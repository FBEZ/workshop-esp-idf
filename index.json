




[{"content":"Welcome to the Espressif Systems ESP-IDF Workshops.\nWorkshop Highlights # Dive into our latest workshops and master the skills you need to maximize the power of the ESP32.\n","date":"12 November 2025","externalUrl":null,"permalink":"/workshop-esp-idf/","section":"Espressif ESP-IDF Workshops","summary":"","title":"Espressif ESP-IDF Workshops","type":"page"},{"content":" Assignment steps # Download the assignment_1_1_base code Run the example (to make sure that everything is working) Create an alarm component Add the component configuration Download the assignment_1_1_base code # There are two ways to download the code:\nDownload the ZIP file from the repository:\nGo to the GitHub repository Click the green ‚ÄúCode‚Äù button In the dropdown menu that appears, click ‚ÄúDownload ZIP‚Äù Clone the repository using git:\ngit clone https://github.com/FBEZ-docs-and-templates/devrel-advanced-workshop-code Run the example # To test that everything it\u0026rsquo;s working, first you need to run the example.\nOpen the folder assignment_1_1_base with VSCode\nAmong the folders in the repository, assignment_1_1_base and assignment_3_2_base contain the starter code for exercises 1.1 and 3.2, respectively. All other folders contain the solutions for the exercises. Set the target: \u0026gt; ESP-IDF: Set Espressif Device Target Select the port: \u0026gt; ESP-IDF: Select Port to Use (COM, tty, usbserial) Set the AP data:\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí WiFi SSID ‚Üí Set your ssid\n‚Üí WiFi Password ‚Üí Set your password\nBuild, flash and monitor the device\n\u0026gt; ESP-IDF: Build, Flash, and Start a Monitor on Your Device\n(or hit the flame icon (üî•) located in the bottom bar) You should now see the example running and connecting to your WiFi network and to the mqtt://test.mosquitto.org server.\nShow terminal output I (30) boot: ESP-IDF v5.4.2-dirty 2nd stage bootloader I (30) boot: compile time Jul 22 2025 10:52:56 I (30) boot: chip revision: v0.1 I (31) boot: efuse block revision: v1.0 I (34) boot.esp32c3: SPI Speed : 80MHz I (38) boot.esp32c3: SPI Mode : DIO I (42) boot.esp32c3: SPI Flash Size : 2MB I (46) boot: Enabling RNG early entropy source... I (50) boot: Partition Table: I (53) boot: ## Label Usage Type ST Offset Length I (59) boot: 0 nvs WiFi data 01 02 00009000 00006000 I (66) boot: 1 phy_init RF data 01 01 0000f000 00001000 I (72) boot: 2 factory factory app 00 00 00010000 00100000 I (79) boot: End of partition table I (82) esp_image: segment 0: paddr=00010020 vaddr=3c0c0020 size=1e7ech (124908) map I (109) esp_image: segment 1: paddr=0002e814 vaddr=3fc93c00 size=01804h ( 6148) load I (111) esp_image: segment 2: paddr=00030020 vaddr=42000020 size=b1fd4h (729044) map I (229) esp_image: segment 3: paddr=000e1ffc vaddr=3fc95404 size=01620h ( 5664) load I (231) esp_image: segment 4: paddr=000e3624 vaddr=40380000 size=13b38h ( 80696) load I (248) esp_image: segment 5: paddr=000f7164 vaddr=50000000 size=0001ch ( 28) load I (254) boot: Loaded app from partition at offset 0x10000 I (254) boot: Disabling RNG early entropy source... I (265) cpu_start: Unicore app I (274) cpu_start: Pro cpu start user code I (274) cpu_start: cpu freq: 160000000 Hz I (274) app_init: Application information: I (274) app_init: Project name: mqtt_tcp I (278) app_init: App version: 1 I (281) app_init: Compile time: Jul 22 2025 10:53:00 I (286) app_init: ELF file SHA256: b10017352... I (291) app_init: ESP-IDF: v5.4.2-dirty I (295) efuse_init: Min chip rev: v0.1 I (299) efuse_init: Max chip rev: v1.99 I (303) efuse_init: Chip rev: v0.1 I (307) heap_init: Initializing. RAM available for dynamic allocation: I (313) heap_init: At 3FC9B2E0 len 00024D20 (147 KiB): RAM I (318) heap_init: At 3FCC0000 len 0001C710 (113 KiB): Retention RAM I (324) heap_init: At 3FCDC710 len 00002B50 (10 KiB): Retention RAM I (330) heap_init: At 5000001C len 00001FCC (7 KiB): RTCRAM I (336) spi_flash: detected chip: generic I (339) spi_flash: flash io: dio W (342) spi_flash: Detected size(4096k) larger than the size in the binary image header(2048k). Using the size in the binary image header. I (355) sleep_gpio: Configure to isolate all GPIO pins in sleep state I (361) sleep_gpio: Enable automatic switching of GPIO sleep configuration I (367) main_task: Started on CPU0 I (377) main_task: Calling app_main() I (377) mqtt_example: [APP] Startup.. I (377) mqtt_example: [APP] Free memory: 270780 bytes I (377) mqtt_example: [APP] IDF version: v5.4.2-dirty I (397) temperature_sensor: Range [-10¬∞C ~ 80¬∞C], error \u0026lt; 1¬∞C I (397) example_connect: Start example_connect. I (397) pp: pp rom version: 8459080 I (397) net80211: net80211 rom version: 8459080 I (417) wifi:wifi driver task: 3fca3b0c, prio:23, stack:6656, core=0 I (417) wifi:wifi firmware version: bea31f3 I (417) wifi:wifi certification version: v7.0 I (417) wifi:config NVS flash: enabled I (417) wifi:config nano formatting: disabled I (427) wifi:Init data frame dynamic rx buffer num: 32 I (427) wifi:Init static rx mgmt buffer num: 5 I (437) wifi:Init management short buffer num: 32 I (437) wifi:Init dynamic tx buffer num: 32 I (447) wifi:Init static tx FG buffer num: 2 I (447) wifi:Init static rx buffer size: 1600 I (447) wifi:Init static rx buffer num: 10 I (457) wifi:Init dynamic rx buffer num: 32 I (457) wifi_init: rx ba win: 6 I (457) wifi_init: accept mbox: 6 I (467) wifi_init: tcpip mbox: 32 I (467) wifi_init: udp mbox: 6 I (467) wifi_init: tcp mbox: 6 I (477) wifi_init: tcp tx win: 5760 I (477) wifi_init: tcp rx win: 5760 I (477) wifi_init: tcp mss: 1440 I (487) wifi_init: WiFi IRAM OP enabled I (487) wifi_init: WiFi RX IRAM OP enabled I (487) phy_init: phy_version 1201,bae5dd99,Mar 3 2025,15:36:21 I (527) wifi:mode : sta (7c:df:a1:42:64:70) I (527) wifi:enable tsf I (527) example_connect: Connecting to SamsungFrancesco... W (527) wifi:Password length matches WPA2 standards, authmode threshold changes from OPEN to WPA2 I (537) example_connect: Waiting for IP(s) I (3057) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (3057) wifi:state: init -\u0026gt; auth (0xb0) I (4057) wifi:state: auth -\u0026gt; init (0x200) I (4057) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (4057) example_connect: Wi-Fi disconnected 2, trying to reconnect... I (6477) example_connect: Wi-Fi disconnected 205, trying to reconnect... I (8887) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (8887) wifi:state: init -\u0026gt; auth (0xb0) I (8967) wifi:state: auth -\u0026gt; assoc (0x0) I (9017) wifi:state: assoc -\u0026gt; run (0x10) I (9087) wifi:connected with SamsungFrancesco, aid = 1, channel 1, BW20, bssid = ce:db:d8:a6:6b:2a I (9087) wifi:security: WPA2-PSK, phy: bgn, rssi: -50 I (9087) wifi:pm start, type: 1 I (9097) wifi:dp: 1, bi: 102400, li: 3, scale listen interval from 307200 us to 307200 us I (9107) wifi:set rx beacon pti, rx_bcn_pti: 0, bcn_timeout: 25000, mt_pti: 0, mt_time: 10000 I (9147) wifi:\u0026lt;ba-add\u0026gt;idx:0 (ifx:0, ce:db:d8:a6:6b:2a), tid:0, ssn:1, winSize:64 I (9177) wifi:dp: 2, bi: 102400, li: 4, scale listen interval from 307200 us to 409600 us I (9177) wifi:AP\u0026#39;s beacon interval = 102400 us, DTIM period = 2 I (10157) esp_netif_handlers: example_netif_sta ip: 10.75.149.18, mask: 255.255.255.0, gw: 10.75.149.225 I (10157) example_connect: Got IPv4 event: Interface \u0026#34;example_netif_sta\u0026#34; address: 10.75.149.18 I (10397) example_connect: Got IPv6 event: Interface \u0026#34;example_netif_sta\u0026#34; address: fe80:0000:0000:0000:7edf:a1ff:fe42:6470, type: ESP_IP6_ADDR_IS_LINK_LOCAL I (10397) example_common: Connected to example_netif_sta I (10397) example_common: - IPv4 address: 10.75.149.18, I (10407) example_common: - IPv6 address: fe80:0000:0000:0000:7edf:a1ff:fe42:6470, type: ESP_IP6_ADDR_IS_LINK_LOCAL I (10417) mqtt_example: Other event id:7 I (15517) mqtt_example: Temperature: 37.60 ¬∞C E (19627) transport_base: tcp_read error, errno=Connection reset by peer E (19627) mqtt_client: esp_mqtt_handle_transport_read_error: transport_read() error: errno=104 I (19637) mqtt_example: MQTT_EVENT_ERROR E (19637) mqtt_example: Last error captured as transport\u0026#39;s socket errno: 0x68 I (19647) mqtt_example: Last errno string (Connection reset by peer) E (19647) mqtt_client: esp_mqtt_connect: mqtt_message_receive() returned -2 E (19657) mqtt_client: MQTT connect failed I (19657) mqtt_example: MQTT_EVENT_DISCONNECTED I (20567) mqtt_example: Temperature: 36.60 ¬∞C I (25667) mqtt_example: Temperature: 36.60 ¬∞C I (29667) mqtt_example: Other event id:7 I (30667) mqtt_example: Temperature: 36.60 ¬∞C Create the alarm component # To create the alarm component, you need to\n\u0026gt; ESP-IDF: Create New ESP-IDF Component\n‚Üí alarm\nA new components/alarm folder is crated.\nMove the files into the component folder\nalarm.c ‚Üí components/alarm/alarm.c\nalarm.h ‚Üí components/alarm/include/alarm.h\nAdd the esp_timer requirement to the component CMakeLists.txt\nidf_component_register(SRCS \u0026#34;alarm.c\u0026#34; REQUIRES esp_timer INCLUDE_DIRS \u0026#34;include\u0026#34;) You didn\u0026rsquo;t need to add REQUIRES esp_timer in the main component, because it automatically requires all other components in the build Remove \u0026ldquo;alarm.c\u0026rdquo; from th main/CMakeLists.txt\nidf_component_register(SRCS \u0026#34;app_main.c\u0026#34; INCLUDE_DIRS \u0026#34;.\u0026#34;) Add the component configuration # Open the file components/alarm/alarm.c There you can find two hardcoded values\n#define ALARM_THRESHOLD_PERCENT 2 // 2% chance #define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms We will replace these values with component configurations.\nCreate a Kconfig file in the root directory of the alarm component Add the following to Kconfig\nmenu \u0026#34;Alarm Component Configuration\u0026#34; config ALARM_THRESHOLD_PERCENT int \u0026#34;Alarm threshold percent\u0026#34; default 2 range 0 100 help Set the threshold percent for the alarm (e.g., 2 for 2% chance). config ALARM_REFRESH_INTERVAL_MS int \u0026#34;Alarm refresh interval (ms)\u0026#34; default 1000 range 1 60000 help Set the interval in milliseconds to reevaluate the alarm. endmenu Comment out the defines\n//#define ALARM_THRESHOLD_PERCENT 2 // 2% chance //#define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms Replace the macro name in the rest of the code\nALARM_THRESHOLD_PERCENT ‚Üí CONFIG_ALARM_THRESHOLD_PERCENT ALARM_REFRESH_INTERVAL_MS ‚Üí CONFIG_ALARM_REFRESH_INTERVAL_MS Clean the project: ESP-IDF: Full Clean Project Rebuild and flash: ESP-IDF: Build, Flash and Start Monitor on Your Device Assignment solution code # Show full assignment code alarm.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_random.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; // for esp_timer_get_time() // Define internal behavior constants // #define ALARM_THRESHOLD_PERCENT 2 // 2% chance // #define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms // Internal alarm structure (hidden from user) struct alarm_t { int64_t last_check_time_us; bool last_state; }; alarm_t* alarm_create(void) { alarm_t *alarm = malloc(sizeof(alarm_t)); if (!alarm) return NULL; alarm-\u0026gt;last_check_time_us = 0; alarm-\u0026gt;last_state = false; return alarm; } bool is_alarm_set(alarm_t *alarm) { if (!alarm) return false; int64_t now_us = esp_timer_get_time(); int64_t elapsed_us = now_us - alarm-\u0026gt;last_check_time_us; if (elapsed_us \u0026gt;= CONFIG_ALARM_REFRESH_INTERVAL_MS * 1000) { uint32_t rand_val = esp_random() % 100; alarm-\u0026gt;last_state = rand_val \u0026lt; CONFIG_ALARM_THRESHOLD_PERCENT; alarm-\u0026gt;last_check_time_us = now_us; } return alarm-\u0026gt;last_state; } void alarm_delete(alarm_t *alarm) { if (alarm) { free(alarm); } } Kconfig\nmenu \u0026#34;Alarm Component Configuration\u0026#34; config ALARM_THRESHOLD_PERCENT int \u0026#34;Alarm threshold percent\u0026#34; default 2 range 0 100 help Set the threshold percent for the alarm (e.g., 2 for 2% chance). config ALARM_REFRESH_INTERVAL_MS int \u0026#34;Alarm refresh interval (ms)\u0026#34; default 1000 range 1 60000 help Set the interval in milliseconds to reevaluate the alarm. You can find the whole solution project on the assignment_1_1 folder on the github repo.\nNext step: Assignment 1.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-1-1/","section":"Workshops","summary":"Create the \u003ccode\u003ealarm\u003c/code\u003e component and refactor the code to use it. (Guided)","title":"ESP-IDF Adv. - Assign.  1.1","type":"workshops"},{"content":"In this second part, we will separate the connection logic from the main function. The main advantage of this approach is that you could transparently change the connection type (e.g. to MQTTS or HTTP).\nIn this assignment, we will refactor the connection to Wi-Fi and MQTT code to fit into a new component.\nAssignment details # Create a cloud_manager component with\nThe following public interface:\ncloud_manager_t *cloud_manager_create(void); esp_err_t cloud_manager_connect(cloud_manager_t *manager); esp_err_t cloud_manager_disconnect(cloud_manager_t *manager); esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp); esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager); void cloud_manager_delete(cloud_manager_t *manager); The following parameters - settable through menuconfig:\nBroker URL (move it from the main to the cloud_manager component) The channel where the temperature is published (sensor/temperature by default) The channel where the alarm is published (sensor/alarm by default) Solution outline # Create a new component and fill cloud_manager.h Add the suggested methods\nAdd an opaque declaration typedef struct cloud_manager_t cloud_manager_t; In cloud_manager.h you need to import just esp_err.h Fill cloud_manager.c\nImplement cloud_manager_t as: struct cloud_manager_t { esp_mqtt_client_handle_t client; esp_mqtt_client_config_t mqtt_cfg; }; In cloud_manager_create just return the initialized object. In cloud_manager_connect initialize everything. You can use the function example_connect. Add the following to the cloud_manager component CMakeList.txt\nPRIV_REQUIRES mqtt nvs_flash esp_netif protocol_examples_common In app_main.c\nInitialize and connect to the cloud_manager cloud_manager_t *cloud = cloud_manager_create(); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); Call the publishing functions in the appropriate position Assignment solution code # Show full assignment code cloud_manager.h # #pragma once #include \u0026#34;esp_err.h\u0026#34; typedef struct cloud_manager_t cloud_manager_t; /** * @brief Creates a new cloud manager instance */ cloud_manager_t *cloud_manager_create(void); /** * @brief Connects the cloud manager (starts MQTT) */ esp_err_t cloud_manager_connect(cloud_manager_t *manager); /** * @brief Disconnects the cloud manager */ esp_err_t cloud_manager_disconnect(cloud_manager_t *manager); /** * @brief Sends a temperature value to the cloud */ esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp); /** * @brief Sends an alarm event to the cloud */ esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager); /** * @brief Frees the memory */ void cloud_manager_delete(cloud_manager_t *manager); cloud_manager.c # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;mqtt_client.h\u0026#34; #include \u0026#34;nvs_flash.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_netif.h\u0026#34; #include \u0026#34;protocol_examples_common.h\u0026#34; static const char *TAG = \u0026#34;cloud_manager\u0026#34;; struct cloud_manager_t { esp_mqtt_client_handle_t client; esp_mqtt_client_config_t mqtt_cfg; }; // Event handler for MQTT static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_mqtt_event_handle_t event = event_data; esp_mqtt_client_handle_t client = event-\u0026gt;client; switch ((esp_mqtt_event_id_t)event_id) { case MQTT_EVENT_CONNECTED: ESP_LOGI(TAG, \u0026#34;Connected to MQTT broker\u0026#34;); esp_mqtt_client_subscribe(client, CONFIG_TEMPERATURE_CHANNEL, 0); esp_mqtt_client_subscribe(client, CONFIG_ALARM_CHANNEL, 0); break; case MQTT_EVENT_DISCONNECTED: ESP_LOGI(TAG, \u0026#34;Disconnected from MQTT broker\u0026#34;); break; case MQTT_EVENT_PUBLISHED: ESP_LOGI(TAG, \u0026#34;Message published (msg_id=%d)\u0026#34;, event-\u0026gt;msg_id); break; case MQTT_EVENT_ERROR: ESP_LOGE(TAG, \u0026#34;MQTT_EVENT_ERROR\u0026#34;); break; default: break; } } cloud_manager_t *cloud_manager_create(void) { cloud_manager_t *manager = calloc(1, sizeof(cloud_manager_t)); if (!manager) return NULL; manager-\u0026gt;mqtt_cfg = (esp_mqtt_client_config_t){ .broker.address.uri = CONFIG_BROKER_URL, }; return manager; } esp_err_t cloud_manager_connect(cloud_manager_t *manager) { if(manager == NULL){return ESP_ERR_INVALID_ARG;} ESP_ERROR_CHECK(nvs_flash_init()); ESP_ERROR_CHECK(esp_netif_init()); manager-\u0026gt;client = esp_mqtt_client_init(\u0026amp;manager-\u0026gt;mqtt_cfg); esp_mqtt_client_register_event(manager-\u0026gt;client, ESP_EVENT_ANY_ID, mqtt_event_handler, manager); ESP_ERROR_CHECK(example_connect()); return esp_mqtt_client_start(manager-\u0026gt;client); } esp_err_t cloud_manager_disconnect(cloud_manager_t *manager) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; return esp_mqtt_client_stop(manager-\u0026gt;client); } esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; char payload[64]; snprintf(payload, sizeof(payload), \u0026#34;%.2f\u0026#34;, temp); ESP_LOGI(TAG, \u0026#34;Temperature: %.2f ¬∞C\u0026#34;, temp); int msg_id = esp_mqtt_client_publish(manager-\u0026gt;client, CONFIG_TEMPERATURE_CHANNEL, payload, 0, 1, 0); return msg_id \u0026gt;= 0 ? ESP_OK : ESP_FAIL; } esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; const char *alarm_payload = \u0026#34;ALARM ON!\u0026#34;; int msg_id = esp_mqtt_client_publish(manager-\u0026gt;client, CONFIG_ALARM_CHANNEL, alarm_payload, 0, 1, 0); return msg_id \u0026gt;= 0 ? ESP_OK : ESP_FAIL; } void cloud_manager_delete(cloud_manager_t *manager) { if (manager) { free(manager); } } Kconfig # menu \u0026#34;Cloud MQTT Configuration\u0026#34; config BROKER_URL string \u0026#34;Broker URL\u0026#34; default \u0026#34;mqtt://test.mosquitto.org/\u0026#34; help URL of the broker to connect to config TEMPERATURE_CHANNEL string \u0026#34;MQTT channel for publishing the temperature\u0026#34; default \u0026#34;/sensor/temperature\u0026#34; help The channel in the mqtt broker where the temperature is published config ALARM_CHANNEL string \u0026#34;MQTT channel for publishing the alarm\u0026#34; default \u0026#34;/sensor/alarm\u0026#34; help The channel in the mqtt broker where the alarm is published endmenu You can find the whole solution project on the assignment_1_2 folder on the github repo.\nNext step: Assignment 1.3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-1-2/","section":"Workshops","summary":"Create a \u003ccode\u003ecloud_manager\u003c/code\u003e component and refactor the code to use it.","title":"ESP-IDF Adv. - Assign.  1.2","type":"workshops"},{"content":"In this assignment, you will create two versions of sdkconfig, one for production and the other debug. The only difference between the two is the logging: Debug will display all logs, while production has all the logs suppressed.\nAssignment goal # You project must have the following configuration files:\nsdkconfig.defaults: containing the esp32-c3 target sdkconfig.prod: containing the logging suppression configuration (both app log and bootloader log) sdkconfig.debug: containing the logging enable configuration profile files to simplify the build command The final project folder tree is\n. |-- main | |-- CMakeLists.txt | |-- app_main.c | `-- idf_component.yml |-- profiles | |-- debug | `-- prod |-- sdkconfig |-- sdkconfig.debug |-- sdkconfig.defaults |-- sdkconfig.old `-- sdkconfig.prod Assignment steps # We will:\nCreate the production sdkconfig version (guided) Create a profile file (guided) Create the debug sdkconfig version Create production version (guided) # To create the debug configuration, we first need to find the log configuration.\nChanging the configuration in menuconfig # ESP-IDF: SDK Configuration Editor (menuconfig)\nSearch for log Uncheck the fields\nBootloader Config ‚Üí Bootloader log verbosity Log ‚Üí Log Lever ‚Üí Default log verbosity Create sdkconfig.prod file # The easiest way to find the configuration names that we changed is to run the save-defconfig tool, which will generate a sdkconfig.defaults file with only the changed parameters.\nESP-IDF: Save Default Config File (save-defconfig) Looking at the new sdkconfig.defaults, we can see two new configurations:\nCONFIG_LOG_DEFAULT_LEVEL_NONE=y CONFIG_BOOTLOADER_LOG_LEVEL_NONE=y Cut these configs and paste them into a sdkconfig.prod file Build and flash # To build the project use\nidf.py -B build-production -DSDKCONFIG=build-production/sdkconfig -DSDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.defaults;sdkconfig.prod\u0026#34; build It will create a build-production folder for this version.\nTo flash the project, you just need to specify the build folder, which already contains all the required information\nidf.py -B build-debug -p \u0026lt;YOUR_PORT\u0026gt; flash monitor Create Profile files # To simplify the process we will create a profile file.\nCreate a profile folder Create a prod file inside the folder Add the CLI parameters\n-B build-production -DSDKCONFIG=build-production/sdkconfig -DSDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.defaults;sdkconfig.prod\u0026#34; We can now build the production version using\nidf.py @profiles/prod build Debug version # Now you can do the same for the debugging setup. For this assignment step, you need to create and fill:\nsdkconfig.debug profile/debug Assignment solution code # Show solution code skdconfig.defaults\n# This file was generated using idf.py save-defconfig. It can be edited manually. # Espressif IoT Development Framework (ESP-IDF) 5.4.2 Project Minimal Configuration # CONFIG_IDF_TARGET=\u0026#34;esp32c3\u0026#34; skdconfig.prod\nCONFIG_LOG_DEFAULT_LEVEL_NONE=y CONFIG_BOOTLOADER_LOG_LEVEL_NONE=y skdconfig.prod\nCONFIG_LOG_DEFAULT_LEVEL_INFO=y You can find the whole solution project in the assignment_1_3 folder in the GitHub repo.\nNext step: Lecture 2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-1-3/","section":"Workshops","summary":"Support multiple configurations via sdkconfigs (Guided)","title":"ESP-IDF Adv. - Assign.  1.3","type":"workshops"},{"content":"In this assignment, we will decouple the alarm and temperature code by using the default event loop.\nIn the previous assignment code, we were already indirectly using this event loop for capturing MQTT and Wi-Fi events. Assignment steps # Create the events\nTEMP_EVENT_BASE - temp_event_id ALARM_EVENT_BASE - alarm_event_id_t Create the handler functions\nalarm_event_handler temp_event_handler Register the handler functions Create the two timers\nesp_timer_create esp_timer_start_periodic Create the timer callback functions to post the event every 5s and 200ms\ntemp_timer_callback alarm_timer_callback Create a infinite sleep loop in main Create the events # Define the two event bases outside any function (global)\nESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); Define their event_id as an enum (in this case, both comprise just a single value):\ntypedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, } alarm_event_id_t; Create handler funcions # We create the two event handler functions which do the actual job of posting the data on the MQTT channel.\nCreate the two handler function: static void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Failed to read temperature\u0026#34;); } } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { if (is_alarm_set(alarm)) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALARM ON!!\u0026#34;); cloud_manager_send_alarm(cloud); } } Register the handler functions # In the app_main register the two handler function:\nESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); Create the timers # The actual source of event in this assignment are timers, so we need to start two of them.\nCreate and start the temperature and alarm timers: // Create and start periodic timers (app_main) // Temperature timer const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); // Alarm timer const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(alarm_timer, ALARM_CHECK_PERIOD_US)); The two macros ALARM_CHECK_PERIOD_US and TEMPERATURE_MEAS_PERIOD_US could be added as defines at the beginning of the code or as a module\u0026rsquo;s parameter.\nFor the sake of semplicity, define them at the beginning of app_main.c as #define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) Create the timer callback functions # In the previous code, we gave as .callback the functions temp_timer_callback and a alarm_timer_callback. These functions are called when the timer expires.\nCreate the timer call back function to post the corresponding event static void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } The event loop will take care of calling the right function when the event is triggered.\nMain sleep # The last thing to do, is to let the main continue to run while events are triggered.\nAdd an infinite idle loop\nwhile (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } Assignment solution code # Show full assignment code #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;temperature_sensor.h\u0026#34; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; #define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) ESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); static bool previous_alarm_set = false; typedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, } alarm_event_id_t; static temperature_sensor_t *sensor = NULL; static alarm_t *alarm = NULL; static cloud_manager_t *cloud = NULL; static void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Failed to read temperature\u0026#34;); } } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { bool alarm_state = is_alarm_set(alarm); if (alarm_state \u0026amp;\u0026amp; !previous_alarm_set) { printf(\u0026#34;ALARM ON!!\\n\u0026#34;); cloud_manager_send_alarm(cloud); } previous_alarm_set = alarm_state; } static void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } void app_main(void) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Starting...\u0026#34;); ESP_ERROR_CHECK(esp_event_loop_create_default()); sensor = temperature_sensor_create(); alarm = alarm_create(); cloud = cloud_manager_create(); printf(\u0026#34;Connecting...\\n\u0026#34;); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); printf(\u0026#34;Connected!\\n\u0026#34;); // Register event handlers ESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); // Create and start periodic timers const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(alarm_timer, ALARM_CHECK_PERIOD_US)); // The main task can now just sleep while (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } // Cleanup (unreachable in this example) cloud_manager_disconnect(cloud); cloud_manager_delete(cloud); temperature_sensor_delete(sensor); alarm_delete(alarm); } You can find the whole solution project in the assignment_2_1 folder in the GitHub repo.\nConclusion # Using an event loop decouples the management of the alarm and temperature sensor. In this specific assignment, we could have reached the same result by using the timers callback function to do the same and avoid all the event loop overhead. But in general, events can come from a variety of sources and event loop offer an unified approach to decouple the application logic.\nNext step # If you still have time: Assignment 2.2.\nIn exercise 2.2, you‚Äôll add another event source ‚Äî this time triggered by a GPIO.\nOtherwise: Lecture 3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-2-1/","section":"Workshops","summary":"Event loop: Manage temperature and alarm sensor via events (guided)","title":"ESP-IDF Adv. - Assign.  2.1","type":"workshops"},{"content":"In this assignment you\u0026rsquo;ll extend the functionality from Assignment 2.1 by introducing an additional event source: When GPIO9 is pressed, an \u0026ldquo;alarm\u0026rdquo; event is posted to the system.\nAssignment goals # The code for detecting a GPIO press is provided below. You need to integrate the logic into the existing event loop. Use the same ALARM_EVENT_BASE as the alarm trigger used before. Create a ALARM_EVENT_BUTTON to differenciate it from the ALARM_EVENT_CHECK. Tips # There is an alternative version for esp_event_post called esp_event_isr_post. Reading GPIO code # #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;esp_attr.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #define GPIO_INPUT_IO_9 9 #define ESP_INTR_FLAG_DEFAULT 0 static const char *TAG = \u0026#34;example\u0026#34;; // ISR handler static void gpio_isr_handler(void* arg) { uint32_t gpio_num = (uint32_t) arg; ESP_EARLY_LOGI(TAG, \u0026#34;GPIO[%d] interrupt triggered\u0026#34;, gpio_num); } void app_main(void) { gpio_config_t io_conf = { .intr_type = GPIO_INTR_NEGEDGE, // Falling edge interrupt .mode = GPIO_MODE_INPUT, // Set as input mode .pin_bit_mask = (1ULL \u0026lt;\u0026lt; GPIO_INPUT_IO_9), .pull_up_en = GPIO_PULLUP_ENABLE, // Enable pull-up .pull_down_en = GPIO_PULLDOWN_DISABLE, }; gpio_config(\u0026amp;io_conf); // Install GPIO ISR service gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT); // Hook ISR handler for specific GPIO pin gpio_isr_handler_add(GPIO_INPUT_IO_9, gpio_isr_handler, (void*) GPIO_INPUT_IO_9); ESP_LOGI(TAG, \u0026#34;GPIO 9 configured as input with falling edge interrupt\u0026#34;); } Assignment solution code # Show full assignment code #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;temperature_sensor.h\u0026#34; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;esp_attr.h\u0026#34; #define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) #define GPIO_INPUT_IO_9 9 #define ESP_INTR_FLAG_DEFAULT 0 static const char *TAG = \u0026#34;assignment2_2\u0026#34;; // EVENTS ESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); static bool previous_alarm_set = false; typedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, ALARM_EVENT_BUTTON } alarm_event_id_t; // GPIO // ISR handler static void gpio_isr_handler(void* arg) { uint32_t gpio_num = (uint32_t) arg; // Now that we post the event, we remove the log: // It is not recommended to log or print inside an ISR // // ESP_EARLY_LOGI(TAG, \u0026#34;GPIO[%d] interrupt triggered\u0026#34;, gpio_num); esp_event_isr_post(ALARM_EVENT_BASE, ALARM_EVENT_BUTTON, NULL, 0, 0); } static temperature_sensor_t *sensor = NULL; static alarm_t *alarm = NULL; static cloud_manager_t *cloud = NULL; static void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Failed to read temperature\u0026#34;); } } static void alarm_event_button_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALARM ON!!\u0026#34;); cloud_manager_send_alarm(cloud); } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { bool alarm_state = is_alarm_set(alarm); if (alarm_state \u0026amp;\u0026amp; !previous_alarm_set) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALARM ON!!\u0026#34;); cloud_manager_send_alarm(cloud); } previous_alarm_set = alarm_state; } static void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } void app_main(void) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Starting...\u0026#34;); ESP_ERROR_CHECK(esp_event_loop_create_default()); sensor = temperature_sensor_create(); alarm = alarm_create(); cloud = cloud_manager_create(); ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Connecting...\u0026#34;); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Connected!\u0026#34;); // Register event handlers ESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_BUTTON, alarm_event_button_handler, NULL)); // Create and start periodic timers const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); // GPIO gpio_config_t io_conf = { .intr_type = GPIO_INTR_NEGEDGE, // Falling edge interrupt .mode = GPIO_MODE_INPUT, // Set as input mode .pin_bit_mask = (1ULL \u0026lt;\u0026lt; GPIO_INPUT_IO_9), .pull_up_en = GPIO_PULLUP_ENABLE, // Enable pull-up .pull_down_en = GPIO_PULLDOWN_DISABLE, }; gpio_config(\u0026amp;io_conf); // Install GPIO ISR service gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT); // Hook ISR handler for specific GPIO pin gpio_isr_handler_add(GPIO_INPUT_IO_9, gpio_isr_handler, (void*) GPIO_INPUT_IO_9); // The main task can now just sleep while (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } // Cleanup (unreachable in this example) cloud_manager_disconnect(cloud); cloud_manager_delete(cloud); temperature_sensor_delete(sensor); alarm_delete(alarm); } You can find the whole solution project on the assignment_2_2 folder on the github repo.\nNext step # Next step: Lecture 3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-2-2/","section":"Workshops","summary":"Event loop: add an external GPIO event","title":"ESP-IDF Adv. - Assign.  2.2","type":"workshops"},{"content":"In this assignment, you will analyze the binary image size and optimize the memory footprint of your application.\nAssignment steps # Build the original project to spot any oversized or suspicious sections (e.g., .text, .data, .rodata) that may hide unoptimized code. Change configuration to reduce it. Rebuild the project to check the improvement. Build the original project # Reopen the last assignment code (it can be both 2.1 or 2.2) \u0026gt; ESP-IDF: Full Clean Project \u0026gt; ESP-IDF: Build Your Project You will get the summary table of Fig.1 for the binary image.\nFig.1 - Size calculation\nRemoving the logs # Remove the logging output in the menuconfig\nif you don\u0026rsquo;t remember how to do that, check assignment 1.3 \u0026gt; ESP-IDF: Build Your Project Fig.2 - Size calculation after removing logging\nThe binary size is 77kb less than before.\nCertificate Bundle # Open menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Uncheck Certificate Bundle ‚Üí Enable trusted root certificate bundle \u0026gt; ESP-IDF: Build Your Project Fig.3 - Size calculation after removing certificate bundle\nMQTT unused options # Open menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Uncheck ESP-MQTT Configurations ‚Üí Enable MQTT over SSL Uncheck ESP-MQTT Configurations ‚Üí Enable MQTT over Websocket \u0026gt; ESP-IDF: Build Your Project Fig.4 - Size calculation after removing mqtt ssl and websocket support\nWe gained another 6.7kb.\nConclusion # In this assignment, we saw how to check the size of our binary and how to use the menuconfig to removed unused options to improve the memory footprint of our application.\nNext step: Assignment 3.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-3-1/","section":"Workshops","summary":"Reduce binary size by working on configuration.","title":"ESP-IDF Adv. - Assign.  3.1","type":"workshops"},{"content":" Core dump # For this assignment, you need to get the assignment_3_2_base project.\nAssignment steps # We will:\nEnable the core dump in the menuconfig Build and run the application Analyze the core dump Fix the bugs in the project Build and run the application again Enable the core dump # Enable the core dump\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Set Core Dump ‚Üí Data destination ‚Üí Flash \u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Build an run the application # Now wait the core fault to happen.\nWhen it happens, halt the execution (CTRL + ]) Create a new terminal \u0026gt; ESP-IDF: Open ESP-IDF Terminal run idf.py coredump-info \u0026gt; coredump.txt Open the file coredump.txt Analyze the core dump # Now look closely to the core dump file.\nClick here if you couldn't generate coredump.txt Executing action: coredump-info Serial port /dev/cu.usbmodem1131101 Connecting... Detecting chip type... ESP32-C3 =============================================================== ==================== ESP32 CORE DUMP START ==================== Crashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;, GDB name: \u0026#39;process 1070202648\u0026#39; Crashed task is not in the interrupt context ================== CURRENT THREAD REGISTERS =================== ra 0x4200d822\t0x4200d822 \u0026lt;is_alarm_set+20\u0026gt; sp 0x3fc9fe50\t0x3fc9fe50 gp 0x3fc94600\t0x3fc94600 \u0026lt;country_info_24ghz+200\u0026gt; tp 0x3fc9ff10\t0x3fc9ff10 t0 0x4005890e\t1074104590 t1 0x90000000\t-1879048192 t2 0xffffffff\t-1 fp 0x0\t0x0 s1 0x8b7f7a\t9142138 a0 0x8b7f7a\t9142138 a1 0x0\t0 a2 0x8b7f7a0\t146274208 a3 0x0\t0 a4 0x4ddf\t19935 a5 0x4c4b3f\t4999999 a6 0x60023000\t1610756096 a7 0xa\t10 s2 0x0\t0 s3 0x0\t0 s4 0xffffffff\t-1 s5 0x0\t0 s6 0xffffffff\t-1 s7 0x0\t0 s8 0x0\t0 s9 0x0\t0 s10 0x0\t0 s11 0x0\t0 t3 0x0\t0 t4 0xfe42\t65090 t5 0x0\t0 t6 0x0\t0 pc 0x4200d840\t0x4200d840 \u0026lt;is_alarm_set+50\u0026gt; ==================== CURRENT THREAD STACK ===================== #0 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 #1 0x4200d48c in alarm_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:66 #2 0x420b1944 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x4c4b3f\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #3 0x420b2290 in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #4 0x420b2388 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================== THREADS INFO ========================= Id Target Id Frame * 1 process 1070202648 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 2 process 1070198548 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 3 process 1070209148 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 4 process 1070196668 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 5 process 1070253776 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 6 process 1070222780 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 7 process 1070191796 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 TCB NAME PRIO C/B STACK USED/FREE ---------- ---------------- -------- ---------------- 0x3fc9ff18 sys_evt 20/20 352/2460 0x3fc9ef14 IDLE 0/0 208/1312 0x3fca187c tiT 18/18 336/3240 0x3fc9e7bc main 1/1 336/3752 0x3fcac6d0 mqtt_task 5/5 768/5372 0x3fca4dbc wifi 23/23 336/6312 0x3fc9d4b4 esp_timer 22/22 224/3856 ==================== THREAD 1 (TCB: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;) ===================== #0 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 #1 0x4200d48c in alarm_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:66 #2 0x420b1944 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x4c4b3f\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #3 0x420b2290 in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #4 0x420b2388 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 2 (TCB: 0x3fc9ef14, name: \u0026#39;IDLE\u0026#39;) ===================== #0 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 #1 0x42015ce8 in esp_vApplicationIdleHook () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/freertos_hooks.c:58 #2 0x4038859c in prvIdleTask (pvParameters=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:4341 #3 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 3 (TCB: 0x3fca187c, name: \u0026#39;tiT\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca099c, pvBuffer=pvBuffer@entry=0x3fca182c, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=6) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x42086ae8 in sys_arch_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c, timeout=60) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:313 #4 0x420710ea in tcpip_timeouts_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:104 #5 0x420711dc in tcpip_thread (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:142 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 4 (TCB: 0x3fc9e7bc, name: \u0026#39;main\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40388d04 in vTaskDelay (xTicksToDelay=xTicksToDelay@entry=100) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:1588 #3 0x4200d7e8 in app_main () at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:136 #4 0x420b420e in main_task (args=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/app_startup.c:208 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 5 (TCB: 0x3fcac6d0, name: \u0026#39;mqtt_task\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x403875bc in xQueueSemaphoreTake (xQueue=0x3fcac8e0, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1901 #3 0x42086910 in sys_arch_sem_wait (sem=sem@entry=0x3fcac8d0, timeout=timeout@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:165 #4 0x420713d4 in tcpip_send_msg_wait_sem (fn=\u0026lt;optimized out\u0026gt;, apimsg=apimsg@entry=0x3fcae33c, sem=0x3fcac8d0) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:461 #5 0x42088840 in netconn_gethostbyname_addrtype (name=name@entry=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, addr=addr@entry=0x3fcae3a8, dns_addrtype=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/api_lib.c:1333 #6 0x4206de2a in lwip_getaddrinfo (nodename=nodename@entry=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, servname=servname@entry=0x0, hints=hints@entry=0x3fcae3fc, res=res@entry=0x3fcae41c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/netdb.c:495 #7 0x42021468 in getaddrinfo (nodename=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, servname=0x0, hints=0x3fcae3fc, res=0x3fcae41c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/include/lwip/netdb.h:23 #8 esp_tls_hostname_to_fd (host=\u0026lt;optimized out\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=1883, addr_family=\u0026lt;optimized out\u0026gt;, address=address@entry=0x3fcae464, fd=fd@entry=0x3fcae460) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:210 #9 0x420218c4 in tcp_connect (host=host@entry=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=port@entry=1883, cfg=cfg@entry=0x3fcac83c, error_handle=error_handle@entry=0x3fcac824, sockfd=sockfd@entry=0x3fcac8a0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:359 #10 0x42021ebc in esp_tls_plain_tcp_connect (host=host@entry=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=port@entry=1883, cfg=cfg@entry=0x3fcac83c, error_handle=error_handle@entry=0x3fcac824, sockfd=sockfd@entry=0x3fcac8a0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:533 #11 0x42023e06 in tcp_connect (t=\u0026lt;optimized out\u0026gt;, host=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, port=1883, timeout_ms=10000) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport_ssl.c:148 #12 0x42023210 in esp_transport_connect (t=\u0026lt;optimized out\u0026gt;, host=\u0026lt;optimized out\u0026gt;, port=\u0026lt;optimized out\u0026gt;, timeout_ms=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport.c:123 #13 0x4200f628 in esp_mqtt_task (pv=0x3fca1a28, pv@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/mqtt/esp-mqtt/mqtt_client.c:1620 #14 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 6 (TCB: 0x3fca4dbc, name: \u0026#39;wifi\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca2c9c, pvBuffer=0x3fca4d48, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x420b3d64 in queue_recv_wrapper (queue=\u0026lt;optimized out\u0026gt;, item=\u0026lt;optimized out\u0026gt;, block_time_tick=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_wifi/esp32c3/esp_adapter.c:238 #4 0x400407be in ppTask () #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 7 (TCB: 0x3fc9d4b4, name: \u0026#39;esp_timer\u0026#39;) ===================== #0 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 #1 0x40387a28 in vPortExitCritical () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:624 #2 0x40389774 in ulTaskGenericNotifyTake (uxIndexToWait=uxIndexToWait@entry=0, xClearCountOnExit=xClearCountOnExit@entry=1, xTicksToWait=xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:5759 #3 0x42017e9a in timer_task (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_timer/src/esp_timer.c:459 #4 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================= ALL MEMORY REGIONS ======================== Name Address Size Attrs .rtc.text 0x50000000 0x0 RW .rtc.force_fast 0x50000000 0x1c RW A .rtc_noinit 0x5000001c 0x0 RW .rtc.force_slow 0x5000001c 0x0 RW .iram0.text 0x40380000 0x13d0a R XA .dram0.data 0x3fc93e00 0x2ed8 RW A .flash.text 0x42000020 0xb4fd8 R XA .flash.appdesc 0x3c0c0020 0x100 R A .flash.rodata 0x3c0c0120 0x1ff3c RW A .eh_frame_hdr 0x3c0e005c 0x0 RW .eh_frame 0x3c0e005c 0x0 RW .flash.tdata 0x3c0e005c 0x0 RW .iram0.data 0x40393e00 0x0 RW .iram0.bss 0x40393e00 0x0 RW .dram0.heap_start 0x3fc9b8e0 0x0 RW .coredump.tasks.data 0x3fc9ff18 0x150 RW .coredump.tasks.data 0x3fc9fdb0 0x160 RW .coredump.tasks.data 0x3fc9ef14 0x150 RW .coredump.tasks.data 0x3fc9ee30 0xd0 RW .coredump.tasks.data 0x3fca187c 0x150 RW .coredump.tasks.data 0x3fca1720 0x150 RW .coredump.tasks.data 0x3fc9e7bc 0x150 RW .coredump.tasks.data 0x3fc9e660 0x150 RW .coredump.tasks.data 0x3fcac6d0 0x150 RW .coredump.tasks.data 0x3fcae240 0x300 RW .coredump.tasks.data 0x3fca4dbc 0x150 RW .coredump.tasks.data 0x3fca4c60 0x150 RW .coredump.tasks.data 0x3fc9d4b4 0x150 RW .coredump.tasks.data 0x3fc9d3c0 0xe0 RW ===================== ESP32 CORE DUMP END ===================== =============================================================== Done! Identify the crashed task and context # The core dump starts with:\nCrashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39; Crashed task is not in the interrupt context From which, we can conclude the following:\nThe crash happened in the FreeRTOS task called sys_evt. The crash did not happen during an interrupt, so it\u0026rsquo;s a normal task context crash. Look at the program counter (PC) and stack trace # The register dump shows:\npc 0x4200d840\t0x4200d840 \u0026lt;is_alarm_set+50\u0026gt; ra 0x4200d822\t0x4200d822 \u0026lt;is_alarm_set+20\u0026gt; sp 0x3fc9fe50 It means that:\nThe program counter (PC) is at address 0x4200d840, inside the function is_alarm_set, specifically at offset +50 bytes. The return address (ra) is also inside is_alarm_set, which means the crash happened inside that function. Examine the stack trace # Stack trace (reversed call order):\n#0 is_alarm_set (alarm=0x0) at alarm.c:40 #1 alarm_event_handler at app_main.c:66 #2 handler_execute (esp_event.c:136) #3 esp_event_loop_run (esp_event.c:696) #4 esp_event_loop_run_task (esp_event.c:106) #5 vPortTaskWrapper (port.c:255) The crash originated from is_alarm_set being called from alarm_event_handler. This handler is called by the ESP-IDF event loop (esp_event_loop_run). Focus on function arguments # Look at is_alarm_set arguments:\n#0 is_alarm_set (alarm=0x0) at alarm.c:40 The argument alarm is 0x0 (NULL pointer) (!) Diagnose the crash reason # The crash happened inside is_alarm_set with a NULL pointer argument. Usually, this means:\nis_alarm_set dereferenced alarm without checking if it was NULL. Since alarm is NULL, accessing its fields caused an invalid memory access, crashing the program. Check the source # The crash line is alarm.c:40. If you look at that line in your source:\nreturn alarm-\u0026gt;last_state; Dereferencing alarm without NULL check causes a fault if alarm == NULL. If we look a couple of lines above, we spot\nalarm = NULL; which is likely our bug.\nBuild and run the application again # Remove the line and the useless else block, to get the following is_alarm_set function.\nbool is_alarm_set(alarm_t *alarm) { int64_t now_us = esp_timer_get_time(); int64_t elapsed_us = now_us - alarm-\u0026gt;last_check_time_us; if (elapsed_us \u0026gt;= CONFIG_ALARM_REFRESH_INTERVAL_MS * 1000) { uint32_t rand_val = esp_random() % 100; alarm-\u0026gt;last_state = rand_val \u0026lt; CONFIG_ALARM_THRESHOLD_PERCENT; alarm-\u0026gt;last_check_time_us = now_us; } return alarm-\u0026gt;last_state; } Rebuild and run the application\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor Another crash! If you still have time, try to solve it by moving to assignment 3.3.\nConclusion # In this assignment, we learnt how to create a core dump and how to analyze it to understand the reason of a core crash. Core dump analysis is a very strong tool to debug your application.\nIf you still have time, try assignment 3.3\nOtherwise\nNext step: Lecture 4\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-3-2/","section":"Workshops","summary":"Explore core dump \u0026ndash; guided","title":"ESP-IDF Adv. - Assign.  3.2","type":"workshops"},{"content":"If you still have time, try to find the other bug in the code by using the info provided by the core dump again.\nSolution steps outline # Create the core dump file as you did in the previous assignment.\nWait for the crash to happen Stop monitor (CTRL + ]) Run idf.py coredump-info \u0026gt; coredump.txt Open the file coredump.txt Expand the second core dump Executing action: coredump-info Serial port /dev/cu.usbmodem1131101 Connecting... Detecting chip type... ESP32-C3 =============================================================== ==================== ESP32 CORE DUMP START ==================== Crashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;, GDB name: \u0026#39;process 1070202648\u0026#39; Crashed task is not in the interrupt context ================== CURRENT THREAD REGISTERS =================== ra 0x4200dc68\t0x4200dc68 \u0026lt;temperature_sensor_read_celsius+10\u0026gt; sp 0x3fc9fe40\t0x3fc9fe40 gp 0x3fc94600\t0x3fc94600 \u0026lt;country_info_24ghz+200\u0026gt; tp 0x3fc9ff10\t0x3fc9ff10 t0 0x4005890e\t1074104590 t1 0x0\t0 t2 0xffffffff\t-1 fp 0x0\t0x0 s1 0x3fc9f13c\t1070199100 a0 0x3fcacc14\t1070255124 a1 0x3fc9fe5c\t1070202460 a2 0x0\t0 a3 0x0\t0 a4 0x3fcacb34\t1070254900 a5 0x0\t0 a6 0x4200d4c2\t1107350722 a7 0x9800000\t159383552 s2 0x0\t0 s3 0x0\t0 s4 0xffffffff\t-1 s5 0x0\t0 s6 0xffffffff\t-1 s7 0x3fcacb44\t1070254916 s8 0x0\t0 s9 0x0\t0 s10 0x0\t0 s11 0x0\t0 t3 0x0\t0 t4 0x604f\t24655 t5 0x0\t0 t6 0x0\t0 pc 0x0\t0x0 ==================== CURRENT THREAD STACK ===================== #0 0x00000000 in ?? () #1 0x4200dc68 in temperature_sensor_read_celsius (sensor=\u0026lt;optimized out\u0026gt;, temperature=temperature@entry=0x3fc9fe5c) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/temperature_sensor/temperature_sensor.c:150 #2 0x4200d4d4 in temp_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:50 #3 0x420b1942 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x0\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #4 0x420b228e in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #5 0x420b2386 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================== THREADS INFO ========================= Id Target Id Frame * 1 process 1070202648 0x00000000 in ?? () 2 process 1070198548 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 3 process 1070254080 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 4 process 1070196668 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 5 process 1070209148 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 6 process 1070222780 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 7 process 1070191796 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 TCB NAME PRIO C/B STACK USED/FREE ---------- ---------------- -------- ---------------- 0x3fc9ff18 sys_evt 20/20 352/2460 0x3fc9ef14 IDLE 0/0 208/1312 0x3fcac800 mqtt_task 5/5 624/5516 0x3fc9e7bc main 1/1 336/3752 0x3fca187c tiT 18/18 336/3240 0x3fca4dbc wifi 23/23 336/6312 0x3fc9d4b4 esp_timer 22/22 224/3856 ==================== THREAD 1 (TCB: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;) ===================== #0 0x00000000 in ?? () #1 0x4200dc68 in temperature_sensor_read_celsius (sensor=\u0026lt;optimized out\u0026gt;, temperature=temperature@entry=0x3fc9fe5c) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/temperature_sensor/temperature_sensor.c:150 #2 0x4200d4d4 in temp_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:50 #3 0x420b1942 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x0\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #4 0x420b228e in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #5 0x420b2386 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 2 (TCB: 0x3fc9ef14, name: \u0026#39;IDLE\u0026#39;) ===================== #0 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 #1 0x42015ce6 in esp_vApplicationIdleHook () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/freertos_hooks.c:58 #2 0x4038859c in prvIdleTask (pvParameters=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:4341 #3 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 3 (TCB: 0x3fcac800, name: \u0026#39;mqtt_task\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x403875bc in xQueueSemaphoreTake (xQueue=0x3fcaca20, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=101) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1901 #3 0x4208695e in sys_arch_sem_wait (sem=\u0026lt;optimized out\u0026gt;, timeout=1000) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:175 #4 0x42070b2a in lwip_select (maxfdp1=55, readset=0x3fcae488, writeset=0x0, exceptset=0x3fcae480, timeout=0x3fcae490) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/sockets.c:2142 #5 0x4200abe8 in esp_vfs_select (nfds=nfds@entry=55, readfds=readfds@entry=0x3fcae488, writefds=writefds@entry=0x0, errorfds=errorfds@entry=0x3fcae480, timeout=0x3fcae490) at /Users/francesco/esp/v5.4.2/esp-idf/components/vfs/vfs.c:1570 #6 0x42023706 in base_poll_read (t=0x3fcac734, timeout_ms=1000) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport_ssl.c:176 #7 0x4202325c in esp_transport_poll_read (t=\u0026lt;optimized out\u0026gt;, timeout_ms=timeout_ms@entry=1000) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport.c:156 #8 0x4200f9f8 in esp_mqtt_task (pv=0x3fca1a28, pv@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/mqtt/esp-mqtt/mqtt_client.c:1736 #9 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 4 (TCB: 0x3fc9e7bc, name: \u0026#39;main\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40388d04 in vTaskDelay (xTicksToDelay=xTicksToDelay@entry=100) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:1588 #3 0x4200d7e8 in app_main () at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:136 #4 0x420b420c in main_task (args=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/app_startup.c:208 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 5 (TCB: 0x3fca187c, name: \u0026#39;tiT\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca099c, pvBuffer=pvBuffer@entry=0x3fca182c, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x42086ae6 in sys_arch_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c, timeout=10) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:313 #4 0x420710e8 in tcpip_timeouts_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:104 #5 0x420711da in tcpip_thread (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:142 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 6 (TCB: 0x3fca4dbc, name: \u0026#39;wifi\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca2c9c, pvBuffer=0x3fca4d48, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x420b3d62 in queue_recv_wrapper (queue=\u0026lt;optimized out\u0026gt;, item=\u0026lt;optimized out\u0026gt;, block_time_tick=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_wifi/esp32c3/esp_adapter.c:238 #4 0x400407be in ppTask () #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 7 (TCB: 0x3fc9d4b4, name: \u0026#39;esp_timer\u0026#39;) ===================== #0 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 #1 0x40387a28 in vPortExitCritical () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:624 #2 0x40389774 in ulTaskGenericNotifyTake (uxIndexToWait=uxIndexToWait@entry=0, xClearCountOnExit=xClearCountOnExit@entry=1, xTicksToWait=xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:5759 #3 0x42017e98 in timer_task (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_timer/src/esp_timer.c:459 #4 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================= ALL MEMORY REGIONS ======================== Name Address Size Attrs .rtc.text 0x50000000 0x0 RW .rtc.force_fast 0x50000000 0x1c RW A .rtc_noinit 0x5000001c 0x0 RW .rtc.force_slow 0x5000001c 0x0 RW .iram0.text 0x40380000 0x13d0a R XA .dram0.data 0x3fc93e00 0x2ed8 RW A .flash.text 0x42000020 0xb4fd6 R XA .flash.appdesc 0x3c0c0020 0x100 R A .flash.rodata 0x3c0c0120 0x1ff3c RW A .eh_frame_hdr 0x3c0e005c 0x0 RW .eh_frame 0x3c0e005c 0x0 RW .flash.tdata 0x3c0e005c 0x0 RW .iram0.data 0x40393e00 0x0 RW .iram0.bss 0x40393e00 0x0 RW .dram0.heap_start 0x3fc9b8e0 0x0 RW .coredump.tasks.data 0x3fc9ff18 0x150 RW .coredump.tasks.data 0x3fc9fda0 0x170 RW .coredump.tasks.data 0x3fc9ef14 0x150 RW .coredump.tasks.data 0x3fc9ee30 0xd0 RW .coredump.tasks.data 0x3fcac800 0x150 RW .coredump.tasks.data 0x3fcae2c0 0x270 RW .coredump.tasks.data 0x3fc9e7bc 0x150 RW .coredump.tasks.data 0x3fc9e660 0x150 RW .coredump.tasks.data 0x3fca187c 0x150 RW .coredump.tasks.data 0x3fca1720 0x150 RW .coredump.tasks.data 0x3fca4dbc 0x150 RW .coredump.tasks.data 0x3fca4c60 0x150 RW .coredump.tasks.data 0x3fc9d4b4 0x150 RW .coredump.tasks.data 0x3fc9d3c0 0xe0 RW ===================== ESP32 CORE DUMP END ===================== =============================================================== Done! Good bug hunting!\nShow solution The error is caused by line 128 in app_main.c\nfree(sensor); It deletes the sensor object and the temperature reading is using an invalid pointer.\nNext step: Lecture 4\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-3-3/","section":"Workshops","summary":"Explore core dump - DIY","title":"ESP-IDF Adv. - Assign.  3.3","type":"workshops"},{"content":"To perform OTA, we need a partition table with at least two partitions.\nAssignment goals # Check the current partition table Change it to a different default partition table Check the new partition table Check the current partition table # To check the current partition table loaded in your module, you need to:\nRead the flash and dump the partition table in a .bin file Convert the .bin file to a readable format Read the flash # To read the flash, use esptool.py:\nesptool.py -p \u0026lt;YOUR-PORT\u0026gt; read_flash 0x8000 0x1000 partition_table.bin \u0026lt;YOUR-PORT\u0026gt; is the same port you use to flash the device (e.g. /dev/tty.usbmodem1131101 or COM25). This creates a partition_table.bin file.\nConvert the partition table # Inside a terminal, use gen_esp32part.py.\npython $IDF_PATH/components/partition_table/gen_esp32part.py partition_table.bin You should get this output:\nParsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,24K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, coredump,data,coredump,0x110000,64K, Change partition table # Now we change the partition table, using the most appropriate default option selectable via menuconfig.\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Partition Table ‚Üí Factory app, two OTA definitions Since we\u0026rsquo;re now using two OTAs, the default flash configuration of 2MB is not enough, so we need to change it too\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Serial Flasher Config ‚Üí Flash Size ‚Üí 4MB Check the new partition table # Let\u0026rsquo;s do the same steps as before:\nesptool.py -p \u0026lt;YOUR-PORT\u0026gt; read_flash 0x8000 0x1000 partition_table.bin python $IDF_PATH/components/partition_table/gen_esp32part.py partition_table.bin And you\u0026rsquo;ll get\nParsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, Conclusion # In this assignment you changed the partition table from Single factory app, no ota to the default Factory app, two ota definitions. Both of these partition table scheme are provided as default values from ESP-IDF. In the next assignment you will create a custom partition table.\nNext step: Assignment 4.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-4-1/","section":"Workshops","summary":"Change partition table to Factory app, two ota definitions (guided)","title":"ESP-IDF Adv. - Assign.  4.1","type":"workshops"},{"content":"In this assignment, you\u0026rsquo;ll set a custom partition table using VS Code.\nAssignment steps # First, you need to enable the custom partition table in the menuconfig\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Partition Table ‚Üí Custom Partition Table CSV Open editor: \u0026gt; ESP-IDF: Open Partition Table Editor UI Copy the previous partition table Add a spiffs partition Custom partition table\nBuild the partition table: \u0026gt; ESP-IDF: Build Partition Table Flash the partition table: \u0026gt; ESP-IDF: Flash (UART) Your Project Read the partition table again. Partition table output Parsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nsv,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory_app,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, fs,data,spiffs,0x310000,64K, Next step: Assignment 4.3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-4-2/","section":"Workshops","summary":"Create a custom partition table","title":"ESP-IDF Adv. - Assign.  4.2","type":"workshops"},{"content":"In this assignment, we will enable flash encryption.\nEnabling flash encryption (and secure bootloader) is an irreversible operation. Double check before doing any step. Assignment steps # In this assignment, we will:\nCheck your device encryption status Enable flash encryption (development mode) Set partition table Check the encryption status again Check your device encryption status # Open an ESP-IDF terminal : \u0026gt; ESP-IDF: Open ESP-IDF Terminal Inside the terminal, run idf.py efuse-summary Now check the relevant eFuses listed in the table below. They must all be at their default zero state.\neFuse Description BLOCK_KEYN AES key storage. N is between 0 and 5. KEY_PURPOSE_N Control the purpose of eFuse block BLOCK_KEYN, where N is between 0 and 5. DIS_DOWNLOAD_MANUAL_ENCRYPT Disables flash encryption when in download boot modes. SPI_BOOT_CRYPT_CNT Enables encryption and decryption when an SPI boot mode is set. Feature is enabled if 1 or 3 bits are set in the eFuse. Show the eFuse blocks EFUSE_NAME (Block) Description = [Meaningful Value] [Readable/Writeable] (Hex Value) ---------------------------------------------------------------------------------------- Calibration fuses: K_RTC_LDO (BLOCK1) BLOCK1 K_RTC_LDO = 96 R/W (0b0011000) K_DIG_LDO (BLOCK1) BLOCK1 K_DIG_LDO = 20 R/W (0b0000101) V_RTC_DBIAS20 (BLOCK1) BLOCK1 voltage of rtc dbias20 = 172 R/W (0x2b) V_DIG_DBIAS20 (BLOCK1) BLOCK1 voltage of digital dbias20 = 32 R/W (0x08) DIG_DBIAS_HVT (BLOCK1) BLOCK1 digital dbias when hvt = -12 R/W (0b10011) THRES_HVT (BLOCK1) BLOCK1 pvt threshold when hvt = 1600 R/W (0b0110010000) TEMP_CALIB (BLOCK2) Temperature calibration data = -9.0 R/W (0b101011010) OCODE (BLOCK2) ADC OCode = 96 R/W (0x60) ADC1_INIT_CODE_ATTEN0 (BLOCK2) ADC1 init code at atten0 = 1736 R/W (0b0110110010) ADC1_INIT_CODE_ATTEN1 (BLOCK2) ADC1 init code at atten1 = -272 R/W (0b1001000100) ADC1_INIT_CODE_ATTEN2 (BLOCK2) ADC1 init code at atten2 = -368 R/W (0b1001011100) ADC1_INIT_CODE_ATTEN3 (BLOCK2) ADC1 init code at atten3 = -824 R/W (0b1011001110) ADC1_CAL_VOL_ATTEN0 (BLOCK2) ADC1 calibration voltage at atten0 = -204 R/W (0b1000110011) ADC1_CAL_VOL_ATTEN1 (BLOCK2) ADC1 calibration voltage at atten1 = -4 R/W (0b1000000001) ADC1_CAL_VOL_ATTEN2 (BLOCK2) ADC1 calibration voltage at atten2 = -160 R/W (0b1000101000) ADC1_CAL_VOL_ATTEN3 (BLOCK2) ADC1 calibration voltage at atten3 = -332 R/W (0b1001010011) Config fuses: WR_DIS (BLOCK0) Disable programming of individual eFuses = 0 R/W (0x00000000) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 0 R/W (0b0000000) DIS_ICACHE (BLOCK0) Set this bit to disable Icache = False R/W (0b0) DIS_TWAI (BLOCK0) Set this bit to disable CAN function = False R/W (0b0) DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = False R/W (0b0) UART_PRINT_CONTROL (BLOCK0) Set the default UARTboot message output mode = Enable when GPIO8 is high at reset R/W (0b10) ERR_RST_ENABLE (BLOCK0) Use BLOCK0 to check error record registers = without check R/W (0b0) BLOCK_USR_DATA (BLOCK3) User data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_SYS_DATA2 (BLOCK10) System data part 2 (reserved) = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Flash fuses: FLASH_TPUW (BLOCK0) Configures flash waiting time after power-up; in u = 0 R/W (0x0) nit of ms. If the value is less than 15; the waiti ng time is the configurable value; Otherwise; the waiting time is twice the configurable value FORCE_SEND_RESUME (BLOCK0) Set this bit to force ROM code to send a resume co = False R/W (0b0) mmand during SPI boot FLASH_CAP (BLOCK1) Flash capacity = 4M R/W (0b001) FLASH_TEMP (BLOCK1) Flash temperature = 105C R/W (0b01) FLASH_VENDOR (BLOCK1) Flash vendor = XMC R/W (0b001) Identity fuses: DISABLE_WAFER_VERSION_MAJOR (BLOCK0) Disables check of wafer version major = False R/W (0b0) DISABLE_BLK_VERSION_MAJOR (BLOCK0) Disables check of blk version major = False R/W (0b0) WAFER_VERSION_MINOR_LO (BLOCK1) WAFER_VERSION_MINOR least significant bits = 3 R/W (0b011) PKG_VERSION (BLOCK1) Package version = 0 R/W (0b000) BLK_VERSION_MINOR (BLOCK1) BLK_VERSION_MINOR = 1 R/W (0b001) WAFER_VERSION_MINOR_HI (BLOCK1) WAFER_VERSION_MINOR most significant bit = False R/W (0b0) WAFER_VERSION_MAJOR (BLOCK1) WAFER_VERSION_MAJOR = 0 R/W (0b00) OPTIONAL_UNIQUE_ID (BLOCK2) Optional unique 128-bit ID = 7c c7 9b 3a 4c 1f e1 be 56 79 19 20 4f ff cd 0e R/W BLK_VERSION_MAJOR (BLOCK2) BLK_VERSION_MAJOR of BLOCK2 = With calibration R/W (0b01) WAFER_VERSION_MINOR (BLOCK0) calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI = 3 R/W (0x3) \u0026lt;\u0026lt; 3 + WAFER_VERSION_MINOR_LO (read only) Jtag fuses: SOFT_DIS_JTAG (BLOCK0) Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000) d number 1 means disable ). JTAG can be enabled in HMAC module DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = False R/W (0b0) is disabled permanently Mac fuses: MAC (BLOCK1) MAC address = 84:f7:03:42:8c:a8 (OK) R/W CUSTOM_MAC (BLOCK3) Custom MAC address = 00:00:00:00:00:00 (OK) R/W Security fuses: DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = False R/W (0b0) oot_mode[3:0] is 0; 1; 2; 3; 6; 7) DIS_FORCE_DOWNLOAD (BLOCK0) Set this bit to disable the function that forces c = False R/W (0b0) hip into download mode DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0) Set this bit to disable flash encryption when in d = False R/W (0b0) ownload boot modes SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Disable R/W (0b000) and disables otherwise SECURE_BOOT_KEY_REVOKE0 (BLOCK0) Revoke 1st secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE1 (BLOCK0) Revoke 2nd secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE2 (BLOCK0) Revoke 3rd secure boot key = False R/W (0b0) KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = USER R/W (0x0) KEY_PURPOSE_1 (BLOCK0) Purpose of Key1 = USER R/W (0x0) KEY_PURPOSE_2 (BLOCK0) Purpose of Key2 = USER R/W (0x0) KEY_PURPOSE_3 (BLOCK0) Purpose of Key3 = USER R/W (0x0) KEY_PURPOSE_4 (BLOCK0) Purpose of Key4 = USER R/W (0x0) KEY_PURPOSE_5 (BLOCK0) Purpose of Key5 = USER R/W (0x0) SECURE_BOOT_EN (BLOCK0) Set this bit to enable secure boot = False R/W (0b0) SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0) Set this bit to enable revoking aggressive secure = False R/W (0b0) boot DIS_DOWNLOAD_MODE (BLOCK0) Set this bit to disable download mode (boot_mode[3 = False R/W (0b0) :0] = 0; 1; 2; 3; 6; 7) ENABLE_SECURITY_DOWNLOAD (BLOCK0) Set this bit to enable secure UART download mode = False R/W (0b0) SECURE_VERSION (BLOCK0) Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000) ure) BLOCK_KEY0 (BLOCK4) Purpose: USER Key0 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY1 (BLOCK5) Purpose: USER Key1 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY2 (BLOCK6) Purpose: USER Key2 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY3 (BLOCK7) Purpose: USER Key3 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY4 (BLOCK8) Purpose: USER Key4 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY5 (BLOCK9) Purpose: USER Key5 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Spi Pad fuses: SPI_PAD_CONFIG_CLK (BLOCK1) SPI PAD CLK = 0 R/W (0b000000) SPI_PAD_CONFIG_Q (BLOCK1) SPI PAD Q(D1) = 0 R/W (0b000000) SPI_PAD_CONFIG_D (BLOCK1) SPI PAD D(D0) = 0 R/W (0b000000) SPI_PAD_CONFIG_CS (BLOCK1) SPI PAD CS = 0 R/W (0b000000) SPI_PAD_CONFIG_HD (BLOCK1) SPI PAD HD(D3) = 0 R/W (0b000000) SPI_PAD_CONFIG_WP (BLOCK1) SPI PAD WP(D2) = 0 R/W (0b000000) SPI_PAD_CONFIG_DQS (BLOCK1) SPI PAD DQS = 0 R/W (0b000000) SPI_PAD_CONFIG_D4 (BLOCK1) SPI PAD D4 = 0 R/W (0b000000) SPI_PAD_CONFIG_D5 (BLOCK1) SPI PAD D5 = 0 R/W (0b000000) SPI_PAD_CONFIG_D6 (BLOCK1) SPI PAD D6 = 0 R/W (0b000000) SPI_PAD_CONFIG_D7 (BLOCK1) SPI PAD D7 = 0 R/W (0b000000) Usb fuses: DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = False R/W (0b0) jtag in module of usb device DIS_USB_SERIAL_JTAG (BLOCK0) USB-Serial-JTAG = Enable R/W (0b0) USB_EXCHG_PINS (BLOCK0) Set this bit to exchange USB D+ and D- pins = False R/W (0b0) DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0) USB printing = Enable R/W (0b0) DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0) Disable UART download mode through USB-Serial-JTAG = False R/W (0b0) Vdd fuses: VDD_SPI_AS_GPIO (BLOCK0) Set this bit to vdd spi pin function as gpio = False R/W (0b0) Wdt fuses: WDT_DELAY_SEL (BLOCK0) RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00) ock cycle Enable encryption # Open menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Security Features ‚Üí Enable flash encryption on boot (READ DOCS FIRST)\nMake sure you have: Enable usage mode ‚Üí Development (Not secure)\nYour configuration should ressemble this:\nFlash encryption options\nWe will also increase the bootloader verbosity to see what happens\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Bootloader log verbosity ‚Üí verbose Set partition table # If you\u0026rsquo;d try to flash the project, you will get an error.\nShow error Successfully created esp32c3 image. Generated \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin [103/103] cd \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py \u0026amp;\u0026amp; \u0026lt;PYTHON_ENV_PATH\u0026gt;/bin/python \u0026lt;ESP_IDF_PATH\u0026gt;/components/partition_table/check_sizes.py --offset 0x8000 bootloader 0x0 \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin FAILED: esp-idf/esptool_py/CMakeFiles/bootloader_check_size \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py/CMakeFiles/bootloader_check_size cd \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py \u0026amp;\u0026amp; \u0026lt;PYTHON_ENV_PATH\u0026gt;/bin/python \u0026lt;ESP_IDF_PATH\u0026gt;/components/partition_table/check_sizes.py --offset 0x8000 bootloader 0x0 \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin Error: Bootloader binary size 0x91f0 bytes is too large for partition table offset 0x8000. Bootloader binary can be maximum 0x8000 (32768) bytes unless the partition table offset is increased in the Partition Table section of the project configuration menu. ninja: build stopped: subcommand failed. [972/978] Generating ld/sections.ld ninja: build stopped: subcommand failed. The reason is that the bootloader now takes more space and does not fit in the space of the standard partition table offset (0x8000). We need to change it to 0xf000 before moving on.\nOpen menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\n‚Üí Offset of partition table ‚Üí 0xf000 Now you can build and flash again and you will get:\n[Flash Encryption] WARNING: Flash Encryption in Development Mode This will burn eFuses on your device which is an IRREVERSIBLE operation. In Development Mode: Development Mode: Allows re-flashing with plaintext data The flash encryption process requires two steps: 1. First, you need to confirm by typing \u0026#34;BURN DEV\u0026#34; in the input box at the top of the screen 2. After flashing completes, you MUST reset your device 3. Then flash again to enable encryption The flashing logs will be different than usual this time, informing us about the flashing encryption process. Show flashing logs D (122) boot: type=1 subtype=2 I (125) boot: 0 nvs WiFi data 01 02 00010000 00004000 D (132) boot: load partition table entry 0x3c00f020 D (136) boot: type=1 subtype=0 I (139) boot: 1 otadata OTA data 01 00 00014000 00002000 D (146) boot: load partition table entry 0x3c00f040 D (150) boot: type=1 subtype=1 I (153) boot: 2 phy_init RF data 01 01 00016000 00001000 D (160) boot: load partition table entry 0x3c00f060 D (164) boot: type=0 subtype=0 I (167) boot: 3 factory factory app 00 00 00020000 00100000 D (174) boot: load partition table entry 0x3c00f080 D (178) boot: type=0 subtype=10 I (181) boot: 4 ota_0 OTA app 00 10 00120000 00100000 D (188) boot: load partition table entry 0x3c00f0a0 D (192) boot: type=0 subtype=11 I (195) boot: 5 ota_1 OTA app 00 11 00220000 00100000 I (202) boot: End of partition table D (205) boot: OTA data offset 0x14000 D (208) bootloader_flash: rodata starts from paddr=0x00014000, size=0x2000, will be mapped to vaddr=0x3c000000 V (218) bootloader_flash: after mapping, starting from paddr=0x00010000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (229) boot: otadata[0]: sequence values 0xffffffff D (233) boot: otadata[1]: sequence values 0xffffffff D (238) boot: OTA sequence numbers both empty (all-0xFF) or partition table does not have bootable ota_apps (app_count=2) I (249) boot: Defaulting to factory image D (252) boot: Trying partition index -1 offs 0x20000 size 0x100000 D (258) esp_image: reading image header @ 0x20000 D (263) bootloader_flash: mmu set block paddr=0x00020000 (was 0xffffffff) D (269) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (275) esp_image: loading segment header 0 at offset 0x20018 V (280) esp_image: segment data length 0x1fd24 data starts 0x20020 V (286) esp_image: MMU page size 0x10000 V (290) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (297) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (305) esp_image: free data page_count 0x00000080 D (309) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (319) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (351) esp_image: loading segment header 1 at offset 0x3fd44 D (351) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (351) esp_image: segment data length 0x2cc data starts 0x3fd4c V (357) esp_image: MMU page size 0x10000 V (361) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (369) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) load D (376) esp_image: free data page_count 0x00000080 D (381) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (390) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (401) esp_image: loading segment header 2 at offset 0x40018 D (406) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (413) esp_image: segment data length 0xb4b94 data starts 0x40020 V (419) esp_image: MMU page size 0x10000 V (422) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (430) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (438) esp_image: free data page_count 0x00000080 D (442) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (452) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (580) esp_image: loading segment header 3 at offset 0xf4bb4 D (580) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (581) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (587) esp_image: MMU page size 0x10000 V (591) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (598) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) load D (606) esp_image: free data page_count 0x00000080 D (610) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (620) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (633) esp_image: loading segment header 4 at offset 0xf77e0 D (636) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (643) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (649) esp_image: MMU page size 0x10000 V (652) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (660) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) load D (668) esp_image: free data page_count 0x00000080 D (672) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (682) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (708) esp_image: loading segment header 5 at offset 0x10b4b0 D (708) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (709) esp_image: segment data length 0x1c data starts 0x10b4b8 V (714) esp_image: MMU page size 0x10000 V (718) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (726) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) load D (734) esp_image: free data page_count 0x00000080 D (738) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (748) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (758) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (764) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (771) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (785) boot: Loaded app from partition at offset 0x20000 I (785) boot: Checking flash encryption... D (788) efuse: BLK0 REG2 [18-20], len=3 bits D (792) efuse: BLK0 REG0 [4-4], len=1 bits V (796) flash_encrypt: CRYPT_CNT 0, write protection 0 D (801) efuse: BLK0 REG0 [4-4], len=1 bits D (805) efuse: BLK0 REG2 [18-20], len=3 bits I (809) efuse: Batch mode of writing fields is enabled D (814) efuse: BLK0 REG2 [24-27], len=4 bits D (818) efuse: BLK0 REG2 [28-31], len=4 bits D (822) efuse: BLK0 REG3 [0-3], len=4 bits D (825) efuse: BLK0 REG3 [4-7], len=4 bits D (829) efuse: BLK0 REG3 [8-11], len=4 bits D (833) efuse: BLK0 REG3 [12-15], len=4 bits I (837) flash_encrypt: Generating new flash encryption key... D (843) flash_encrypt: Key generation complete D (847) efuse: BLK0 REG2 [24-27], len=4 bits D (851) efuse: BLK0 REG0 [8-8], len=1 bits D (855) efuse: BLK0 REG1 [0-0], len=1 bits D (858) efuse: BLK0 REG0 [23-23], len=1 bits D (862) efuse: BLK4 REG0 [0-31], len=32 bits D (866) efuse: BLK4 REG1 [0-31], len=32 bits D (870) efuse: BLK4 REG2 [0-31], len=32 bits D (874) efuse: BLK4 REG3 [0-31], len=32 bits D (878) efuse: BLK4 REG4 [0-31], len=32 bits D (882) efuse: BLK4 REG5 [0-31], len=32 bits D (886) efuse: BLK4 REG6 [0-31], len=32 bits D (890) efuse: BLK4 REG7 [0-31], len=32 bits D (894) efuse: BLK0 REG2 [28-31], len=4 bits D (898) efuse: BLK0 REG0 [9-9], len=1 bits D (902) efuse: BLK0 REG1 [1-1], len=1 bits D (906) efuse: BLK0 REG0 [24-24], len=1 bits D (910) efuse: BLK5 REG0 [0-31], len=32 bits D (914) efuse: BLK5 REG1 [0-31], len=32 bits D (918) efuse: BLK5 REG2 [0-31], len=32 bits D (922) efuse: BLK5 REG3 [0-31], len=32 bits D (926) efuse: BLK5 REG4 [0-31], len=32 bits D (930) efuse: BLK5 REG5 [0-31], len=32 bits D (934) efuse: BLK5 REG6 [0-31], len=32 bits D (938) efuse: BLK5 REG7 [0-31], len=32 bits D (942) efuse: BLK0 REG3 [0-3], len=4 bits D (946) efuse: BLK0 REG0 [10-10], len=1 bits D (950) efuse: BLK0 REG1 [2-2], len=1 bits D (954) efuse: BLK0 REG0 [25-25], len=1 bits D (958) efuse: BLK6 REG0 [0-31], len=32 bits D (962) efuse: BLK6 REG1 [0-31], len=32 bits D (966) efuse: BLK6 REG2 [0-31], len=32 bits D (970) efuse: BLK6 REG3 [0-31], len=32 bits D (974) efuse: BLK6 REG4 [0-31], len=32 bits D (978) efuse: BLK6 REG5 [0-31], len=32 bits D (982) efuse: BLK6 REG6 [0-31], len=32 bits D (986) efuse: BLK6 REG7 [0-31], len=32 bits D (990) efuse: BLK0 REG3 [4-7], len=4 bits D (993) efuse: BLK0 REG0 [11-11], len=1 bits D (997) efuse: BLK0 REG1 [3-3], len=1 bits D (1001) efuse: BLK0 REG0 [26-26], len=1 bits D (1005) efuse: BLK7 REG0 [0-31], len=32 bits D (1009) efuse: BLK7 REG1 [0-31], len=32 bits D (1013) efuse: BLK7 REG2 [0-31], len=32 bits D (1017) efuse: BLK7 REG3 [0-31], len=32 bits D (1022) efuse: BLK7 REG4 [0-31], len=32 bits D (1026) efuse: BLK7 REG5 [0-31], len=32 bits D (1030) efuse: BLK7 REG6 [0-31], len=32 bits D (1034) efuse: BLK7 REG7 [0-31], len=32 bits D (1038) efuse: BLK0 REG3 [8-11], len=4 bits D (1042) efuse: BLK0 REG0 [12-12], len=1 bits D (1046) efuse: BLK0 REG1 [4-4], len=1 bits D (1050) efuse: BLK0 REG0 [27-27], len=1 bits D (1054) efuse: BLK8 REG0 [0-31], len=32 bits D (1058) efuse: BLK8 REG1 [0-31], len=32 bits D (1062) efuse: BLK8 REG2 [0-31], len=32 bits D (1066) efuse: BLK8 REG3 [0-31], len=32 bits D (1070) efuse: BLK8 REG4 [0-31], len=32 bits D (1074) efuse: BLK8 REG5 [0-31], len=32 bits D (1078) efuse: BLK8 REG6 [0-31], len=32 bits D (1082) efuse: BLK8 REG7 [0-31], len=32 bits D (1087) efuse: BLK0 REG3 [12-15], len=4 bits D (1091) efuse: BLK0 REG0 [13-13], len=1 bits D (1095) efuse: BLK0 REG1 [5-5], len=1 bits D (1099) efuse: BLK0 REG0 [28-28], len=1 bits D (1103) efuse: BLK9 REG0 [0-31], len=32 bits D (1107) efuse: BLK9 REG1 [0-31], len=32 bits D (1111) efuse: BLK9 REG2 [0-31], len=32 bits D (1115) efuse: BLK9 REG3 [0-31], len=32 bits D (1119) efuse: BLK9 REG4 [0-31], len=32 bits D (1123) efuse: BLK9 REG5 [0-31], len=32 bits D (1127) efuse: BLK9 REG6 [0-31], len=32 bits D (1131) efuse: BLK9 REG7 [0-31], len=32 bits D (1135) efuse: BLK0 REG2 [24-27], len=4 bits D (1139) efuse: BLK0 REG0 [8-8], len=1 bits D (1143) efuse: BLK0 REG1 [0-0], len=1 bits D (1147) efuse: BLK0 REG0 [23-23], len=1 bits D (1151) efuse: BLK4 REG0 [0-31], len=32 bits D (1155) efuse: BLK4 REG1 [0-31], len=32 bits D (1159) efuse: BLK4 REG2 [0-31], len=32 bits D (1164) efuse: BLK4 REG3 [0-31], len=32 bits D (1168) efuse: BLK4 REG4 [0-31], len=32 bits D (1172) efuse: BLK4 REG5 [0-31], len=32 bits D (1176) efuse: BLK4 REG6 [0-31], len=32 bits D (1180) efuse: BLK4 REG7 [0-31], len=32 bits I (1184) efuse: Writing EFUSE_BLK_KEY0 with purpose 4 D (1189) efuse: BLK0 REG2 [24-27], len=4 bits D (1193) efuse: BLK0 REG0 [8-8], len=1 bits D (1197) efuse: BLK0 REG1 [0-0], len=1 bits D (1201) efuse: BLK0 REG0 [23-23], len=1 bits D (1205) efuse: BLK4 REG0 [0-31], len=32 bits D (1209) efuse: BLK4 REG1 [0-31], len=32 bits D (1213) efuse: BLK4 REG2 [0-31], len=32 bits D (1217) efuse: BLK4 REG3 [0-31], len=32 bits D (1221) efuse: BLK4 REG4 [0-31], len=32 bits D (1225) efuse: BLK4 REG5 [0-31], len=32 bits D (1229) efuse: BLK4 REG6 [0-31], len=32 bits D (1233) efuse: BLK4 REG7 [0-31], len=32 bits D (1237) efuse: BLK4 REG0 [0-31], len=32 bits D (1241) efuse: BLK4 REG1 [0-31], len=32 bits D (1245) efuse: BLK4 REG2 [0-31], len=32 bits D (1250) efuse: BLK4 REG3 [0-31], len=32 bits D (1254) efuse: BLK4 REG4 [0-31], len=32 bits D (1258) efuse: BLK4 REG5 [0-31], len=32 bits D (1262) efuse: BLK4 REG6 [0-31], len=32 bits D (1266) efuse: BLK4 REG7 [0-31], len=32 bits D (1270) efuse: BLK0 REG0 [23-23], len=1 bits D (1274) efuse: BLK0 REG0 [23-23], len=1 bits D (1278) efuse: BLK0 REG1 [0-0], len=1 bits D (1282) efuse: BLK0 REG1 [0-0], len=1 bits D (1286) efuse: BLK0 REG2 [24-27], len=4 bits D (1290) efuse: BLK0 REG0 [8-8], len=1 bits D (1294) efuse: BLK0 REG0 [8-8], len=1 bits W (1298) flash_encrypt: Not disabling UART bootloader encryption I (1304) flash_encrypt: Disable UART bootloader cache... D (1309) efuse: BLK0 REG1 [10-10], len=1 bits D (1313) efuse: BLK0 REG1 [10-10], len=1 bits I (1317) flash_encrypt: Disable JTAG... D (1320) efuse: BLK0 REG1 [19-19], len=1 bits D (1324) efuse: BLK0 REG1 [19-19], len=1 bits D (1328) efuse: BLK0 REG1 [9-9], len=1 bits D (1332) efuse: BLK0 REG1 [9-9], len=1 bits D (1336) efuse: BLK0 REG4 [1-1], len=1 bits D (1340) efuse: BLK0 REG4 [1-1], len=1 bits I (1345) efuse: BURN BLOCK4 I (1350) efuse: BURN BLOCK4 - OK (write block == read block) I (1352) efuse: BURN BLOCK0 I (1357) efuse: BURN BLOCK0 - OK (all write block bits are set) I (1360) efuse: Batch mode. Prepared fields are committed D (1365) esp_image: reading image header @ 0x0 D (1369) bootloader_flash: mmu set block paddr=0x00000000 (was 0x00100000) D (1376) esp_image: image header: 0xe9 0x03 0x02 0x02 403cc71a V (1382) esp_image: loading segment header 0 at offset 0x18 V (1387) esp_image: segment data length 0x32e8 data starts 0x20 V (1393) esp_image: MMU page size 0x10000 V (1396) esp_image: segment 0 map_segment 0 segment_data_offs 0x20 load_addr 0x3fcd5990 I (1404) esp_image: segment 0: paddr=00000020 vaddr=3fcd5990 size=032e8h ( 13032) D (1411) esp_image: free data page_count 0x00000080 D (1416) bootloader_flash: rodata starts from paddr=0x00000020, size=0x32e8, will be mapped to vaddr=0x3c000000 V (1426) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1437) esp_image: loading segment header 1 at offset 0x3308 D (1442) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) V (1448) esp_image: segment data length 0xcfc data starts 0x3310 V (1454) esp_image: MMU page size 0x10000 V (1458) esp_image: segment 1 map_segment 0 segment_data_offs 0x3310 load_addr 0x403cc710 I (1466) esp_image: segment 1: paddr=00003310 vaddr=403cc710 size=00cfch ( 3324) D (1473) esp_image: free data page_count 0x00000080 D (1477) bootloader_flash: rodata starts from paddr=0x00003310, size=0xcfc, will be mapped to vaddr=0x3c000000 V (1487) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1498) esp_image: loading segment header 2 at offset 0x400c D (1503) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) V (1510) esp_image: segment data length 0x51b8 data starts 0x4014 V (1516) esp_image: MMU page size 0x10000 V (1519) esp_image: segment 2 map_segment 0 segment_data_offs 0x4014 load_addr 0x403ce710 I (1527) esp_image: segment 2: paddr=00004014 vaddr=403ce710 size=051b8h ( 20920) D (1535) esp_image: free data page_count 0x00000080 D (1539) bootloader_flash: rodata starts from paddr=0x00004014, size=0x51b8, will be mapped to vaddr=0x3c000000 V (1549) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1561) esp_image: image start 0x00000000 end of last section 0x000091cc D (1566) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) D (1573) flash_encrypt: bootloader is plaintext. Encrypting... I (2151) flash_encrypt: bootloader encrypted successfully D (2151) flash_parts: partition table verified, 7 entries D (2151) flash_encrypt: partition table is plaintext. Encrypting... I (2205) flash_encrypt: partition table encrypted and loaded successfully I (2206) flash_encrypt: Encrypting partition 1 at offset 0x14000 (length 0x2000)... I (2331) flash_encrypt: Done encrypting D (2331) esp_image: reading image header @ 0x20000 D (2331) bootloader_flash: mmu set block paddr=0x00020000 (was 0x00000000) D (2334) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (2340) esp_image: loading segment header 0 at offset 0x20018 V (2345) esp_image: segment data length 0x1fd24 data starts 0x20020 V (2351) esp_image: MMU page size 0x10000 V (2355) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (2363) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (2370) esp_image: free data page_count 0x00000080 D (2375) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (2385) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2416) esp_image: loading segment header 1 at offset 0x3fd44 D (2416) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (2417) esp_image: segment data length 0x2cc data starts 0x3fd4c V (2423) esp_image: MMU page size 0x10000 V (2427) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (2435) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) D (2442) esp_image: free data page_count 0x00000080 D (2447) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (2456) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2467) esp_image: loading segment header 2 at offset 0x40018 D (2472) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (2479) esp_image: segment data length 0xb4b94 data starts 0x40020 V (2485) esp_image: MMU page size 0x10000 V (2489) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (2497) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (2504) esp_image: free data page_count 0x00000080 D (2509) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (2519) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (2647) esp_image: loading segment header 3 at offset 0xf4bb4 D (2647) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (2648) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (2654) esp_image: MMU page size 0x10000 V (2658) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (2666) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) D (2673) esp_image: free data page_count 0x00000080 D (2678) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (2687) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (2700) esp_image: loading segment header 4 at offset 0xf77e0 D (2703) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (2710) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (2716) esp_image: MMU page size 0x10000 V (2720) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (2728) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) D (2735) esp_image: free data page_count 0x00000080 D (2740) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (2750) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2773) esp_image: loading segment header 5 at offset 0x10b4b0 D (2773) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (2774) esp_image: segment data length 0x1c data starts 0x10b4b8 V (2780) esp_image: MMU page size 0x10000 V (2784) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (2792) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) D (2799) esp_image: free data page_count 0x00000080 D (2804) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (2813) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (2824) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (2830) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (2837) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (2845) flash_encrypt: Encrypting partition 3 at offset 0x20000 (length 0xeb500)... I (16131) flash_encrypt: Done encrypting D (16131) esp_image: reading image header @ 0x120000 D (16131) bootloader_flash: mmu set block paddr=0x00120000 (was 0x00100000) D (16135) esp_image: image header: 0x09 0xe5 0x92 0x04 10ef8522 E (16140) esp_image: image at 0x120000 has invalid magic byte (nothing flashed here?) D (16148) esp_image: reading image header @ 0x220000 D (16153) bootloader_flash: mmu set block paddr=0x00220000 (was 0x00120000) D (16159) esp_image: image header: 0xff 0xff 0xff 0x0f ffffffff E (16165) esp_image: image at 0x220000 has invalid magic byte (nothing flashed here?) D (16172) flash_encrypt: All flash regions checked for encryption pass D (16179) efuse: BLK0 REG0 [4-4], len=1 bits D (16183) efuse: BLK0 REG2 [18-20], len=3 bits D (16187) flash_encrypt: CRYPT_CNT 0 -\u0026gt; 1 D (16191) efuse: BLK0 REG2 [18-20], len=3 bits I (16195) efuse: BURN BLOCK0 I (16200) efuse: BURN BLOCK0 - OK (all write block bits are set) I (16204) flash_encrypt: Flash encryption completed I (16208) boot: Resetting with flash encryption enabled... ESP-ROM:esp32c3-api1-20210207 Build:Feb 7 2021 rst:0x3 (RTC_SW_SYS_RST),boot:0xc (SPI_FAST_FLASH_BOOT) Saved PC:0x40048b82 --- 0x40048b82: ets_secure_boot_verify_bootloader_with_keys in ROM SPIWP:0xee mode:DIO, clock div:1 load:0x3fcd5990,len:0x32e8 load:0x403cc710,len:0xcfc load:0x403ce710,len:0x51b8 entry 0x403cc71a I (31) boot: ESP-IDF v5.4.2-dirty 2nd stage bootloader I (31) boot: compile time Jul 22 2025 09:21:12 D (31) bootloader_flash: XMC chip detected by RDID (00204016), skip. D (35) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) I (41) boot: chip revision: v0.3 I (44) boot: efuse block revision: v1.1 D (48) boot.esp32c3: magic e9 D (51) boot.esp32c3: segments 03 D (53) boot.esp32c3: spi_mode 02 D (56) boot.esp32c3: spi_speed 0f D (59) boot.esp32c3: spi_size 02 I (62) boot.esp32c3: SPI Speed : 80MHz I (66) boot.esp32c3: SPI Mode : DIO I (70) boot.esp32c3: SPI Flash Size : 4MB D (74) boot: Enabling RTCWDT(9000 ms) I (77) boot: Enabling RNG early entropy source... D (82) bootloader_flash: rodata starts from paddr=0x0000f000, size=0xc00, will be mapped to vaddr=0x3c000000 V (91) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (101) boot: mapped partition table 0xf000 at 0x3c00f000 D (107) flash_parts: partition table verified, 7 entries I (112) boot: Partition Table: I (114) boot: ## Label Usage Type ST Offset Length D (121) boot: load partition table entry 0x3c00f000 D (125) boot: type=1 subtype=2 I (128) boot: 0 nvs WiFi data 01 02 00010000 00004000 D (135) boot: load partition table entry 0x3c00f020 D (139) boot: type=1 subtype=0 I (142) boot: 1 otadata OTA data 01 00 00014000 00002000 D (149) boot: load partition table entry 0x3c00f040 D (153) boot: type=1 subtype=1 I (156) boot: 2 phy_init RF data 01 01 00016000 00001000 D (163) boot: load partition table entry 0x3c00f060 D (167) boot: type=0 subtype=0 I (170) boot: 3 factory factory app 00 00 00020000 00100000 D (177) boot: load partition table entry 0x3c00f080 D (181) boot: type=0 subtype=10 I (184) boot: 4 ota_0 OTA app 00 10 00120000 00100000 D (191) boot: load partition table entry 0x3c00f0a0 D (195) boot: type=0 subtype=11 I (198) boot: 5 ota_1 OTA app 00 11 00220000 00100000 I (205) boot: End of partition table D (208) boot: OTA data offset 0x14000 D (212) bootloader_flash: rodata starts from paddr=0x00014000, size=0x2000, will be mapped to vaddr=0x3c000000 V (221) bootloader_flash: after mapping, starting from paddr=0x00010000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (232) boot: otadata[0]: sequence values 0xffffffff D (236) boot: otadata[1]: sequence values 0xffffffff D (241) boot: OTA sequence numbers both empty (all-0xFF) or partition table does not have bootable ota_apps (app_count=2) I (252) boot: Defaulting to factory image D (255) boot: Trying partition index -1 offs 0x20000 size 0x100000 D (261) esp_image: reading image header @ 0x20000 D (266) bootloader_flash: mmu set block paddr=0x00020000 (was 0xffffffff) D (272) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (278) esp_image: loading segment header 0 at offset 0x20018 V (283) esp_image: segment data length 0x1fd24 data starts 0x20020 V (289) esp_image: MMU page size 0x10000 V (293) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (301) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (308) esp_image: free data page_count 0x00000080 D (313) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (322) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (356) esp_image: loading segment header 1 at offset 0x3fd44 D (356) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (357) esp_image: segment data length 0x2cc data starts 0x3fd4c V (362) esp_image: MMU page size 0x10000 V (366) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (374) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) load D (382) esp_image: free data page_count 0x00000080 D (386) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (396) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (406) esp_image: loading segment header 2 at offset 0x40018 D (412) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (418) esp_image: segment data length 0xb4b94 data starts 0x40020 V (424) esp_image: MMU page size 0x10000 V (428) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (436) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (443) esp_image: free data page_count 0x00000080 D (447) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (457) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (598) esp_image: loading segment header 3 at offset 0xf4bb4 D (598) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (599) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (604) esp_image: MMU page size 0x10000 V (608) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (616) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) load D (623) esp_image: free data page_count 0x00000080 D (628) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (638) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (650) esp_image: loading segment header 4 at offset 0xf77e0 D (654) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (660) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (666) esp_image: MMU page size 0x10000 V (670) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (678) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) load D (685) esp_image: free data page_count 0x00000080 D (690) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (699) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (727) esp_image: loading segment header 5 at offset 0x10b4b0 D (727) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (727) esp_image: segment data length 0x1c data starts 0x10b4b8 V (733) esp_image: MMU page size 0x10000 V (737) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (745) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) load D (752) esp_image: free data page_count 0x00000080 D (757) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (766) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (777) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (783) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (790) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (804) boot: Loaded app from partition at offset 0x20000 I (804) boot: Checking flash encryption... D (807) efuse: BLK0 REG2 [18-20], len=3 bits D (811) efuse: BLK0 REG0 [4-4], len=1 bits V (815) flash_encrypt: CRYPT_CNT 1, write protection 0 I (820) flash_encrypt: flash encryption is enabled (1 plaintext flashes left) I (827) boot: Disabling RNG early entropy source... D (831) boot: Mapping segment 0 as DROM D (835) boot: Mapping segment 2 as IROM D (838) boot: calling set_cache_and_start_app D (842) boot: configure drom and irom and start V (847) boot: rodata starts from paddr=0x00020020, vaddr=0x3c0c0020, size=0x1fd24 V (854) boot: after mapping rodata, starting from paddr=0x00020000 and vaddr=0x3c0c0000, 0x20000 bytes are mapped V (864) boot: mapped one page of the rodata, from paddr=0x00020000 and vaddr=0x3c7f0000, 0x10000 bytes are mapped V (874) boot: text starts from paddr=0x00040020, vaddr=0x42000020, size=0xb4b94 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 V (881) boot: after mapping text, starting from paddr=0x00040000 and vaddr=0x42000000, 0xc0000 bytes are mapped D (891) boot: start: 0x403802ea --- 0x403802ea: call_start_cpu0 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/port/cpu_start.c:387 You need to do the last two steps.\nClick the reset button on your device Flash the project again: \u0026gt; ESP-IDF: Flash (UART) Your Project Check the device encryption status # Open an ESP-IDF terminal : \u0026gt; ESP-IDF: Open ESP-IDF Terminal Inside the terminal, run idf.py efuse-summary Show eFuses summary espefuse.py v4.9.0 Connecting... === Run \u0026#34;summary\u0026#34; command === EFUSE_NAME (Block) Description = [Meaningful Value] [Readable/Writeable] (Hex Value) ---------------------------------------------------------------------------------------- Calibration fuses: K_RTC_LDO (BLOCK1) BLOCK1 K_RTC_LDO = 96 R/W (0b0011000) K_DIG_LDO (BLOCK1) BLOCK1 K_DIG_LDO = 20 R/W (0b0000101) V_RTC_DBIAS20 (BLOCK1) BLOCK1 voltage of rtc dbias20 = 172 R/W (0x2b) V_DIG_DBIAS20 (BLOCK1) BLOCK1 voltage of digital dbias20 = 32 R/W (0x08) DIG_DBIAS_HVT (BLOCK1) BLOCK1 digital dbias when hvt = -12 R/W (0b10011) THRES_HVT (BLOCK1) BLOCK1 pvt threshold when hvt = 1600 R/W (0b0110010000) TEMP_CALIB (BLOCK2) Temperature calibration data = -9.0 R/W (0b101011010) OCODE (BLOCK2) ADC OCode = 96 R/W (0x60) ADC1_INIT_CODE_ATTEN0 (BLOCK2) ADC1 init code at atten0 = 1736 R/W (0b0110110010) ADC1_INIT_CODE_ATTEN1 (BLOCK2) ADC1 init code at atten1 = -272 R/W (0b1001000100) ADC1_INIT_CODE_ATTEN2 (BLOCK2) ADC1 init code at atten2 = -368 R/W (0b1001011100) ADC1_INIT_CODE_ATTEN3 (BLOCK2) ADC1 init code at atten3 = -824 R/W (0b1011001110) ADC1_CAL_VOL_ATTEN0 (BLOCK2) ADC1 calibration voltage at atten0 = -204 R/W (0b1000110011) ADC1_CAL_VOL_ATTEN1 (BLOCK2) ADC1 calibration voltage at atten1 = -4 R/W (0b1000000001) ADC1_CAL_VOL_ATTEN2 (BLOCK2) ADC1 calibration voltage at atten2 = -160 R/W (0b1000101000) ADC1_CAL_VOL_ATTEN3 (BLOCK2) ADC1 calibration voltage at atten3 = -332 R/W (0b1001010011) Config fuses: WR_DIS (BLOCK0) Disable programming of individual eFuses = 8388864 R/W (0x00800100) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 1 R/W (0b0000001) DIS_ICACHE (BLOCK0) Set this bit to disable Icache = False R/W (0b0) DIS_TWAI (BLOCK0) Set this bit to disable CAN function = False R/W (0b0) DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = True R/W (0b1) UART_PRINT_CONTROL (BLOCK0) Set the default UARTboot message output mode = Enable when GPIO8 is high at reset R/W (0b10) ERR_RST_ENABLE (BLOCK0) Use BLOCK0 to check error record registers = without check R/W (0b0) BLOCK_USR_DATA (BLOCK3) User data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_SYS_DATA2 (BLOCK10) System data part 2 (reserved) = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Flash fuses: FLASH_TPUW (BLOCK0) Configures flash waiting time after power-up; in u = 0 R/W (0x0) nit of ms. If the value is less than 15; the waiti ng time is the configurable value; Otherwise; the waiting time is twice the configurable value FORCE_SEND_RESUME (BLOCK0) Set this bit to force ROM code to send a resume co = False R/W (0b0) mmand during SPI boot FLASH_CAP (BLOCK1) Flash capacity = 4M R/W (0b001) FLASH_TEMP (BLOCK1) Flash temperature = 105C R/W (0b01) FLASH_VENDOR (BLOCK1) Flash vendor = XMC R/W (0b001) Identity fuses: DISABLE_WAFER_VERSION_MAJOR (BLOCK0) Disables check of wafer version major = False R/W (0b0) DISABLE_BLK_VERSION_MAJOR (BLOCK0) Disables check of blk version major = False R/W (0b0) WAFER_VERSION_MINOR_LO (BLOCK1) WAFER_VERSION_MINOR least significant bits = 3 R/W (0b011) PKG_VERSION (BLOCK1) Package version = 0 R/W (0b000) BLK_VERSION_MINOR (BLOCK1) BLK_VERSION_MINOR = 1 R/W (0b001) WAFER_VERSION_MINOR_HI (BLOCK1) WAFER_VERSION_MINOR most significant bit = False R/W (0b0) WAFER_VERSION_MAJOR (BLOCK1) WAFER_VERSION_MAJOR = 0 R/W (0b00) OPTIONAL_UNIQUE_ID (BLOCK2) Optional unique 128-bit ID = 7c c7 9b 3a 4c 1f e1 be 56 79 19 20 4f ff cd 0e R/W BLK_VERSION_MAJOR (BLOCK2) BLK_VERSION_MAJOR of BLOCK2 = With calibration R/W (0b01) WAFER_VERSION_MINOR (BLOCK0) calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI = 3 R/W (0x3) \u0026lt;\u0026lt; 3 + WAFER_VERSION_MINOR_LO (read only) Jtag fuses: SOFT_DIS_JTAG (BLOCK0) Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000) d number 1 means disable ). JTAG can be enabled in HMAC module DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = True R/W (0b1) is disabled permanently Mac fuses: MAC (BLOCK1) MAC address = 84:f7:03:42:8c:a8 (OK) R/W CUSTOM_MAC (BLOCK3) Custom MAC address = 00:00:00:00:00:00 (OK) R/W Security fuses: DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = True R/W (0b1) oot_mode[3:0] is 0; 1; 2; 3; 6; 7) DIS_FORCE_DOWNLOAD (BLOCK0) Set this bit to disable the function that forces c = False R/W (0b0) hip into download mode DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0) Set this bit to disable flash encryption when in d = False R/W (0b0) ownload boot modes SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Enable R/W (0b001) and disables otherwise SECURE_BOOT_KEY_REVOKE0 (BLOCK0) Revoke 1st secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE1 (BLOCK0) Revoke 2nd secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE2 (BLOCK0) Revoke 3rd secure boot key = False R/W (0b0) KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = XTS_AES_128_KEY R/- (0x4) KEY_PURPOSE_1 (BLOCK0) Purpose of Key1 = USER R/W (0x0) KEY_PURPOSE_2 (BLOCK0) Purpose of Key2 = USER R/W (0x0) KEY_PURPOSE_3 (BLOCK0) Purpose of Key3 = USER R/W (0x0) KEY_PURPOSE_4 (BLOCK0) Purpose of Key4 = USER R/W (0x0) KEY_PURPOSE_5 (BLOCK0) Purpose of Key5 = USER R/W (0x0) SECURE_BOOT_EN (BLOCK0) Set this bit to enable secure boot = False R/W (0b0) SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0) Set this bit to enable revoking aggressive secure = False R/W (0b0) boot DIS_DOWNLOAD_MODE (BLOCK0) Set this bit to disable download mode (boot_mode[3 = False R/W (0b0) :0] = 0; 1; 2; 3; 6; 7) ENABLE_SECURITY_DOWNLOAD (BLOCK0) Set this bit to enable secure UART download mode = False R/W (0b0) SECURE_VERSION (BLOCK0) Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000) ure) BLOCK_KEY0 (BLOCK4) Purpose: XTS_AES_128_KEY Key0 or user data = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/- BLOCK_KEY1 (BLOCK5) Purpose: USER Key1 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY2 (BLOCK6) Purpose: USER Key2 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY3 (BLOCK7) Purpose: USER Key3 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY4 (BLOCK8) Purpose: USER Key4 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY5 (BLOCK9) Purpose: USER Key5 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Spi Pad fuses: SPI_PAD_CONFIG_CLK (BLOCK1) SPI PAD CLK = 0 R/W (0b000000) SPI_PAD_CONFIG_Q (BLOCK1) SPI PAD Q(D1) = 0 R/W (0b000000) SPI_PAD_CONFIG_D (BLOCK1) SPI PAD D(D0) = 0 R/W (0b000000) SPI_PAD_CONFIG_CS (BLOCK1) SPI PAD CS = 0 R/W (0b000000) SPI_PAD_CONFIG_HD (BLOCK1) SPI PAD HD(D3) = 0 R/W (0b000000) SPI_PAD_CONFIG_WP (BLOCK1) SPI PAD WP(D2) = 0 R/W (0b000000) SPI_PAD_CONFIG_DQS (BLOCK1) SPI PAD DQS = 0 R/W (0b000000) SPI_PAD_CONFIG_D4 (BLOCK1) SPI PAD D4 = 0 R/W (0b000000) SPI_PAD_CONFIG_D5 (BLOCK1) SPI PAD D5 = 0 R/W (0b000000) SPI_PAD_CONFIG_D6 (BLOCK1) SPI PAD D6 = 0 R/W (0b000000) SPI_PAD_CONFIG_D7 (BLOCK1) SPI PAD D7 = 0 R/W (0b000000) Usb fuses: DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = True R/W (0b1) jtag in module of usb device DIS_USB_SERIAL_JTAG (BLOCK0) USB-Serial-JTAG = Enable R/W (0b0) USB_EXCHG_PINS (BLOCK0) Set this bit to exchange USB D+ and D- pins = False R/W (0b0) DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0) USB printing = Enable R/W (0b0) DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0) Disable UART download mode through USB-Serial-JTAG = False R/W (0b0) Vdd fuses: VDD_SPI_AS_GPIO (BLOCK0) Set this bit to vdd spi pin function as gpio = False R/W (0b0) Wdt fuses: WDT_DELAY_SEL (BLOCK0) RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00) ock cycle You should spot the following differences:\n[...] WR_DIS (BLOCK0) Disable programming of individual eFuses = 8388864 R/W (0x00800100) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 1 R/W (0b0000001) [...] DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = True R/W (0b1) [...] DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = True R/W (0b1) [...] DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = True R/W (0b1)) [...] SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Enable R/W (0b001) [...] KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = XTS_AES_128_KEY R/- (0x4) [...] BLOCK_KEY0 (BLOCK4) Purpose: XTS_AES_128_KEY Key0 or user data = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/- [...] DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = True R/W (0b1) We can see that:\nThe flash encryption is set (SPI_BOOT_CRYPT_CNT). One of the eFuse blocks has been reserved to store the encryption key. Now your device has flash encryption. Since we selected the development, you can still flash it again using the serial port.\nConclusion # In this assignment, we added flash encryption to the project by enabling the appropriate options in the menuconfig and by accommodating the partition table offset as required.\nNext step: Conclusion\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/assignment-4-3/","section":"Workshops","summary":"","title":"ESP-IDF Adv. - Assign.  4.3","type":"workshops"},{"content":" Introduction # The ESP-IDF build system is built on top of CMake and Ninja. CMake is responsible for setting up your project and generating the necessary build files, while Ninja handles the actual building process with minimal overhead.\nBuild system tool chain\nTo simplify development, ESP-IDF provides a command-line tool called idf.py. This tool acts as a front-end to CMake and Ninja, managing project setup, building, and flashing the firmware to your device using esptool.py. It also gives you access to a configuration menu where you can customize your project\u0026rsquo;s settings, which are saved in a single sdkconfig file. IDEs like VSCode and Espressif IDE (Eclipse) usually offer wrappers around the idf.py tool.\nIn this workshop we will use the VSCode plugin.\nModular development # To streamline the development of layered code, ESP-IDF offers a components system, paired with a powerful component manager.\nESP-IDF Components # In ESP-IDF, projects are organized into components \u0026mdash; self-contained, modular blocks of code that provide specific functionality such as drivers, libraries, protocols, utilities, or application logic. This structure simplifies code reuse, organization, and maintenance across complex applications.\nFor example, interfacing with a sensor can be handled by a dedicated component that encapsulates all communication and data processing logic, eliminating the need to rewrite code in every project.\nA typical component includes:\nSource code Header files CMakeLists.txt file for build configuration idf_component.yml file that describes dependencies and version information Fig.1 - Component structure\nThis structure allows components to be easily integrated and managed within ESP-IDF projects, supporting modular development and code sharing. Additional info can be found at the page component Management and Usage.\nComponent manager # The IDF Component Manager is a tool designed to simplify the management of components in ESP-IDF projects. It allows developers to:\nAdd components as dependencies to projects. Automatically download and update components from the ESP Component Registry or from git repositories. Manage component versions and dependencies reliably. When you build your project, the Component Manager fetches all required components and places them in a managed_components folder, ensuring your project has everything it needs to compile and run. This streamlines the process of extending project functionality and encourages code reuse within the Espressif developer community.\nBoard Support Packages (BSP) in ESP-IDF # One kind of ESP-IDF component is the Board Support Package (BSP), a versioned component that encapsulates hardware initialization for a specific development board. BSPs provide pre-configured drivers and a consistent API for accessing onboard peripherals such as LEDs, buttons, displays, touch panels, audio codecs, and SD cards. Like any ESP-IDF component, a BSP can be integrated into a project via the component manager using the idf.py add-dependency which will update the idf_component.yml.\nOn a basic board like the ESP32-C6-DevKit, the BSP abstracts setup for components like the onboard button and addressable LED. On more complex platforms (e.g., ESP32-S3-BOX-3), it includes initialization for multiple peripherals such as displays and audio devices‚Äîpackaged as a single, reusable component.\nThe main reasons for using a BSP are:\nPeripheral initialization: BSPs handle low-level setup (GPIOs, I2C, SPI, etc.) for supported hardware. Reusable abstraction: They expose a common API, enabling code reuse across different projects or board variants. Faster bring-up: With peripherals already configured, application logic can be developed and tested faster and more efficiently. Custom and Generic BSPs # For unsupported or custom boards, developers can use generic BSPs (e.g., esp_bsp_generic, esp_bsp_devkit) and adjust hardware mappings via menuconfig. This allows BSPs to act as a flexible hardware abstraction layer for both official and custom hardware designs.\nHow to create a component # Let\u0026rsquo;s see how to create a component led_toggle starting from the hello_world example.\nAfter you create a project from the example hello_world, your project folder will be as follows:\n. ‚îú‚îÄ‚îÄ CMakeLists.txt ‚îú‚îÄ‚îÄ main ‚îÇ¬†‚îú‚îÄ‚îÄ CMakeLists.txt ‚îÇ¬†‚îî‚îÄ‚îÄ hello_world_main.c ‚îú‚îÄ‚îÄ pytest_hello_world.py ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ sdkconfig ‚îú‚îÄ‚îÄ sdkconfig.ci ‚îî‚îÄ‚îÄ sdkconfig.old To create a component, press F1 or CTRL+SHIFT+P to enter the Command palette and type:\n\u0026gt; ESP-IDF: Create a new ESP-IDF Component\n‚Üí led_toggle Now the folder tree changed to\n. ‚îú‚îÄ‚îÄ CMakeLists.txt ‚îú‚îÄ‚îÄ components # \u0026lt;--- new folder ‚îÇ¬†‚îî‚îÄ‚îÄ led_toggle ‚îÇ¬†‚îú‚îÄ‚îÄ CMakeLists.txt ‚îÇ¬†‚îú‚îÄ‚îÄ include ‚îÇ¬†‚îÇ¬†‚îî‚îÄ‚îÄ led_toggle.h ‚îÇ¬†‚îî‚îÄ‚îÄ led_toggle.c ‚îú‚îÄ‚îÄ main ‚îÇ¬†‚îú‚îÄ‚îÄ CMakeLists.txt ‚îÇ¬†‚îî‚îÄ‚îÄ hello_world_main.c ‚îú‚îÄ‚îÄ pytest_hello_world.py ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ sdkconfig ‚îú‚îÄ‚îÄ sdkconfig.ci ‚îî‚îÄ‚îÄ sdkconfig.old As you can see, a new components folder has been created and inside of it you can find the led_toggle component folder.\nA component folder contains:\nCMakeLists.txt: configuration used by the build system include folder: which contains the headers (automatically passed to the linker) .c file: the actual component code You need to perform a full clean to see newly added components. In VSCode, run:\n\u0026gt; ESP-IDF: Full Clean Project. Let\u0026rsquo;s assume you have the following component header file:\n// led_toggle.h #include \u0026#34;driver/gpio.h\u0026#34; typedef struct { int gpio_nr; bool status; }led_gpio_t; esp_err_t led_config(led_gpio_t * led_gpio); esp_err_t led_drive(led_gpio_t * led_gpio); After a full clean, you can simply include it in your main file and call its functions:\n#include \u0026#34;led_toggle.h\u0026#34; //[...] void app_main(void) { printf(\u0026#34;Hello world!\\n\u0026#34;); led_gpio_t led_board = { .gpio_nr = 5, .status = true }; led_config(led_board) led_drive(led_board) } Managing Configuration in ESP-IDF Projects # ESP-IDF projects handle configuration management primarily through two key files: sdkconfig and sdkconfig.defaults.\nsdkconfig contains the active configuration for your project. It is automatically generated and updated by configuration tools such as idf.py menuconfig, capturing all selected options. sdkconfig.defaults provides a set of default values for configuration options. It\u0026rsquo;s especially useful for setting up consistent initial configurations for new builds or different environments (e.g., development, testing, production). You can generate a sdkconfig.defaults file that reflects your current configuration using the following VSCode command (in the command palette):\n\u0026gt; ESP-IDF: Save Default SDKCONFIG File (save-defconfig) Which is a wrapper around:\nidf.py save-defconfig This command saves all configuration values that differ from the ESP-IDF defaults into sdkconfig.defaults.\nPerformance Optimization # Build configurations can also play a key role in optimizing system performance. The default settings in ESP-IDF represent a balanced compromise between performance, resource usage, and feature availability.\nFor production systems, designers often have specific optimization goals, e.g. reducing memory usage, increasing speed, or minimizing power consumption. These goals can be achieved by selecting and tuning the appropriate configuration options.\nTo assist with this, the official documentation provides a helpful Performance Optimization Guide, which outlines strategies and configuration tips to help you reach your performance targets effectively.\nUsing Multiple Default Files and Target-Specific Defaults # ESP-IDF supports multiple defaults files (skconfig.xxx), which can be specified via the SDKCONFIG_DEFAULTS environment variable or within your project\u0026rsquo;s CMakeLists.txt. These files are listed using semicolons as separators and are applied in order. If there are overlapping configuration keys, the values in earlier files are overridden by those in the following ones. This layered approach allows you to:\nMaintain shared settings in one file Override them with environment-specific or product-specific defaults in others You can also define target-specific defaults using files named sdkconfig.defaults.\u0026lt;chip\u0026gt;, such as sdkconfig.defaults.esp32s3. These are only considered if a generic sdkconfig.defaults file exists (even if it‚Äôs empty). This mechanism supports fine-grained control over configurations for different Espressif chip variants within the same project.\nManaging Build Scenarios with Profile Files # Profile files allow you to encapsulate build settings for specific scenarios (e.g., development, debugging, production) into reusable files. These profiles contain idf.py command-line arguments and can streamline the build process by eliminating repetitive flag specification.\nFor example:\nprofiles/prod ‚Äì for production builds profiles/debug ‚Äì for debugging builds To build using a profile:\nidf.py @profiles/prod build You can also combine profile files with additional command-line arguments for even more flexibility. This approach promotes consistency and simplifies switching between build environments. For more details, see the ESP-IDF multi-config example.\nThe VSCode ESP-IDF extension lets you define multiple configurations via JSON file. It\u0026rsquo;s planned to unify this approach with the CLI one in the near future. You can check the detail in the documentation. Practical Example: Isolating Development and Production Builds # To maintain separate configurations for development and production:\nCreate a sdkconfig.defaults file for development.\nCreate production-specific files, such as sdkconfig.prod_common and sdkconfig.prod1.\nBuild with the production configuration using:\nidf.py -B build_prod1 -D SDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.prod_common;sdkconfig.prod1\u0026#34; build This creates an isolated build directory (build_prod1) and applies the specified default configuration layers. As a result, you can maintain reproducible and isolated builds across different environments.\nWe will explore this topic more in-depth in the assignment 1.3.\nConclusion # The ESP-IDF build system provides a powerful foundation for developing embedded applications. With modular components, managed dependencies, and support for reusable Board Support Packages (BSPs), developers can build scalable and maintainable projects. Tools like idf.py, the Component Manager, and profile-based build configurations streamline both development and deployment workflows. By mastering these tools and practices, you\u0026rsquo;ll be well-equipped to create robust firmware across a variety of hardware platforms and development scenarios.\nNext Step: Assignment 1.1\nOr go back to navigation menu.\nAdditional information # What is the ESP Component Registry? IDF Component Manager and ESP Component Registry Documentation ","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/lecture-1/","section":"Workshops","summary":"In this lecture, we explore the ESP-IDF build system, built on CMake and Ninja. We focus on modular components, the Component Manager, and Board Support Packages (BSPs) for hardware abstraction. We also cover how to create custom components and manage configurations using sdkconfig files and build profiles, enabling flexible and reproducible builds.","title":"ESP-IDF Adv. - Lecture 1","type":"workshops"},{"content":" Introduction # Managing asynchronous events‚Äîsuch as Wi-Fi connectivity, timers, or signals‚Äîcan be challenging in embedded systems. Espressif\u0026rsquo;s ESP-IDF addresses this complexity through its event loop library, which allows components to define events and register handlers that respond when those events occur. This model encourages loose coupling between components and promotes a clean, event-driven programming style by deferring execution to a dedicated context rather than handling events directly in interrupt service routines or application threads.\nWhen are event loop useful # Event loops are essential when handling asynchronous events in a modular and structured manner. Consider a scenario where a Wi-Fi connection is established: different components‚Äîsuch as a logger, a UI module, and a network service‚Äîmay each need to respond to this event. The event loop allows each component to independently register a handler, and ensures all handlers are executed in the order they were registered.\nThis approach reduces tight coupling and eliminates the need for complex interdependencies between components. As a result, applications become more modular, scalable, and easier to maintain.\nEvent loops are especially useful in situations where multiple components need to react to the same event independently‚Äîfor example, networking, sensor data processing, or inter-task communication. This approach simplifies coordination and improves maintainability across the system.\nEvents and Callback Functions # The event loop revolves around two key concepts:\nEvents Callback functions In simple terms, when a registered event is triggered (or posted), the event loop invokes the corresponding callback function. To make this work, you must register both the event and its associated callback with the event loop.\nSimplified event loop block diagram\nSince many events can be logically grouped‚Äîfor example, all events related to Wi-Fi or MQTT‚Äîthey are categorized using two identifiers:\nAn event base, which defines the group. An event ID, which identifies the specific event within that group. For instance, Wi-Fi-related events fall under the event base WIFI_EVENT. Specific event IDs within this base include WIFI_EVENT_STA_START and WIFI_EVENT_STA_DISCONNECTED.\nDefault event loop # ESP-IDF automatically creates and manages a default event loop for core system events‚Äîsuch as Wi-Fi, IP configuration, and Bluetooth. This default loop is internal, and its handle is abstracted away from the user. System components post events to this loop, and application code can register handlers to process them.\nFor many use cases, the default event loop is sufficient and avoids the overhead of creating a custom loop. Developers can also post their own application events to the default event loop, making it an efficient option when memory usage is a concern. You can read more about the difference between default event loop and user event loop on the documentation.\nCode Snippets # Defining an event # The following code snippet demonstrates how to define an event base and event IDs using the ESP-IDF macros\n// In your header file (e.g., my_events.h) #include \u0026#34;esp_event.h\u0026#34; ESP_EVENT_DECLARE_BASE(MY_EVENT_BASE); typedef enum { MY_EVENT_ID_1, MY_EVENT_ID_2, MY_EVENT_ID_3, } my_event_id_t; // In your source file (e.g., my_events.c) #include \u0026#34;my_events.h\u0026#34; ESP_EVENT_DEFINE_BASE(MY_EVENT_BASE); This approach uses ESP_EVENT_DECLARE_BASE() to declare the event base in a header file and ESP_EVENT_DEFINE_BASE() to define it in a source file. Event IDs are typically declared as an enumeration for clarity and maintainability. This pattern is recommended across ESP-IDF for all supported chips.\nThese macros just create global variables. We can take a look to their code to understand what they do:\n// Defines for declaring and defining event base #define ESP_EVENT_DECLARE_BASE(id) extern esp_event_base_t const id #define ESP_EVENT_DEFINE_BASE(id) esp_event_base_t const id = #id Defining and Registering an Event Handler # The following example shows how to define a handler and register it to the default event loop for a specific event:\n// Define the event handler void run_on_event(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { // Event handler logic } // Register the handler to the default event loop esp_event_handler_register(MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;run_on_event, NULL); Posting an Event to the Default Event Loop # To trigger an event from within your application, you can post to the default event loop like this:\n// Post an event to the default event loop esp_event_post(MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;event_data, sizeof(event_data), portMAX_DELAY); Creating and Using a User Event Loop # In more advanced scenarios, you might want to create a dedicated event loop. Here\u0026rsquo;s how:\nesp_event_loop_handle_t user_loop; esp_event_loop_args_t loop_args = { .queue_size = 5, .task_name = \u0026#34;user_event_task\u0026#34;, // Set to NULL to avoid creating a dedicated task .task_priority = uxTaskPriorityGet(NULL), .task_stack_size = 2048, .task_core_id = tskNO_AFFINITY }; // Create the user event loop esp_event_loop_create(\u0026amp;loop_args, \u0026amp;user_loop); // Register a handler with the custom event loop esp_event_handler_register_with(user_loop, MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;run_on_event, NULL); // Post an event to the custom loop esp_event_post_to(user_loop, MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;event_data, sizeof(event_data), portMAX_DELAY); Conclusion # The event loop mechanism in Espressif\u0026rsquo;s ESP-IDF framework offers a powerful way to handle asynchronous events cleanly and efficiently. Used by default for system-level notifications like Wi-Fi connectivity, the event loop can also be extended for custom application needs through user-defined loops. By facilitating decoupled, ordered, and modular event processing, this architecture helps developers build more maintainable and scalable embedded systems‚Äîespecially in complex IoT applications.\nNext step: Assignment 2.1\nOr go back to navigation menu\nFurther reading # Event Loop Library Overview esp_event APIs Default Event Loop Example User Event Loops Example ","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/lecture-2/","section":"Workshops","summary":"In this article, we explore the event loop‚Äîa core component of Espressif\u0026rsquo;s ESP-IDF framework that facilitates efficient, decoupled, and asynchronous event handling in embedded applications. We examine its functionality, highlight its benefits, explain how it is used by default within ESP-IDF, and provide practical code examples to demonstrate common usage patterns.","title":"ESP-IDF Adv. - Lecture 2","type":"workshops"},{"content":" Introduction # We‚Äôll focus on two useful tools:\nSize analysis: Understand and manage your application‚Äôs memory footprint. Core dump: Capture the system state after a crash for detailed post-mortem debugging. Let\u0026rsquo;s take a closer look at each.\nSize analysis # Size analysis is the process of examining how much flash and RAM your firmware consumes. This helps ensure the application fits within the target hardware and leaves enough memory available for runtime operations such as task scheduling, buffer management, and peripheral interaction.\nPerforming size analysis # When building a project with ESP-IDF, the build system automatically provides a memory usage summary. After running:\nESP-IDF: Build Your Project You‚Äôll see output like this:\nTotal sizes: DRAM .data size: 1234 bytes DRAM .bss size: 5678 bytes IRAM size: 9101 bytes Flash code size: 11213 bytes Flash rodata size: 1415 bytes This breakdown gives insight into where your application is consuming resources. For deeper analysis, ESP-IDF offers additional commands:\nidf.py size: Provides a summary of statically-allocated memory usage. idf.py size-components: Shows per-component memory usage. idf.py size-files: Breaks down usage by source file. idf.py size-symbols: Lists symbol-level memory usage (useful for pinpointing heavy functions or variables). These tools help identify memory hotspots and guide you in optimizing your codebase.\nOnce you know the memory usage of your firmware, you can begin pruning both the configuration and code to reduce it. After making your changes, test the memory usage again to see how much impact they had.\nCore dumps # A core dump is a snapshot of the device‚Äôs memory and processor state at the time of a crash. It includes:\nCall stacks of all tasks CPU register contents Relevant memory regions This data allows developers to analyze what went wrong, even after the device resets, making core dumps an invaluable tool for diagnosing hard-to-reproduce bugs.\nEnabling and using core dumps # To enable core dumps on an Espressif device using ESP-IDF, you need to\nEnable the core dump in the menuconfig\nTrigger and analyze the core dump When a crash occurs, the Espressif chip saves the core dump to flash or shows it in UART. You can analyze it using:\nidf.py coredump-info These commands decode the core dump and present a readable backtrace, variable states, and register values. This makes it easier to identify the root cause of a failure.\nCore dumps are an invaluable tool to be used alongside debugging.\nConclusion # Mastering size analysis and core dumps is extremely useful for embedded developers. Size analysis helps ensure your application remains within resource limits and runs efficiently, while core dumps provide a powerful mechanism for post-crash diagnostics.\nBy integrating these tools into your development workflow, you\u0026rsquo;ll be better prepared to build robust, high-performance applications.\nNext step: Assignment 3.1\nOr go back to navigation menu\nFurther Reading # ESP-IDF Core Dump Guide ","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/lecture-3/","section":"Workshops","summary":"In this article, we cover size analysis and core dumps. You‚Äôll learn what they do, why they matter, and how to use them to build more efficient and reliable applications.","title":"ESP-IDF Adv. - Lecture 3","type":"workshops"},{"content":" Introduction # As IoT devices become more widespread in homes, industries, and critical infrastructure, the need for robust security is growing rapidly. These connected systems often handle personal data, control physical processes, and operate in untrusted environments‚Äîmaking them attractive targets for attackers.\nIn response to these risks, new regulations like the EU‚Äôs Radio Equipment Directive Delegated Act (RED DA) are raising the bar for IoT security, requiring manufacturers to implement stronger protections by design.\nTo meet these evolving demands, three core technologies have become staples of modern IoT security: over-the-air (OTA) updates, flash encryption, and secure bootloaders.\nOTA updates allow devices to receive firmware updates remotely, enabling timely security patches and feature enhancements without requiring physical access. This is crucial for maintaining device integrity over its lifecycle, especially once deployed in the field.\nFlash encryption protects data stored in the device‚Äôs flash memory by encrypting it at the hardware level. This ensures that sensitive information (such as cryptographic keys or user data) remains inaccessible even if an attacker gains physical access to the device.\nSecure bootloaders verify the integrity and authenticity of firmware before execution. By checking digital signatures during the boot process, they prevent unauthorized or malicious code from running on the device\nIn the following assignments, you will enable these features on the hardware. If you don\u0026rsquo;t feel comfortable, you can follow the developer portal article to emulate security features using QEMU. Together, these features form a foundational security layer, helping developers build devices that are compliant with new regulations and resilient against real-world threats.\nIn this article we\u0026rsquo;ll see what each of these features. To use the OTA we need to first change the partition table. For this reason, before we start, we need to spend a few words about partition tables.\nPartition tables # The partition table defines how the flash memory is organized, specifying where applications, data, filesystems, and other resources are stored. This logical separation allows developers to manage firmware, persistent data, and update mechanisms efficiently.\nESP-IDF uses partition tables because they enable:\nSeparation of code and data: Application and persistent data are isolated, allowing firmware updates without erasing user data. OTA updates: Multiple app partitions and OTA data management for robust remote firmware upgrades. Flexible storage: Support for filesystems and custom data regions for certificates, logs, or configuration. Structure and Location # The partition table is typically flashed at offset 0x8000 in the device‚Äôs SPI flash. It occupies 0xC00 bytes, supporting up to 95 entries, and includes an MD5 checksum for integrity verification. The table itself takes up a full 4 KB flash sector, so any partition following it must start at least at offset 0x9000, depending on the table size and alignment requirements. Each entry in the table includes a name (label), type (such as app or data), subtype, offset, and size in flash memory.\nBuilt-in Partition Schemes # ESP-IDF provides several predefined partition tables for common use cases, selectable via menuconfig:\nSingle factory app, no OTA: Contains a single application partition and basic data partitions (NVS, PHY init). Factory app, two OTA definitions: Adds support for over-the-air (OTA) updates, with two OTA app partitions and an OTA data slot. We will use this predefined partition table in the assignment 4.1 For example, the \u0026ldquo;Factory app, two OTA definitions\u0026rdquo; scheme typically looks like this:\nName Type SubType Offset Size nvs data nvs 0x9000 0x4000 otadata data ota 0xd000 0x2000 phy_init data phy 0xf000 0x1000 factory app factory 0x10000 1M ota_0 app ota_0 0x110000 1M ota_1 app ota_1 0x210000 1M The bootloader uses the partition table to locate the application to boot and the data regions for NVS, PHY calibration, and OTA management.\nCustom Partition Tables # For advanced use cases, developers can define custom partition tables in CSV format. This allows for additional partitions, such as extra NVS storage, SPIFFS, or FAT filesystems, tailored to the application‚Äôs needs. The custom CSV is specified in the project configuration, and ESP-IDF tools will flash and use it accordingly.\nUse custom partition table to increase the size of OTA partitions to the maximum available space (after all other partition sizes are known): This way you have the most space available when doing OTA updates in the future! We will test this option in assignment 4.2.\nOver-the-Air (OTA) Updates on Espressif Devices # Over-the-Air (OTA) updates allow you to remotely upgrade the firmware of embedded devices without requiring physical access. This capability is especially important for IoT deployments, where devices are often distributed across wide or hard-to-reach areas. OTA ensures your devices stay up to date with the latest features, bug fixes, and security patches long after they\u0026rsquo;ve been deployed.\nIn the OTA process, the Espressif device downloads the firmware from a given location, as depicted in Fig.1.\nFig.1 \u0026ndash; OTA basic diagram\nKey benefits of OTA include:\nRemote maintenance: Update firmware without on-site visits. Improved security: Quickly patch known vulnerabilities. Feature updates: Seamlessly deliver new functionality to users. Lower maintenance costs: Avoid expensive manual recalls or servicing. Implementing OTA with ESP-IDF # ESP-IDF offers built-in support for OTA through two main methods:\nNative API: Using the app_update component for full control over the update process. Simplified API: Using the esp_https_ota component for a higher-level interface that handles HTTPS download and flashing automatically. In most cases, application needs to interact with public interface of esp_https_ota and app_update components only. In Fig.2 you can find a simplified diagram of the OTA key components.\nFig.2 \u0026ndash; OTA key components (simplified diagram)\nA typical OTA workflow includes:\nDownloading the new firmware image over Wi-Fi or Ethernet. Writing it to an unused OTA partition in flash. Updating the OTA data partition to mark the new firmware as the active version. Rebooting the device to apply the update. To use OTA, you must add an appropriate partition table. Example code snippet using esp_https_ota # Using esp_https_ota is straightforward and typically requires just a few lines of code.\n#include \u0026#34;esp_https_ota.h\u0026#34; esp_err_t do_firmware_upgrade() { esp_http_client_config_t config = { .url = \u0026#34;https://example.com/firmware.bin\u0026#34;, .cert_pem = (char *)server_cert_pem_start, }; esp_https_ota_config_t ota_config = { .http_config = \u0026amp;config, }; esp_err_t ret = esp_https_ota(\u0026amp;ota_config); if (ret == ESP_OK) { esp_restart(); } else { return ESP_FAIL; } return ESP_OK; } This code downloads a new firmware image and, if successful, restarts the device to boot into the new firmware. For more advanced usage, refer to the ESP-IDF OTA documentation.\nOTA partition table layout # OTA requires a specific partition table layout. At minimum, you need:\nNVS partition: For non-volatile storage. otadata partition: To track which firmware partition is active. Two OTA app partitions: For active/passive firmware images. An example of valid partition table is the following.\nName, Type, SubType, Offset, Size, Flags nvs, data, nvs, , 0x6000, otadata, data, ota, , 0x2000, phy_init, data, phy, , 0x1000, ota_0, app, ota_0, , 1M, ota_1, app, ota_1, , 1M, This layout ensures safe updates: the new firmware is written to the inactive partition, and only after verification is it marked as active for the next boot. The OTA data partition is two flash sectors (0x2000 bytes) to prevent corruption in case of power failure during updates.\nBesides the already mentioned (data,nvs), this partition table contains a (data,ota) field which plays an important role in OTA updates.\notadata partition # The otadata partition is a special partition in the ESP-IDF partition table, required for projects that use Over-The-Air (OTA) firmware updates. Its main purpose is to store information about which OTA app slot (such as ota_0 or ota_1) should be booted by the device. It\u0026rsquo;s typical size is 0x2000 bytes (two flash sectors)\nThe otadata partition is used as follows:\nOn first boot (or after erasing), the otadata partition is empty (all bytes set to 0xFF). In this state, the bootloader will boot the factory app if present, or the first OTA slot if not. After a successful OTA update, the otadata partition is updated to indicate which OTA app slot should be booted next. The partition is designed to be robust against power failures: it uses two sectors, and a counter field to determine the most recent valid data if the sectors disagree. Flash encryption # Flash encryption is a critical security feature, designed to protect the contents of flash memory. When enabled, all data stored in flash is encrypted, making it extremely difficult for unauthorized parties to extract sensitive information, even if they have physical access to the device.\nHow Flash Encryption Works # On first boot, firmware is flashed as plaintext and then encrypted in place. The encryption process uses hardware-accelerated algorithms such as XTS-AES-128, XTS-AES-256, or AES-256, depending on the chip series. The encryption key is securely stored in eFuse blocks within the chip and is not accessible by software, ensuring robust key protection.\nFlash access is transparent: any memory-mapped region is automatically decrypted when read, and encrypted when written, without requiring changes to application code.\nBy default, critical partitions such as the bootloader, partition table, NVS key partition, otadata, and all application partitions are encrypted. Other partitions can be selectively encrypted by marking them with the encrypted flag in the partition table.\nDevelopment mode and release mode # Flash encryption can be enabled in \u0026ldquo;Development\u0026rdquo; or \u0026ldquo;Release\u0026rdquo; mode.\nIn development mode, it is possible to re-flash plaintext firmware for testing, but this is not secure for production. In release mode, re-flashing plaintext firmware is prevented, and the device is locked down for maximum security. It is strongly recommended to use release mode for production devices to prevent unauthorized firmware extraction or modification.\nImportant usage notes # Do not interrupt power during the initial encryption pass on first boot, as this can corrupt flash contents and require re-flashing. Enabling flash encryption increases the bootloader size, which may require updating the partition table offset. We\u0026rsquo;ll see it in detail in assignment 4.3 Secure Bootloader # Espressif devices offer a feature called Secure Boot, which is implemented via a secure bootloader. This mechanism forms the foundation of device security, protecting against unauthorized code execution and firmware tampering.\nA secure bootloader is a special program that verifies the authenticity and integrity of the firmware before allowing it to run on the device. It does this by checking cryptographic signatures appended to the bootloader and application images. If any part of the code has been altered or is not signed by a trusted key, the device will refuse to execute it.\nThis process establishes a chain of trust:\nThe hardware (ROM bootloader) verifies the software bootloader. The software bootloader then verifies the application firmware. This ensures that only code signed by the device manufacturer (or another trusted entity) can run, protecting against malware, unauthorized updates, and physical tampering with the device\u0026rsquo;s flash memory. The private signing key is kept secret, while the public key or its digest is stored securely in the device\u0026rsquo;s eFUSE memory, making it inaccessible to software and attackers.\nHow to Use Secure Bootloader # Enabling secure bootloader on Espressif devices involves the following steps\nEnable Secure Boot in Configuration:\nUse menuconfig to enable secure boot under \u0026ldquo;Security Features\u0026rdquo;. Generate or Specify a Signing Key:\nIf a signing key does not exist, generate one using the provided command (e.g., idf.py secure-generate-signing-key). For production, generate keys using a trusted tool like OpenSSL. Build and Flash the Bootloader:\nBuild the secure boot-enabled bootloader: idf.py bootloader Flash the bootloader manually using the command printed by the build process. Build and Flash the Application:\nBuild and flash the application and partition table: idf.py flash The application image will be signed automatically using the specified key. Verify Secure Boot Activation:\nOn first boot, the device will enable secure boot, burn the necessary eFUSEs, and verify the signatures. Monitor the serial output to confirm successful activation. Once secure boot is enabled, the bootloader cannot be reflashed (unless using a special \u0026ldquo;reflashable\u0026rdquo; mode, which is not recommended for production). Always keep your private signing key secure, as its compromise undermines the entire secure boot process Conclusion # In this article, we explored three foundational pillars of modern IoT security: OTA updates, flash encryption, and secure bootloaders. Together, these features ensure that devices can be updated securely, protect sensitive data at rest, and verify firmware integrity from the moment they power on. As IoT security requirements continue to evolve, mastering these tools is essential for building resilient and regulation-compliant embedded systems. In the next assignments, you will test these features first-hand.\nNext step: Assignment 4.1\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-advanced/lecture-4/","section":"Workshops","summary":"In this article, we explore the advanced features required for security: OTA update, flash encryption, and secure bootloader","title":"ESP-IDF Adv. - Lecture 4","type":"workshops"},{"content":" Create a new project starting from the hello world example and change the displayed string (Guided).\nAssignment steps # In this assignment you will:\nCreate a new project starting from the hello_world example Change the displayed string. In this workshop, we\u0026rsquo;ll be using VSCode extension. If you didn\u0026rsquo;t install it yet, please follow these instructions. Step 1: Create and test a project from an example # In this section, we will:\nCreate a new project from an example Build the project Flash and monitor Please note that most commands in VSCode are executed through the Command Palette, which you can open by pressing Ctrl+Shift+P (or Cmd+Shift+P)\nIn this guide, commands to enter in the Command Palette are marked with the symbol \u0026gt;. Usually it is sufficient to type a few character of the command, then a dropdown menu will help you find the right one. Create a new project from an example # Open VSCode \u0026gt; ESP-IDF: Show Example Project (If asked) Choose the ESP-IDF version Click on get_started ‚Üí hello_world Click on the button Select Location for Creating hello_world Example in the new tab. Fig.1 - Create new project tab\nA new window will open with the following file structure:\nFig.2 - hello_world example files\nFor now, you can ignore .vscode, .devcontainer, and build folder. You will work on the main/hello_world_main.c file.\nBuild the project # To compile (build) your project, you first need to tell the compiler which core (called target) you are using. You can do it through the IDE as follows:\n\u0026gt; ESP-IDF: Set Espressif Device Target In the dropdown menu, choose esp32c3 ‚Üí ESP32-C3 chip (via builtin USB-JTAG) Now you\u0026rsquo;re ready to compile your project:\n\u0026gt; ESP-IDF: Build Your Project You can also click on the small üîß icon located in the bottom bar A terminal tab will open at the bottom of your IDE and show the successful compilation and size of the compiled binary.\nFig.3 - Compilation result\nIf you have problems that are hard to debug, it is useful to do a full clean of your project by using the command \u0026gt; ESP-IDF: Full clean project. Flash and monitor # To see the firmware running, you need to store it on the device (flash) and then you need to read the output it emits on the serial port (monitor).\nConnect the board to your workstation Check that the device is recognized\nIf you don\u0026rsquo;t know how, check this guide Note the name assigned to the Espressif device On Windows, it starts with COM On Linux/macOS, it starts with tty or ttyUSB Inform the IDE about the port the board is connected at\nESP-IDF: Select Port to Use (COM, tty, usbserial) If you\u0026rsquo;re having trouble, check the Establish Serial Connection with ESP32 Guide. Now you can flash and monitor your device.\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device If a dropdown menu appears, choose UART In the terminal, you should now see the Hello World! string and the countdown before the reset.\nStep 2: Change the output text # Identify the output string and change it to Hello LED.\nConclusion # You can now create a new project and flash it on the board. In the next assignment, we\u0026rsquo;ll consolidate this process.\nNext step # Next assignment ‚Üí Assignment 1.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-1-1/","section":"Workshops","summary":"","title":"ESP-IDF Basics - Assign. 1.1","type":"workshops"},{"content":" Assignment outcomes # Creation of a new project from example blink Change the output GPIO according to the board schematic. Blinking of EVK Led Assignment steps outline # For this assignment, you will create a new project from the other get_started example: blink. In the blink example, you need to specify the GPIO on which the LED is connected. The default value is GPIO8 but it\u0026rsquo;s different on your board. You will need to change the configuration value through menuconfig.\nCreate the project from example as done in the previous assignment. Change the example GPIO number in menuconfig: Find the GPIO on which the LED is connected on your board \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) ‚Üí Example Configuration ‚Üí Blink GPIO number Build, flash, and monitor the example. Check that the LED is flashing. Is the output port correct? See the board schematic. Fig.1 - Board Top View\nBonus task # (Bonus) Change the main filename to hello_led_main.c and the project folder to hello_led. Did you encounter errors? Where is the problem? Solution The linker is not informed that it needs to compile the file hello_led_main.c as well. You need to modify the CMakeLists.txt file, which contains the list of source files to include.\nThe build system is a topic covered in the advanced workshop.\nidf_component_register(SRCS \u0026#34;hello_led_main.c\u0026#34; INCLUDE_DIRS \u0026#34;.\u0026#34;) Conclusion # You have now a solid understanding of the project creation, building, and flashing. In the next lesson, we will focus on what usually is the main topic for an Espressif application \u0026ndash; connectivity.\nNext step # Next lecture ‚Üí Lecture 2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-1-2/","section":"Workshops","summary":"Create a new project from example \u003ccode\u003eblink\u003c/code\u003e and change the output GPIO pin via \u003ccode\u003emenuconfig\u003c/code\u003e","title":"ESP-IDF Basics - Assign. 1.2","type":"workshops"},{"content":" Assignment Steps # Create a new project from a template Start a soft-AP Start an HTTP server Connect via smartphone and verify the displayed page Create a new project from a template # In the previous exercises, we created a project based on an example. This time, we will create a project from an empty template instead.\nOpen VS Code \u0026gt; ESP-IDF: Create Project from Extension Template In the dropdown menu that appears ‚Üí Choose a container directory Select a folder where the project folder will be created In the dropdown menu that appears ‚Üí template-app In the folder you selected, the following project files are now present:\n. |-- CMakeLists.txt |-- README.md `-- main |-- CMakeLists.txt `-- main.c As you can see, the structure is much simpler than in the blink or hello_world example.\nStart a soft-AP # To keep things as simple as possible, this tutorial will hard-code the access point (AP) credentials. As a result, we won\u0026rsquo;t use Non-Volatile Storage (NVS), which is typically used in Wi-Fi applications to store credentials and calibration data.\nNVS is enabled by default. To avoid warnings and errors, we have to disable it through menuconfig.\nDisable NVS # To disable NVS, open menuconfig and look for the NVS option:\n\u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) ‚Üí NVS Deselect PHY and Wi-Fi, as shown in Fig.2 Fig. 2 - NVS options to disable\nClick Save Close the menuconfig tab Define soft-AP parameters # Now open the file main/main.c. We\u0026rsquo;ll use define to set the parameters required by the softAP:\n#define ESP_WIFI_SSID \u0026#34;\u0026lt;YOURNAME_esp_test\u0026gt;\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 To avoid overlapping with the other participants, please choose and unique SSID name. This is not the recommended way to store credentials. Please store them securely in NVS or manage them through configuration settings using menuconfig. For this workshop, use a unique SSID value! Initialize IP stack and Event Loop # Espressif\u0026rsquo;s Wi-Fi component relies on an event loop to handle asynchronous events. To start the soft-AP, we need to:\nInclude esp_wifi.h, string.h and esp_log.h Initialize the IP stack (via esp_netif_init and esp_netif_create_default_wifi_ap) Start the default event loop Create and register an event handler function to process Wi-Fi events. To keep things clean, we\u0026rsquo;ll encapsulate this code in the function wifi_init_softap\n#include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; static const char* TAG = \u0026#34;main\u0026#34;; // Used for logging // ... void wifi_init_softap() { esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // always start with this esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap finished. SSID:%s password:%s channel:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } Register handlers for soft-AP # Create a function to handle the wifi events\nSince this function is called by wifi_init_softap(), you should put it before static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Event nr: %ld!\\n\u0026#34;, event_id); } Call the function inside the app_main\nvoid app_main(void) { wifi_init_softap(); } Choose target (esp32c3) and select port as done in the previous assignments. \u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device You should start seeing several event numbers appearing on the terminal.\n```console [...] I (576) wifi:Init max length of beacon: 752/752 Event n¬∞: 43! I (576) esp_netif_lwip: DHCP server started on interface WIFI_AP_DEF with IP: 192.168.4.1 Event n¬∞: 12! I (586) main: wifi_init_softap completata. SSID:TEST_WORKSHOP password:test_esp canale:1 I (596) main_task: Returned from app_main() Connect to the soft-AP with a Smartphone # Take your smartphone, open the Wi-Fi list, and select the SSID you choose at the previous step (Fig.2)\nFig. 2 - List of APs\nIn the terminal, you should now see Event nr: 14! which corresponds to WIFI_EVENT_AP_STACONNECTED (you can check the enum value on GitHub - remember that enumeration of values start from 0!)\nThis indicates that a station (i.e. your smartphone) has connected to the soft-AP (i.e. the Espressif module).\nStarting HTTP server # The HTTP server library provided by ESP-IDF is called esp_http_server. To use it, you‚Äôll need to include the library and configure and start the server.\nInclude the library # To use esp_http_server in your project, you‚Äôll need to ensure that CMake recognizes it as a required component.\nInclude the HTTP server header:\n#include \u0026#34;esp_http_server.h\u0026#34; Configure the HTTP Server # We encapsulate the server setup in a dedicated function:\nhttpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server started successfully, registering URI handlers...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Failed to start server\u0026#34;); return NULL; } After calling httpd_start(), the server handle is initialized and can be used to manage the HTTP server.\nIn your app_main function, start the server calling:\nhttpd_handle_t server = start_webserver(); HTTP URI management # We\u0026rsquo;ll return an HTML page when the user visits the / route. To register a route, we call the function httpd_register_uri_handler after the start_webserver in app_main.\nhttpd_register_uri_handler(server,\u0026amp;hello_world_uri); The httpd_uri_t structure defines the properties of the URI being registered.\nstatic const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, // the address at which the resource can be found .method = HTTP_GET, // The HTTP method (HTTP_GET, HTTP_POST, ...) .handler = hello_get_handler, // The function which process the request .user_ctx = NULL // Additional user data for context }; The last piece we need is the request handler function\nstatic esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } Note the HTML embedded in the response string.\nConnect to the server # For Espressif devices, the default IP address of the Soft-AP is usually 192.168.4.1.\nYou can verify this in the terminal output. Look for a log line like this:\nI (766) esp_netif_lwip: DHCP server started on interface WIFI_AP_DEF with IP: 192.168.4.1 Open the web browser again on your connected device and enter the IP address in the address bar. As shown in Fig.3, you should now get the HTML page that we sent in the hello_get_handler function.\nFig. 3 ‚Äì HTML page displayed\nAssignment Code # Show assignment code /* Blink Example This example code is in the Public Domain (or CC0 licensed, at your option.) Unless required by applicable law or agreed to in writing, this software is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */ #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;led_strip.h\u0026#34; #include \u0026#34;sdkconfig.h\u0026#34; #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_http_server.h\u0026#34; static const char *TAG = \u0026#34;example\u0026#34;; #define ESP_WIFI_SSID \u0026#34;esp_tutorial\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 /* Use project configuration menu (idf.py menuconfig) to choose the GPIO to blink, or you can edit the following line and set a number here. */ #define BLINK_GPIO CONFIG_BLINK_GPIO static uint8_t s_led_state = 0; #ifdef CONFIG_BLINK_LED_STRIP static led_strip_handle_t led_strip; static void blink_led(void) { /* If the addressable LED is enabled */ if (s_led_state) { /* Set the LED pixel using RGB from 0 (0%) to 255 (100%) for each color */ led_strip_set_pixel(led_strip, 0, 16, 16, 16); /* Refresh the strip to send data */ led_strip_refresh(led_strip); } else { /* Set all LED off to clear all pixels */ led_strip_clear(led_strip); } } static void configure_led(void) { ESP_LOGI(TAG, \u0026#34;Example configured to blink addressable LED!\u0026#34;); /* LED strip initialization with the GPIO and pixels number*/ led_strip_config_t strip_config = { .strip_gpio_num = BLINK_GPIO, .max_leds = 1, // at least one LED on board }; #if CONFIG_BLINK_LED_STRIP_BACKEND_RMT led_strip_rmt_config_t rmt_config = { .resolution_hz = 10 * 1000 * 1000, // 10MHz .flags.with_dma = false, }; ESP_ERROR_CHECK(led_strip_new_rmt_device(\u0026amp;strip_config, \u0026amp;rmt_config, \u0026amp;led_strip)); #elif CONFIG_BLINK_LED_STRIP_BACKEND_SPI led_strip_spi_config_t spi_config = { .spi_bus = SPI2_HOST, .flags.with_dma = true, }; ESP_ERROR_CHECK(led_strip_new_spi_device(\u0026amp;strip_config, \u0026amp;spi_config, \u0026amp;led_strip)); #else #error \u0026#34;unsupported LED strip backend\u0026#34; #endif /* Set all LED off to clear all pixels */ led_strip_clear(led_strip); } #elif CONFIG_BLINK_LED_GPIO static void blink_led(void) { /* Set the GPIO level according to the state (LOW or HIGH)*/ gpio_set_level(BLINK_GPIO, s_led_state); } static void configure_led(void) { ESP_LOGI(TAG, \u0026#34;Example configured to blink GPIO LED!\u0026#34;); gpio_reset_pin(BLINK_GPIO); /* Set the GPIO as a push/pull output */ gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT); } #else #error \u0026#34;unsupported LED type\u0026#34; #endif static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Event nr: %ld!\\n\u0026#34;, event_id); } void wifi_init_softap() { esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // always start with this esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap finished. SSID:%s password:%s channel:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } static esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, // the address at which the resource can be found .method = HTTP_GET, // The HTTP method (HTTP_GET, HTTP_POST, ...) .handler = hello_get_handler, // The function which process the request .user_ctx = NULL // Additional user data for context }; httpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server started successfully, registering URI handlers...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Failed to start server\u0026#34;); return NULL; } void app_main(void) { /* Configure the peripheral according to the LED type */ configure_led(); wifi_init_softap(); httpd_handle_t server = start_webserver(); httpd_register_uri_handler(server,\u0026amp;hello_world_uri); while (1) { ESP_LOGI(TAG, \u0026#34;Turning the LED %s!\u0026#34;, s_led_state == true ? \u0026#34;ON\u0026#34; : \u0026#34;OFF\u0026#34;); blink_led(); /* Toggle the LED state */ s_led_state = !s_led_state; vTaskDelay(CONFIG_BLINK_PERIOD / portTICK_PERIOD_MS); } } Conclusion # Now you can put the Espressif device into Soft-AP or STA mode and create an HTTP server which can return both HTML based content of a JSON based response for a REST API.\nNext step # Next assignment: Assignment 2.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-2-1/","section":"Workshops","summary":"Start a soft-AP and an HTTP server (guided)","title":"ESP-IDF Basics - Assign. 2.1","type":"workshops"},{"content":"The second assignment is to add the following routes to the HTTP server that we created in the previous assignment:\nGET /led/on ‚Üí turns the LED on and returns JSON {\u0026ldquo;led\u0026rdquo;: \u0026ldquo;on\u0026rdquo;} GET /led/off‚Üí turns the LED off and returns JSON {\u0026ldquo;led\u0026rdquo;: \u0026ldquo;off\u0026rdquo;} POST /led/blink ‚Üí accepts JSON { \u0026quot;times\u0026quot;: int, \u0026quot;interval_ms\u0026quot;: int } to blink the LED the specified number of times at the given interval, and returns JSON {\u0026quot;blink\u0026quot;: \u0026quot;done\u0026quot;} Solution Outline # To control the LED, you can use the code from exercise 1.2, included here for convenience.\nInclude the GPIO header\n#include \u0026#34;driver/gpio.h\u0026#34; Specify the pin to use\n#define OUTPUT_LED GPIO_NUM_7 Create the LED configuration function (to be called from app_main)\nstatic void configure_led(void) { ESP_LOGI(TAG, \u0026#34;LED Configured!\\n\u0026#34;); gpio_reset_pin(OUTPUT_LED); /* Set the GPIO as push/pull output */ gpio_set_direction(OUTPUT_LED, GPIO_MODE_OUTPUT); } Assignment Code # Show assignment code #include \u0026lt;stdio.h\u0026gt; #define ESP_WIFI_SSID \u0026#34;TEST_WORKSHOP\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_http_server.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #define OUTPUT_LED GPIO_NUM_7 static const char* TAG = \u0026#34;main\u0026#34;; static void configure_led(void) { ESP_LOGI(TAG, \u0026#34;LED Configured!\\n\u0026#34;); gpio_reset_pin(OUTPUT_LED); /* Set the GPIO as push/pull output */ gpio_set_direction(OUTPUT_LED, GPIO_MODE_OUTPUT); } static esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* Handler definitions */ static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Event number: %ld!\\n\u0026#34;, event_id); } static esp_err_t led_on_handler(httpd_req_t *req) { led_control(1); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;on\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static esp_err_t led_off_handler(httpd_req_t *req) { led_control(0); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;off\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* URI definitions */ static const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, .method = HTTP_GET, .handler = hello_get_handler, .user_ctx = NULL }; static const httpd_uri_t led_on_uri = { .uri = \u0026#34;/led/on\u0026#34;, .method = HTTP_GET, .handler = led_on_handler, .user_ctx = NULL }; static const httpd_uri_t led_off_uri = { .uri = \u0026#34;/led/off\u0026#34;, .method = HTTP_GET, .handler = led_off_handler, .user_ctx = NULL }; void wifi_init_softap(){ esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // always start from here esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap completed. SSID:%s password:%s channel:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } httpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server started successfully, registering URI handlers...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Unable to start the server\u0026#34;); return NULL; } void app_main(void) { wifi_init_softap(); configure_led(); httpd_handle_t server = start_webserver(); /* Register URI/Handler */ httpd_register_uri_handler(server,\u0026amp;hello_world_uri); httpd_register_uri_handler(server, \u0026amp;led_on_uri); httpd_register_uri_handler(server, \u0026amp;led_off_uri); } ### Conclusion Now we have a clear picture of how to connect REST API requests to physical device control. You will work on a more complex application in the last assignment 3.3.\nNext step # If you still have time, you can try this optional assignment.\nNext (optional) assignment ‚Üí Assignment 2.3\nOtherwise, you can move to the third lecture.\nNext lecture ‚Üí Lecture 3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-2-2/","section":"Workshops","summary":"Add additional routes to the HTTP server to drive the led remotely","title":"ESP-IDF Basics - Assign. 2.2","type":"workshops"},{"content":"This assignment is optional and it should be done if there\u0026rsquo;s some time left before the break.\nAdd another route to the HTTP server from the previous assignments:\nPOST /led/flash ‚Üí accepts JSON {\u0026quot;periods\u0026quot;: [int], \u0026quot;duty_cycles\u0026quot;: [int]} and for each element, calculates the on-time and off-time and drives the LED accordingly. To test a POST request, you need an app that allows you to send structured HTTP requests. One example is Teste. If you connect your computer to the module‚Äôs access point, you can instead use the Python script below. Python script for POST request First install requests: pip install requests Then create the following script #!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; Send LED flashing parameters to an ESP device via HTTP POST. Endpoint: POST http://192.168.4.1/led/flash Body: {\u0026#34;periods\u0026#34;: [int, ...], \u0026#34;duty_cycles\u0026#34;: [int, ...]} Each pair (period, duty_cycle) defines one blink pattern. \u0026#34;\u0026#34;\u0026#34; import requests import json # --- Configuration --- ESP_IP = \u0026#34;192.168.4.1\u0026#34; # Replace with your module‚Äôs IP address ENDPOINT = f\u0026#34;http://{ESP_IP}/led/flash\u0026#34; # Example data: # periods in milliseconds, duty_cycles in percentage payload = { \u0026#34;periods\u0026#34;: [1000, 500, 2000], \u0026#34;duty_cycles\u0026#34;: [50, 75, 25] } def send_led_flash(payload): \u0026#34;\u0026#34;\u0026#34;Send POST request to the ESP endpoint with LED flash parameters.\u0026#34;\u0026#34;\u0026#34; try: print(f\u0026#34;Sending POST to {ENDPOINT} ...\u0026#34;) response = requests.post(ENDPOINT, json=payload, timeout=5) response.raise_for_status() print(\u0026#34;‚úÖ Request successful!\u0026#34;) print(\u0026#34;Response:\u0026#34;, response.text) except requests.exceptions.RequestException as e: print(\u0026#34;‚ùå Error communicating with the ESP:\u0026#34;, e) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;Payload:\u0026#34;, json.dumps(payload, indent=2)) send_led_flash(payload) Solution outline # You need to check that both periods and duty_cycles have the same length and contain positive number only. duty_cycles should contain numbers between 0 and 100.\nYou can traverse the two arrays and calculate for each element at index i the LED on_time and off_time as follows:\non_time[i] = duty_cycle[i]/100 * periods[i] off_time[i] = periods[i]-on_time[i] You can drive the LED according to the sequence:\nON: on_time[1] OFF: off_time[1] ON: on_time[2] OFF: off_time[2] ... Conclusion # If you managed to reach this point, it means you have good understanding of a basic REST API implementation. You can now move to the third lecture, detailing the management of external libraries and the use of the components found on the component registry.\nNext step # Next lecture ‚Üí Lecture 3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-2-3/","section":"Workshops","summary":"Add a new route to the HTTP server for a programmable blink (Optional)","title":"ESP-IDF Basics - Assign. 2.3 (Optional)","type":"workshops"},{"content":"This assignment has two tasks:\nCreate a led-toggle component Refactor the hello_led example using the created component led-toggle component # The first task is to create a led-toggle component.\nCreate a new component # Open your project hello_led in VSCode Create a new component: \u0026gt; ESP-IDF: Create New ESP-IDF Component Type led_toggle in the text field appearing on top (see Fig.1) Fig.1 - Create new component\nThe project will now contain the folder components and all the required files:\n. ‚îî‚îÄ‚îÄ hello_led/ ‚îú‚îÄ‚îÄ components/ ‚îÇ ‚îî‚îÄ‚îÄ led_toggle/ ‚îÇ ‚îú‚îÄ‚îÄ include/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ led_toggle.h ‚îÇ ‚îú‚îÄ‚îÄ CMakeList.txt ‚îÇ ‚îî‚îÄ‚îÄ led_toggle.c ‚îú‚îÄ‚îÄ main ‚îî‚îÄ‚îÄ build Create the toggle function # Inside the led_toggle.h, add:\n#include \u0026#34;driver/gpio.h\u0026#34; typedef struct { int gpio_nr; bool status; }led_gpio_t; esp_err_t config_led(led_gpio_t * led_gpio); esp_err_t drive_led(led_gpio_t * led_gpio); esp_err_t toggle_led(led_gpio_t * led_gpio); esp_err is an enum (hence an int) used to return error codes. You can check its values in the documentation. This enum is used also with logging and macros like ESP_ERR_CHECK, which you will find almost all esp-idf examples. In the led_toggle.c, we have to implement the toggling logic:\nesp_err_t config_led(led_gpio_t * led_gpio){ gpio_config_t io_conf = {}; io_conf.intr_type = GPIO_INTR_DISABLE; io_conf.mode = GPIO_MODE_OUTPUT; io_conf.pin_bit_mask = (1ULL\u0026lt;\u0026lt;led_gpio-\u0026gt;gpio_nr); io_conf.pull_down_en = 0; io_conf.pull_up_en = 0; return gpio_config(\u0026amp;io_conf); } esp_err_t drive_led(led_gpio_t * led_gpio){ return gpio_set_level(led_gpio-\u0026gt;gpio_nr, led_gpio-\u0026gt;status); // turns led on } esp_err_t toggle_led(led_gpio_t * led_gpio){ //TBD return 0; } Now, in app_main, include the appropriate header Configure the peripheral (using the config_led function) Test that everything works correctly through the drive_led function Refactor the hello_led code # Now you are ready to:\nImplement the toggle_led function Refactor the hello_led code to use the newly created component. Conclusion # You can now create your own components, which makes your code easier to maintain and to share. In the next assignment, you will face a typical development problem and use the skills you just learned.\nNext step # Next assignment ‚Üí Assignment 3.2\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-3-1/","section":"Workshops","summary":"Create a led-toggle component and refactor the hello_led example using the component","title":"ESP-IDF Basics - Assign. 3.1","type":"workshops"},{"content":"In this assignment, you will read the humidity and temperature values from the on-board sensor.\nFor this assignment, you have to\nFind the part number of the sensor on your board Find the code for driving the sensor Read temperature and humidity from the sensor and output it on the serial port with printf. It is not asked to develop the driver, focus on the fastest way to solve the problem and what the previous lecture was about. Hint # Show hint The address can be found on the EVK GitHub page.\nTo install a dependency, open an ESP-IDF terminal:\n\u0026gt; ESP-IDF: Open ESP-IDF Terminal Then use idf.py:\nidf.py add-dependency \u0026#34;repository_name_in_the_registry\u0026#34; Remember to adjust the settings in menuconfig.\nConclusion # Now that you can read the on board sensor, you\u0026rsquo;re ready to move to the last assignment of the workshop to put everything together.\nNext step # Next assignment ‚Üí Assignment 3.3\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-3-2/","section":"Workshops","summary":"","title":"ESP-IDF Basics - Assign. 3.2","type":"workshops"},{"content":"In this assignment, you will put combine all you have done together by adding the two routes below to your HTTP server.\nFor this assignment, you have to\nAdd the route GET /enviroment/ which returns the json object { \u0026#39;temperature\u0026#39;: float, \u0026#39;humidity\u0026#39;: float } (Optional) add route POST /startblink/ which flashes the led according to the temperature reading Flashes the number of tens digit (e.g. 29 degrees ‚Üí 2) with 400ms on and 200ms off Pauses 1 sec Flashes the number of units digit (e.g. 29 degrees ‚Üí 2) with 400ms on and 200ms off Conclusion # You have create a basic IoT application, putting together sensor reading and HTTP connectivity, letting external services to interact with your application.\nNext step # Next step ‚Üí Conclusion\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/assignment-3-3/","section":"Workshops","summary":"","title":"ESP-IDF Basics - Assign. 3.3","type":"workshops"},{"content":" ESP-IDF Introduction # The ESP-IDF (Espressif IoT Development Framework) is the official operating system and development framework for the Espressif Systems SoCs. It provides a comprehensive environment for building IoT applications with robust networking, security, and reliability features.\nThe ESP-IDF framework includes FreeRTOS, enabling developers to build real-time, multitasking applications. It provides a comprehensive set of libraries, tools, and documentation, serving as the foundation for development on Espressif devices.\nESP-IDF includes more than 400 examples, covering a wide range of use cases and helping developers quickly get started on their projects.\nArchitecture # The ESP-IDF platform architecture is mainly divided into 3 layers:\nESP-IDF platform Contains the core components required and the operating system. Includes the FreeRTOS, drivers, build system, protocols, etc. Middleware Adds new features to ESP-IDF, for example the audio framework and HMI. In this workshop, we won\u0026rsquo;t use them. AIoT Application Your application. Fig.1 - ESP-IDF High level Overview\nAll the necessary building blocks for your application will be included in the ESP-IDF platform. ESP-IDF is constantly developing, growing, and improving; acquiring new features and supporting more Espressif cores. Visit the ESP-IDF project on GitHub to get the updated list of supported versions and the maintenance period.\nespressif/esp-idf Espressif IoT Development Framework. Official development framework for Espressif SoCs. C 16307 7889 Main ESP-IDF blocks # As mentioned, ESP-IDF is built on FreeRTOS and contains several libraries. The main libraries you will include in your projects are:\nFreeRTOS (freertos): lightweight, real-time operating system kernel designed for embedded devices, providing multitasking capabilities through preemptive scheduling, task management, and inter-task communication. Drivers (esp_driver_xxx): libraries for driving peripherals. Protocols (esp_http, esp-tls etc.): libraries implementing protocols. During the assignments, you will learn how to include both internal libraries provided by ESP-IDF and external libraries. ESP-IDF also offers a convenient system for managing external dependencies, known as components.\nComponents # Components are packages that include libraries along with additional files for dependency management, metadata, and configuration.\nFig.2 - ESP-IDF Components\nThey are used to add new features such as sensor drivers, communication protocols, board support packages, and other functionalities not included in ESP-IDF by default. Some components are already integrated into example projects, and ESP-IDF itself adopts the external component model to promote modularity.\nUsing components enhances maintainability and accelerates development by enabling code reuse and sharing across multiple projects.\nIf you want to create and publish your own component, we recommend that you watch the talk DevCon23 - Developing, Publishing, and Maintaining Components for ESP-IDF or read the How to create an ESP-IDF component article.\nYou can also find components by browsing our ESP Registry platform.\nIn assignment 3.2, you will have a chance to create your own component and use it in your project.\nFrameworks # Also, ESP-IDF serves as the basis for several other frameworks, including:\nArduino for Espressif ESP-ADF (Audio Development Framework): Designed for audio applications. ESP-WHO (AI Development Framework): Focused on face detection and recognition. ESP-RainMaker: Simplifies building connected devices with cloud capabilities. ESP-Matter SDK: Espressif\u0026rsquo;s SDK for Matter is the official Matter development framework for ESP32 series SoCs. To see all the supported frameworks, please visit our GitHub organization page.\nESP-IDF Development # In addition to libraries, ESP-IDF includes the necessary tools to compile, flash, and monitor your device.\nYou can develop applications for Espressif devices using any plain text editor, such as Gedit or Notepad++, by following the manual installation guide provided in Espressif\u0026rsquo;s documentation.\nHowever, for this workshop, we will use an IDE (Integrated Development Environment) to streamline both development and setup. Espressif supports several IDEs, but we will focus on Visual Studio Code (VS Code). Espressif provides an official VS Code extension called ESP-IDF, which enables you to develop, compile, flash, and debug your projects directly within the editor.\nTo give you an idea, the ESP-IDF VS Code Extension manages the toolchain and gives you some useful commands which we will use later, such as:\n\u0026gt; ESP-IDF: Build Your Project \u0026gt; ESP-IDF: Set Espressif Device Target \u0026gt; ESP-IDF: Full clean project The character \u0026gt; indicates VS Code Command Palette, which can be opened by pressing F1 or Ctrl+Shift+P (or Cmd+Shift+P).\nAll these commands are wrappers around the main ESP-IDF front-end tool which is idf.py.\nHardware used in this workshop # In this workshop we will use an ESP32-C3 SoC based module, called ESP32-C3-Mini-1-N4. You can spot the ESP32-C3-Mini-1-N4 on your workshop board (see Fig. 3). The ESP32-C3 SoC is under the ESP32-C3-Mini-1-N4 shield.\nFig.3 - ESP32-C3 SoC, module, and workshop board\nESP32-C3 SoC # ESP32-C3 is a highly-integrated SoC equipped with a 32-bit RISC-V processor, supporting 2.4 GHz Wi-Fi and Bluetooth LE connectivity. The functional block diagram for ESP32-C3 is shown in Fig.4.\nFig.4 - ESP32-C3 Block Diagram\nESP32-C3 has the following features:\nA 32-bit RISC-V single-core processor @ 160 MHz.\nA Wi-Fi subsystem Supports Station mode, SoftAP mode, SoftAP + Station mode, and promiscuous mode.\nA Bluetooth LE subsystem\nSupports Bluetooth 5 and Bluetooth mesh.\nIntegrated memory\n400 KB SRAM and 384 KB ROM on the chip, external flash connection capability\nSecurity mechanisms\nCryptographic hardware accelerators, encrypted flash, secure bootloader\nA rich set of peripheral interfaces The 22 programmable GPIOs can be configured flexibly to support LED PWM, UART, I2C, SPI, I2S, ADC, TWAI, RMT, and USB Serial/JTAG applications.\nThe ESP32-C3 series of chips has several variants, including the version with in-package SPI flash. You can find them on the ESP32-C3 Series Comparison section of the datasheet. ESP8685 is a small package version of ESP32-C3.\nESP32-C3-Mini-1-N4 Module # In addition to SoCs, Espressif offers modules, which integrate an SoC, additional flash, (optionally) PSRAM memory, and a PCB antenna or an antenna connector. The main advantage of modules is not only their ease of use but also a simplified certification process.\nThe module we will use is the ESP32-C3-MINI-1-N4. As the name suggests, it includes 4MB of flash. If you\u0026rsquo;re curious about how to interpret the module part number, you can check the article Espressif part numbers explained: A complete guide - Modules on the Espressif Developer Portal .\nESP32-C3 Workshop board # Fig.5 - Workshop board\nBoard peripheral overview # You can find the schematic of the version 1 of the evk on the github page.\nI2C peripheral\nThis board includes the following peripherals over the I2C bus:\nPeripheral Part number Reference Crate Address IMU ICM-42670-P Datasheet Link 0x68 Temperature and Humidity SHTC3 Datasheet Link 0x70 I2C Bus Connection\nSignal GPIO SDA GPIO7 SCL GPIO8 GPIO\nThe following devices are connected through GPIO:\nI/O Devices GPIO WS2812 LED GPIO2 LED GPIO10 Button/Boot GPIO9 Power supply\nUSB type-C (no PD compatibility). Li-Ion battery charger - MCP73831T-2ACI/OT, it charges up to 4.2V. Recommendation: MCP73831T-2ACI/OT does not provide battery protection for over-current or over-discharge. For the battery (Li-Ion or Li-Po), it\u0026rsquo;s recommended to use the ones with embedded protection. Limitation: reading the battery voltage is not supported. Pin Layout\nLeft Side\nPin Number Description SoC 1 Reset EN/CHIP_PU 2 3V3 3 N/C 4 GND 5 IO0/ADC1-0 GPIO0 6 IO1/ADC1-1 GPIO1 7 IO2/ADC1-2 GPIO2 8 IO3/ADC1-3 GPIO3 9 IO4/ADC2-0 GPIO4 10 IO5/ADC2-1 GPIO5 11 IO6/MTCK GPIO6 12 IO7/MTDO/LED GPIO7 13 IO8/LOG GPIO8 14 IO21/U0RXD GPIO21 15 IO20/U0TXD GPIO20 16 IO9/BOOT GPIO9 Right Side\nPin Number Description SoC 1 VBAT 2 EN [1] 3 VBUS [2] 4 NC 5 NC 6 NC 7 NC 8 NC 9 IO18/USB_D- GPIO18 10 IO19/USB_D+ GPIO19 11 IO8/SCL GPIO8 12 IO10/SDA GPIO10 [1] Connected to LDO enable pin* [2] Connected to USB 5V* Schematics # You can find the board schematic on the KiCad Libraries GitHub Repository.\nConclusion # Now that we have a high-level overview of both hardware and firmware, we\u0026rsquo;re ready to start the first assignment.\nNext Step # Next Assignment ‚Üí assignment 1.1\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/lecture-1/","section":"Workshops","summary":"In this lesson, we introduce ESP-IDF, the official Espressif framework for IoT application development, exploring its architecture, main components, and development tools. We also examine the hardware used in the workshop, based on the ESP32-C3 SoC, thus preparing the ground for the first practical exercise.","title":"ESP-IDF Basics - Lecture 1","type":"workshops"},{"content":" Internet connectivity # Applications communicate over the internet using different protocols, many of which are build on top of other protocols forming a layered structure.\nThe ISO/OSI model is a conceptual framework that breaks down how data (like messages, videos, or web pages) travels across networks ‚Äî including Wi-Fi and Ethernet ‚Äî into seven steps (layers). Each layer has its own job and uses specific protocols (rules or languages for communication).\nThe ISO/OSI model is typically visualized like on Fig.1.\nFig.1 - ISO OSI Stack\nStarting from the bottom, the layers are:\nPhysical - This is the actual hardware: radio signals, antennas, and frequencies.\nExample: Wi-Fi, Ethernet\nData Link - Controls the direct connection between devices (like your laptop and router) and handles things like access to the wireless channel.\nExample: MAC (Media Access Control)\nNetwork - Figures out how data gets from one network to another.\nExample: IP (Internet Protocol)\nTransport - Makes sure data is delivered correctly and in the right order.\nExamples: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)\nSession - Manages and maintains connections between devices or applications.\nNo single protocol in Wi-Fi, but session handling happens in apps using things like NetBIOS, SMB, or TLS\nPresentation - Translates data so it\u0026rsquo;s readable on both ends (like turning an encrypted message back into text).\nExamples: SSL/TLS (used for encryption), JPEG, MP3, ASCII\nApplication - What the user sees: websites, video calls, email, etc.\nExamples: HTTP (web), HTTPS (secure web), SMTP (email), FTP (file transfer), DNS (domain names)\nSome of the layers of this conceptual framework can me managed by a single protocol. For instance the Ethernet protocol takes care of both the physical and the data link layers.\nHigher level protocols may use the same lower level stack. For instance the MQTT protocol sits at the same level as HTTP. Both of them make use of the TCP/IP stack.\nEncapsulation # The combination of the layers is done through encapsulation.\nEncapsulation is the process by which data is wrapped with protocol information at each layer of the network stack to facilitate proper transmission and delivery. In the context of a Wi-Fi network, application data is first encapsulated within a TCP segment, which provides reliable transport services. This TCP segment is then encapsulated within an IP packet, adding logical addressing and routing information necessary for delivery across networks. Finally, the IP packet is enclosed within a Wi-Fi (IEEE 802.11) frame or an Ethernet frame, which handles the physical and data link layer functions for wireless communication. Each layer adds its own header (and sometimes trailer) to the data unit, enabling modular and efficient network communication.\nA picture is worth more than a thousand words:\nFig.2 - Encapsulation\nSimply put, the whole content of the higher level is inside the payload or data field of the lower layer protocol.\nConnectivity in Espressif # Now that we have an understanding of the connectivity layers, let\u0026rsquo;s explore which ones are supported by Espressif.\nPhysical Layers # Espressif modules support three main physical layers, depending on the SoC:\nWi-Fi: Supported by all devices, it is used for connection to a router and then to the internet. It will be the focus of this workshop. BLE: In IoT, it is mainly used for direct communication with a smartphone and for provisioning (i.e. setting up credentials). Thread/Zigbee: IoT protocols that are used for local machine-to-machine (M2M) communication based on mesh topology (many to many connection). To connect to the internet, a Thread-to-Wi-Fi bridge is required. The Matter protocol utilizes all of these connectivity layers: BLE is used for provisioning, Thread enables low-power communication, and Wi-Fi is used for high-bandwidth data transfer. In this workshop, we will focus on Wi-Fi only. Let\u0026rsquo;s briefly review its topology.\nWi-Fi topology # In a Wi-Fi network, there are two main roles: Access Point (AP) (usually called softAP in Espressif) and Station (STA).\nThe Access Point (AP) is the central device (like a Wi-Fi router) that broadcasts the wireless network and connects stations to each other and to external networks like the internet. A Station (STA) is any device that connects to the AP. It can be a smartphone, laptop, or smart home device. The AP manages the wireless medium, while STAs communicate through the AP, not directly with each other (unless in ad hoc mode). This setup forms a basic infrastructure mode network, which is the most common type of Wi-Fi setup.\nFig.3 - STA vs AP\nEspressif\u0026rsquo;s modules can function in both modes. To connect to an AP, a station need the SSID (router network name) and the password.\nIn the first part of the assignment, we will put the Espressif device in AP mode and use our smartphone to connect to it.\nApplication layer protocols # In the Internet of Things (IoT), various communication protocols are used, with MQTT and HTTP being among the most common. MQTT is specifically designed for machine-to-machine (M2M) communication and is widely used to manage networks of sensors and actuators, particularly in home automation systems due to its lightweight and efficient messaging model.\nHTTP, on the other hand, is best known as the protocol behind the web, used to deliver HTML-based content. However, another major application of HTTP in IoT is for implementing REST APIs. These APIs are not intended for direct user interaction, but rather to be accessed by external applications or services.\nFor example, imagine a smart home web application that displays the status of various sensors in your house. Instead of connecting to each device individually, the application queries the REST API exposed by a sensor gateway, which acts as a bridge between the devices and the user interface.\nIn this webinar, we will use HTTP to serve a simple HTML page and implement a REST API, so let\u0026rsquo;s focus on these concepts.\nHTTP, HTML, and JSON: Serving Web Pages and Building REST APIs # HTTP can be used to serve HTML pages (like those viewed in web browsers) and structured data such as JSON, which is commonly used to implement REST APIs‚Äîmainly for communication between applications.\nHTTP Basics # HTTP (Hypertext Transfer Protocol) is the foundation of communication on the web, based on a simple client-server model. In this model, the client (such as a web browser or application) sends a request to a server, which processes it and returns a response.\nHTTP Requests # HTTP defines several request methods, each serving a specific purpose:\nGET - Retrieve data from the server POST - Send or create new data on the server PUT - Update existing data DELETE - Remove data HTTP Responses # After receiving a request, the server sends an HTTP response, which includes a status code to indicate the outcome. Common status codes include:\n200 OK - The request was successful 201 Created - A new resource was successfully created (usually after a POST) 400 Bad Request - The server couldn\u0026rsquo;t understand the request due to invalid syntax 401 Unauthorized - Authentication is required or has failed 404 Not Found - The requested resource does not exist 500 Internal Server Error - A general error occurred on the server Modern applications and IoT systems often use JSON (JavaScript Object Notation) to format and exchange data. This structured format is at the core of REST APIs, which allow clients to interact with server-side resources using standard HTTP methods.\nFig.4 - Client-server interaction\nHTML: Web Pages # HTML (HyperText Markup Language) is the standard language for creating web pages. With ESP-IDF, you can serve HTML pages directly from your embedded device using HTTP.\nThese HTML pages can be used to:\nDisplay real-time sensor readings Provide control interfaces (e.g., buttons or sliders to interact with GPIOs) Allow user configuration of network settings or parameters A simple HTML page served by an ESP device might look like this:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ESP Sensor Dashboard\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Living Room Sensor\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Temperature: 22.5¬∞C\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Humidity: 60%\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In Fig.5 you can see the HTML code rendering.\nFig.5 - HTML page rendering\nServing HTML content from your ESP device allows users to interact with it through any web browser, with no additional software required.\nJSON: REST API # JSON is a lightweight, human-readable format used to represent structured data. It\u0026rsquo;s ideal for web and IoT applications to exchange information between clients and servers.\nA JSON object is made up of key-value pairs. Here\u0026rsquo;s a simple example:\n{ \u0026#34;temperature\u0026#34;: 22.5, \u0026#34;humidity\u0026#34;: 60, \u0026#34;sensor\u0026#34;: \u0026#34;living_room\u0026#34; } In this case, the object represents a reading from a sensor in the living room.\nREST API # A REST API (Representational State Transfer Application Programming Interface) allows applications to interact with a server using standard HTTP methods. It follows the client-server model, with the server usually responding with JSON-formatted data and an appropriate HTTP status code.\nREST APIs organize access to resources through routes, or URL paths, which are typically human-readable and logically structured.\nExample REST API routes:\nGET /sensors - Retrieve a list of all sensors GET /sensors/42 - Retrieve data for sensor with ID 42 POST /sensors - Create a new sensor PUT /sensors/42 - Update sensor 42\u0026rsquo;s settings DELETE /sensors/42 - Delete sensor 42 This approach allows easy access and manipulation of data, making REST APIs ideal for modern web and IoT applications.\nIn the second part of this workshop, you will implement both a simple HTML page and a REST API using HTTP. These examples will help you understand how to serve web content and expose device data to external applications.\nConclusion # This article introduced the layered structure of internet communication, focusing on the ISO/OSI model and its practical use in Wi-Fi networks. We explored how protocols like HTTP and MQTT operate within this framework, how encapsulation allows data to flow through the layers, and how REST APIs enable structured, JSON-based communication between devices and applications. These concepts form the foundation for building modern, connected IoT systems.\nNow you have all the technical background to start the assignments.\nNext step # Next assignment ‚Üí Assignment 2.1\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/lecture-2/","section":"Workshops","summary":"In this lesson, we introduce the layered structure of Internet communication, explaining the ISO/OSI model and the data encapsulation process. We also explore HTTP and MQTT protocols, showing how REST APIs and the JSON format enable communication between IoT devices and applications.","title":"ESP-IDF Basics - Lecture 2","type":"workshops"},{"content":" Introduction # As we saw earlier, ESP-IDF contains several libraries, from FreeRTOS \u0026mdash; the operating system which manages all tasks \u0026mdash; to the peripheral drivers and protocol libraries. Including the libraries for every possible protocol, algorithm, or driver inside ESP-IDF is not possible: It\u0026rsquo;s size would increase dramatically. If you need a specific protocol, you can probably find it\u0026rsquo;s C implementation somewhere on Github. In this case, the challenge will be to port it to ESP-IDF, taking care of finding all dependencies and informing the build system about which files should be compiled and linked.\nTo solve these problem, Espressif developed a component system similar to a package system in GNU/Linux distributions. The components take care of the dependencies and the build system and you can simply include the header file and you\u0026rsquo;re ready to go! Like in the case of Linux packages, there is also a component manager and a component registry, where you can find all the official packages by Espressif. Once, components are included, the idf.py tool will download the component and set the stage for its use.\nFor additional information, we recommend that you watch the talk DevCon23 - Developing, Publishing, and Maintaining Components for ESP-IDF.\nWe will explore the differences in the use of the integrated libraries and the ones provided by the component registry. We will also see how to create a component, in order to make reusable code.\nWe will explore how to:\nInclude and use the gpio and the i2c libraries (included) See how and use the button component (registry) Create a new component During the assignments, the goal will be to control the LED and the I2C sensor (SHTC3) on the board (see Fig. 1).\nFig.1 - GPIO connected to the LED\nIncluded Libraries # Let‚Äôs take a look at how to use the included libraries. This usually involves three main steps:\nLet the build system know about the library (include the header file and update CMakeLists.txt) Configure the library settings Use the library by calling its functions GPIO # A GPIO (General-Purpose Input/Output) peripheral is a digital interface on a microcontroller or processor that allows it to read input signals (like button presses) or control output devices (like LEDs) through programmable pins. These pins can be configured individually as either input or output and are commonly used for basic device interfacing and control.\nOn our board, we have an LED connected to the GPIO10 (see Fig. 1) and we will use this pin for the example.\nIncluding the library # To include the gpio library, we first need to include the header file and tell the build system where to find it.\nWe need first to include\n#include \u0026#34;driver/gpio.h\u0026#34; and then add to CMakeList.txt\nREQUIRES esp_driver_gpio Note that the header file and the required path are different: When including a library, make sure you check the programming guide first.\nTo find the name of the REQUIRES path, you need to open the programming guide and:\nChoose the core (ESP32-C3) in the upper left corner Find the page for the peripheral (GPIO) Find the section API Reference Configuration # Peripherals have many settings (input/output, frequency, etc). You need to confiure them before using the peripherals.\nIn case of GPIO, a basic configuration is\n//zero-initialize the config structure. gpio_config_t io_conf = {}; //disable interrupt io_conf.intr_type = GPIO_INTR_DISABLE; //set as output mode io_conf.mode = GPIO_MODE_OUTPUT; //bit mask of the pins that you want to set,e.g.GPIO18/19 io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL; //disable pull-down mode io_conf.pull_down_en = 0; //disable pull-up mode io_conf.pull_up_en = 0; //configure GPIO with the given settings gpio_config(\u0026amp;io_conf); In this workshop, we will use GPIO for output. Due to this, we won\u0026rsquo;t talk about:\nInterrupts (trigger a function when the input changes) Pull-up and pull-down (set a default input value) The only field that needs some explanation is the pin_bit_mask. The configuration refers to the whole GPIO peripheral. In order to apply the configuration only to certain pins (via gpio_config), we need to specify the pins via a bit mask. The pin_bit_mask is set equal to GPIO_OUTPUT_PIN_SEL which is\n#define GPIO_OUTPUT_LED 10 #define GPIO_OUTPUT_PIN_SEL (1ULL\u0026lt;\u0026lt;GPIO_OUTPUT_LED) // i.e. 0000000000000000000000000000010000000000 If you want to apply the configuration to more than one GPIO, you need to OR them. For example:\n#define GPIO_OUTPUT_LED 10 #define GPIO_OUTPUT_EXAMPLE 12 #define GPIO_OUTPUT_PIN_SEL ((1ULL\u0026lt;\u0026lt;GPIO_OUTPUT_LED) | (GPIO_OUTPUT_EXAMPLE))// i.e. 0000000000000000000000000001010000000000 Usage # Once the peripheral is configured, we can use the function gpio_set_level to set the GPIO output to either 0 or 1. The header file:\ngpio_set_level(GPIO_OUTPUT_LED, 1); // turns led on gpio_set_level(GPIO_OUTPUT_LED, 0); // turns led off I2C # I2C (Inter-Integrated Circuit) is a communication protocol that uses only two wires‚ÄîSDA (data line) and SCL (clock line)‚Äîto transmit data between devices. Usually, it is used to connect a microcontroller to an external sensor or actuator. It allows multiple peripherals to communicate with a microcontroller using unique addresses, enabling efficient and scalable device interconnection.\nIncluding the library # Consulting the corresponding programming guide section we get the header file\n#include \u0026#34;driver/i2c_master.h\u0026#34; and value for the CMakeList.txt\nREQUIRES esp_driver_i2c Configuration # A configuration has the following form:\ni2c_master_bus_config_t bus_config = { .i2c_port = I2C_NUM_0, .sda_io_num = I2C_MASTER_SDA_IO, .scl_io_num = I2C_MASTER_SCL_IO, .clk_source = I2C_CLK_SRC_DEFAULT, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; i2c_new_master_bus(\u0026amp;bus_config, bus_handle); i2c_device_config_t dev_config = { .dev_addr_length = I2C_ADDR_BIT_LEN_7, .device_address = SHTC3_SENSOR_ADDR, .scl_speed_hz = 400000, }; i2c_master_bus_add_device(*bus_handle, \u0026amp;dev_config, dev_handle); The values for our board are (see Fig. 1)\n#define I2C_MASTER_SDA_IO 7 #define I2C_MASTER_SCL_IO 8 #define SHTC3_SENSOR_ADDR 0x70 The other macros are defined internally.\nComponent registry # Use a component from the registry - button # For our last external library (button), we will use the component manager and registry.\nGo to the component registry Search for the button component (espressif/button) Copy the instruction on the left (see Fig.2) - idf.py add-dependency \u0026quot;espressif/button^4.1.3\u0026quot; In VSCode: \u0026gt; ESP-IDF: Open ESP-IDF Terminal and paste the instruction Fig.2 - espressif/button component\nYou should get a message\nExecuting action: add-dependency NOTICE: Successfully added dependency \u0026#34;espressif/button\u0026#34;: \u0026#34;^4.1.3\u0026#34; to component \u0026#34;main\u0026#34; NOTICE: If you want to make additional changes to the manifest file at path \u0026lt;user_path\u0026gt;/blink/main/idf_component.yml manually, please refer to the documentation: https://docs.espressif.com/projects/idf-component-manager/en/latest/reference/manifest_file.html A new file idf_component.yml has been created in your project with the following content:\ndependencies: espressif/led_strip: ^2.4.1 espressif/button: ^4.1.3 You can add dependencies directly in this file, but it\u0026rsquo;s recommended to use idf.py add-dependency utility.\nTo use the component, you have to include the appropriate header file and call the functions given in the component documentation and folder.\nCreate a component # For detailed instructions on how to create a component using the CLI, you can refer to the article How to create an ESP-IDF component on the Espressif Developer Portal.\nIn VSCode, you can follow a similar flow:\nCreate a new project Create a new component by calling \u0026gt; ESP-IDF: Create New ESP-IDF Component Give the component a name (e.g. led_toggle) The project will now contain a components folder and all the required files\n. ‚îî‚îÄ‚îÄ project_folder/ ‚îú‚îÄ‚îÄ components/ ‚îÇ ‚îî‚îÄ‚îÄ led_toggle/ ‚îÇ ‚îú‚îÄ‚îÄ include/ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ led_toggle.h ‚îÇ ‚îú‚îÄ‚îÄ CMakeList.txt ‚îÇ ‚îî‚îÄ‚îÄ led_toggle.c ‚îú‚îÄ‚îÄ main ‚îî‚îÄ‚îÄ build Each time you create or download a component, you need to perform a project full cleal by calling:\n\u0026gt; ESP-IDF: Full Clean Project\nYou can then include your component in the main file as led_toggle.h.\nConclusion # In this short lecture, we explored two main ways to include external libraries: directly through the CMakeLists.txt file and via the component registry. We covered how to include and use libraries with both methods and explained how to create a custom component from scratch using VSCode. Now it\u0026rsquo;s time to put these concepts into practice in the upcoming assignments.\nNext step # Next assignment ‚Üí Assignment 3.1\nOr go back to navigation menu\n","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/esp-idf-basic/lecture-3/","section":"Workshops","summary":"In this lecture we\u0026rsquo;ll explore how to include libraries which are part of the ESP-IDF, external libraries and components from the ESP component registry","title":"ESP-IDF Basics - Lecture 3","type":"workshops"},{"content":"","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/series/ws00a/","section":"Series","summary":"","title":"WS00A","type":"series"},{"content":"","date":"5 August 2025","externalUrl":null,"permalink":"/workshop-esp-idf/series/ws00b/","section":"Series","summary":"","title":"WS00B","type":"series"},{"content":"Welcome to the Espressif workshops! Here you can find workshops prepared by Espressif and partners for the community.\n","date":"3 June 2024","externalUrl":null,"permalink":"/workshop-esp-idf/workshops/","section":"Workshops","summary":"","title":"Workshops","type":"workshops"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/authors/","section":"Developer Portal Authors","summary":"","title":"Developer Portal Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/authors/francesco-bez/","section":"Developer Portal Authors","summary":"","title":"Francesco Bez","type":"authors"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/platforms/","section":"Platforms","summary":"","title":"Platforms","type":"platforms"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/socs/","section":"Socs","summary":"","title":"Socs","type":"socs"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]