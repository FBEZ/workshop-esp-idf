[{"content":"Per eseguire l\u0026rsquo;OTA, abbiamo bisogno di una tabella delle partizioni con almeno due partizioni.\nObiettivi dell\u0026rsquo;esercizio # Controllare la tabella delle partizioni corrente Cambiare la tabella delle partizioni Controllare la nuova tabella delle partizioni Controllare la tabella delle partizioni corrente # Per controllare la tabella delle partizioni attualmente caricata sul modulo Ã¨ necessario:\nLeggere la flash e salvare la tabella delle partizioni in un file .bin Convertire il file .bin in un formato leggibile Leggere la flash salvando la tabella delle partizioni in un file .bin # Leggi la flash con esptool.py:\nesptool.py -p \u0026lt;YOUR-PORT\u0026gt; read_flash 0x8000 0x1000 https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/partition_table.bin \u0026lt;YOUR-PORT\u0026gt; Ã¨ la stessa porta che usi per flashare il dispositivo (es. /dev/tty.usbmodem1131101 o COM25). Con questo comando viene creato un file partition_table.bin.\nConvertire in file .bin in un formato leggibile # Nel terminale, usa il comando gen_esp32part.py.\npython $IDF_PATH/components/partition_table/gen_esp32part.py https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/partition_table.bin Otterrai questo output:\nParsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,24K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, coredump,data,coredump,0x110000,64K, Cambiare la tabella delle partizioni # Ora cambiamo la tabella delle partizioni, usando l\u0026rsquo;opzione di default piÃ¹ appropriata da selezionare tramite menuconfig.\nApri menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Partition Table â†’ Factory app, two OTA definitions Dato che ora stiamo usando due OTA, la configurazione flash di default di 2MB non Ã¨ sufficiente, quindi dobbiamo cambiarla\nApri menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Serial Flasher Config â†’ Flash Size â†’ 4MB Controllare la nuova tabella delle partizioni # Ripetiamo gli stessi passaggi di prima:\nesptool.py -p \u0026lt;YOUR-PORT\u0026gt; read_flash 0x8000 0x1000 https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/partition_table.bin\npython $IDF_PATH/components/partition_table/gen_esp32part.py https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/partition_table.bin\nOttenendo cosÃ¬\nParsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, Conclusione # In questo esercizio hai cambiato la tabella delle partizioni da Single factory app, no ota al default Factory app, two ota definitions. Entrambi questi schemi di tabella delle partizioni sono forniti come valori di default da ESP-IDF. Nel prossimo esercizio creerai una tabella delle partizioni personalizzata.\nPasso successivo: Esercizio 4.2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-4-1/","section":"Workshops","summary":"Modifica della tabella delle partizioni in Factory app, due definizioni OTA (guidato)","title":"ESP-IDF Avanzato - Esercizio  4.1","type":"workshops"},{"content":" Obiettivi dell\u0026rsquo;esercitazione # Scaricare il codice assignment_1_1_base Compilare ed eseguire lâ€™esempio (per verificare che tutto funzioni) Creare un componente alarm Aggiungere la configurazione del componente Scaricare il codice assignment_1_1_base # Per scaricare il codice ci sono due strade.\nScarica lo zip dalla repo: Vai alla repository su github Clicca il tasto verde \u0026ldquo;Code\u0026rdquo; Nel menÃ¹ a tendina che si pare, clicca su Download ZIP Clona la repo con git\ngit clone https://github.com/espressif/developer-portal-codebase Eseguire lâ€™esempio # Apri la cartella assignment_1_1_base con VS Code\nDelle cartelle nella repo, assigment_1_1_base e assignment_3_2_base contengono il codice di partenza per i rispettivi esercizi 1.1 e 3.2. Tutte le altre cartelle contengono invece la soluzione delle esercitazioni. Imposta il target: \u0026gt; ESP-IDF: Set Espressif Device Target\nSeleziona la porta: \u0026gt; ESP-IDF: Select Port to Use (COM, tty, usbserial)\nImposta i dati dellâ€™AP:\nApri il menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ WiFi SSID â†’ Imposta l\u0026rsquo;SSID del hotspot\nâ†’ WiFi Password â†’ Imposta la password\nCompila, carica il binario e monitora il dispositivo\n\u0026gt; ESP-IDF: Build, Flash, and Start a Monitor on Your Device\n(Oppure clicca sullâ€™icona della fiamma (ðŸ”¥) nella barra inferiore) Ora dovresti vedere lâ€™esempio in esecuzione, connesso alla tua rete WiFi e al server mqtt://test.mosquitto.org.\nMostra output del terminale I (30) boot: ESP-IDF v5.4.2-dirty 2nd stage bootloader I (30) boot: compile time Jul 22 2025 10:52:56 I (30) boot: chip revision: v0.1 I (31) boot: efuse block revision: v1.0 I (34) boot.esp32c3: SPI Speed : 80MHz I (38) boot.esp32c3: SPI Mode : DIO I (42) boot.esp32c3: SPI Flash Size : 2MB I (46) boot: Enabling RNG early entropy source... I (50) boot: Partition Table: I (53) boot: ## Label Usage Type ST Offset Length I (59) boot: 0 nvs WiFi data 01 02 00009000 00006000 I (66) boot: 1 phy_init RF data 01 01 0000f000 00001000 I (72) boot: 2 factory factory app 00 00 00010000 00100000 I (79) boot: End of partition table I (82) esp_image: segment 0: paddr=00010020 vaddr=3c0c0020 size=1e7ech (124908) map I (109) esp_image: segment 1: paddr=0002e814 vaddr=3fc93c00 size=01804h ( 6148) load I (111) esp_image: segment 2: paddr=00030020 vaddr=42000020 size=b1fd4h (729044) map I (229) esp_image: segment 3: paddr=000e1ffc vaddr=3fc95404 size=01620h ( 5664) load I (231) esp_image: segment 4: paddr=000e3624 vaddr=40380000 size=13b38h ( 80696) load I (248) esp_image: segment 5: paddr=000f7164 vaddr=50000000 size=0001ch ( 28) load I (254) boot: Loaded app from partition at offset 0x10000 I (254) boot: Disabling RNG early entropy source... I (265) cpu_start: Unicore app I (274) cpu_start: Pro cpu start user code I (274) cpu_start: cpu freq: 160000000 Hz I (274) app_init: Application information: I (274) app_init: Project name: mqtt_tcp I (278) app_init: App version: 1 I (281) app_init: Compile time: Jul 22 2025 10:53:00 I (286) app_init: ELF file SHA256: b10017352... I (291) app_init: ESP-IDF: v5.4.2-dirty I (295) efuse_init: Min chip rev: v0.1 I (299) efuse_init: Max chip rev: v1.99 I (303) efuse_init: Chip rev: v0.1 I (307) heap_init: Initializing. RAM available for dynamic allocation: I (313) heap_init: At 3FC9B2E0 len 00024D20 (147 KiB): RAM I (318) heap_init: At 3FCC0000 len 0001C710 (113 KiB): Retention RAM I (324) heap_init: At 3FCDC710 len 00002B50 (10 KiB): Retention RAM I (330) heap_init: At 5000001C len 00001FCC (7 KiB): RTCRAM I (336) spi_flash: detected chip: generic I (339) spi_flash: flash io: dio W (342) spi_flash: Detected size(4096k) larger than the size in the binary image header(2048k). Using the size in the binary image header. I (355) sleep_gpio: Configure to isolate all GPIO pins in sleep state I (361) sleep_gpio: Enable automatic switching of GPIO sleep configuration I (367) main_task: Started on CPU0 I (377) main_task: Calling app_main() I (377) mqtt_example: [APP] Startup.. I (377) mqtt_example: [APP] Free memory: 270780 bytes I (377) mqtt_example: [APP] IDF version: v5.4.2-dirty I (397) temperature_sensor: Range [-10Â°C ~ 80Â°C], error \u0026lt; 1Â°C I (397) example_connect: Start example_connect. I (397) pp: pp rom version: 8459080 I (397) net80211: net80211 rom version: 8459080 I (417) wifi:wifi driver task: 3fca3b0c, prio:23, stack:6656, core=0 I (417) wifi:wifi firmware version: bea31f3 I (417) wifi:wifi certification version: v7.0 I (417) wifi:config NVS flash: enabled I (417) wifi:config nano formatting: disabled I (427) wifi:Init data frame dynamic rx buffer num: 32 I (427) wifi:Init static rx mgmt buffer num: 5 I (437) wifi:Init management short buffer num: 32 I (437) wifi:Init dynamic tx buffer num: 32 I (447) wifi:Init static tx FG buffer num: 2 I (447) wifi:Init static rx buffer size: 1600 I (447) wifi:Init static rx buffer num: 10 I (457) wifi:Init dynamic rx buffer num: 32 I (457) wifi_init: rx ba win: 6 I (457) wifi_init: accept mbox: 6 I (467) wifi_init: tcpip mbox: 32 I (467) wifi_init: udp mbox: 6 I (467) wifi_init: tcp mbox: 6 I (477) wifi_init: tcp tx win: 5760 I (477) wifi_init: tcp rx win: 5760 I (477) wifi_init: tcp mss: 1440 I (487) wifi_init: WiFi IRAM OP enabled I (487) wifi_init: WiFi RX IRAM OP enabled I (487) phy_init: phy_version 1201,bae5dd99,Mar 3 2025,15:36:21 I (527) wifi:mode : sta (7c:df:a1:42:64:70) I (527) wifi:enable tsf I (527) example_connect: Connecting to SamsungFrancesco... W (527) wifi:Password length matches WPA2 standards, authmode threshold changes from OPEN to WPA2 I (537) example_connect: Waiting for IP(s) I (3057) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (3057) wifi:state: init -\u0026gt; auth (0xb0) I (4057) wifi:state: auth -\u0026gt; init (0x200) I (4057) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (4057) example_connect: Wi-Fi disconnected 2, trying to reconnect... I (6477) example_connect: Wi-Fi disconnected 205, trying to reconnect... I (8887) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,0\u0026gt;, ap:\u0026lt;255,255\u0026gt;, sta:\u0026lt;1,0\u0026gt;, prof:1, snd_ch_cfg:0x0 I (8887) wifi:state: init -\u0026gt; auth (0xb0) I (8967) wifi:state: auth -\u0026gt; assoc (0x0) I (9017) wifi:state: assoc -\u0026gt; run (0x10) I (9087) wifi:connected with SamsungFrancesco, aid = 1, channel 1, BW20, bssid = ce:db:d8:a6:6b:2a I (9087) wifi:security: WPA2-PSK, phy: bgn, rssi: -50 I (9087) wifi:pm start, type: 1 I (9097) wifi:dp: 1, bi: 102400, li: 3, scale listen interval from 307200 us to 307200 us I (9107) wifi:set rx beacon pti, rx_bcn_pti: 0, bcn_timeout: 25000, mt_pti: 0, mt_time: 10000 I (9147) wifi:\u0026lt;ba-add\u0026gt;idx:0 (ifx:0, ce:db:d8:a6:6b:2a), tid:0, ssn:1, winSize:64 I (9177) wifi:dp: 2, bi: 102400, li: 4, scale listen interval from 307200 us to 409600 us I (9177) wifi:AP\u0026#39;s beacon interval = 102400 us, DTIM period = 2 I (10157) esp_netif_handlers: example_netif_sta ip: 10.75.149.18, mask: 255.255.255.0, gw: 10.75.149.225 I (10157) example_connect: Got IPv4 event: Interface \u0026#34;example_netif_sta\u0026#34; address: 10.75.149.18 I (10397) example_connect: Got IPv6 event: Interface \u0026#34;example_netif_sta\u0026#34; address: fe80:0000:0000:0000:7edf:a1ff:fe42:6470, type: ESP_IP6_ADDR_IS_LINK_LOCAL I (10397) example_common: Connected to example_netif_sta I (10397) example_common: - IPv4 address: 10.75.149.18, I (10407) example_common: - IPv6 address: fe80:0000:0000:0000:7edf:a1ff:fe42:6470, type: ESP_IP6_ADDR_IS_LINK_LOCAL I (10417) mqtt_example: Other event id:7 I (15517) mqtt_example: Temperature: 37.60 Â°C E (19627) transport_base: tcp_read error, errno=Connection reset by peer E (19627) mqtt_client: esp_mqtt_handle_transport_read_error: transport_read() error: errno=104 I (19637) mqtt_example: MQTT_EVENT_ERROR E (19637) mqtt_example: Last error captured as transport\u0026#39;s socket errno: 0x68 I (19647) mqtt_example: Last errno string (Connection reset by peer) E (19647) mqtt_client: esp_mqtt_connect: mqtt_message_receive() returned -2 E (19657) mqtt_client: MQTT connect failed I (19657) mqtt_example: MQTT_EVENT_DISCONNECTED I (20567) mqtt_example: Temperature: 36.60 Â°C I (25667) mqtt_example: Temperature: 36.60 Â°C I (29667) mqtt_example: Other event id:7 I (30667) mqtt_example: Temperature: 36.60 Â°C Creare il componente alarm # Per creare il componente alarm, devi:\n\u0026gt; ESP-IDF: Create New ESP-IDF Component\nNel menÃ¹ a tendina inserisci: alarm\nVerrÃ  creata una nuova cartella components/alarm.\nSposta i file nella cartella del componente\nalarm.c â†’ components/alarm/alarm.c\nalarm.h â†’ components/alarm/include/alarm.h\nAggiungi la dipendenza esp_timer nel file CMakeLists.txt del componente\nidf_component_register(SRCS \u0026#34;alarm.c\u0026#34; REQUIRES esp_timer INCLUDE_DIRS \u0026#34;include\u0026#34;) Non Ã¨ necessario aggiungere REQUIRES esp_timer nel componente main. Il main ha accesso di default a tutti i componenti disponibili. 4. Rimuovi il sorgente da main/CMakeLists.txt\nidf_component_register(SRCS \u0026#34;app_main.c\u0026#34; INCLUDE_DIRS \u0026#34;.\u0026#34;) Fai un full clean: \u0026gt; ESP-IDF: Full Clean Project\nRicompila: \u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device\nSe tutto Ã¨ andato a buon fine, possiamo passare ora alla creazione di una configurazione del componente.\nAggiungere opzioni alla configurazione del componente # Apri il file components/alarm/alarm.c\nAl suo interno puoi notare due valori hardcoded:\n#define ALARM_THRESHOLD_PERCENT 2 // 2% chance #define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms Sostituiremo questi valori con delle configurazioni del componente.\nCrea un file Kconfig nella directory principale del componente alarm\nAggiungi il seguente contenuto al file Kconfig\nmenu \u0026#34;Alarm Component Configuration\u0026#34; config ALARM_THRESHOLD_PERCENT int \u0026#34;Alarm threshold percent\u0026#34; default 2 range 0 100 help Set the threshold percent for the alarm (e.g., 2 for 2% chance). config ALARM_REFRESH_INTERVAL_MS int \u0026#34;Alarm refresh interval (ms)\u0026#34; default 1000 range 1 60000 help Set the interval in milliseconds to reevaluate the alarm. endmenu Commenta o cancella le define\n//#define ALARM_THRESHOLD_PERCENT 2 // 2% chance //#define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms Sostituisci i nomi delle macro nel resto del codice\nALARM_THRESHOLD_PERCENT â†’ CONFIG_ALARM_THRESHOLD_PERCENT ALARM_REFRESH_INTERVAL_MS â†’ CONFIG_ALARM_REFRESH_INTERVAL_MS Pulisci il progetto: ESP-IDF: Full Clean Project\nRicompila e riprogramma: ESP-IDF: Build, Flash and Start Monitor on Your Device\nSoluzione dell\u0026rsquo;esercizio # Mostra il codice alarm.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_random.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; // for esp_timer_get_time() // // Define internal behavior constants // #define ALARM_THRESHOLD_PERCENT 20 // 2% chance // #define ALARM_REFRESH_INTERVAL_MS 1000 // reevaluate every 1000 ms // Internal alarm structure (hidden from user) struct alarm_t { int64_t last_check_time_us; bool last_state; }; alarm_t* alarm_create(void) { alarm_t *alarm = malloc(sizeof(alarm_t)); if (!alarm) return NULL; alarm-\u0026gt;last_check_time_us = 0; alarm-\u0026gt;last_state = false; return alarm; } bool is_alarm_set(alarm_t *alarm) { if (!alarm) return false; int64_t now_us = esp_timer_get_time(); int64_t elapsed_us = now_us - alarm-\u0026gt;last_check_time_us; if (elapsed_us \u0026gt;= CONFIG_ALARM_REFRESH_INTERVAL_MS * 1000) { uint32_t rand_val = esp_random() % 100; alarm-\u0026gt;last_state = rand_val \u0026lt; CONFIG_ALARM_THRESHOLD_PERCENT; alarm-\u0026gt;last_check_time_us = now_us; } return alarm-\u0026gt;last_state; } void alarm_delete(alarm_t *alarm) { if (alarm) { free(alarm); } } Kconfig\nmenu \u0026#34;Alarm Component Configuration\u0026#34; config ALARM_THRESHOLD_PERCENT int \u0026#34;Alarm threshold percent\u0026#34; default 2 range 0 100 help Set the threshold percent for the alarm (e.g., 2 for 2% chance). config ALARM_REFRESH_INTERVAL_MS int \u0026#34;Alarm refresh interval (ms)\u0026#34; default 1000 range 1 60000 help Set the interval in milliseconds to reevaluate the alarm. Puoi trovare lâ€™intero progetto di soluzione nella cartella assignment_1_1 della repository GitHub.\nPassaggio successivo: Esercizio 1.2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-1-1/","section":"Workshops","summary":"Crea il componente \u003ccode\u003ealarm\u003c/code\u003e e rifattorizza il codice per utilizzarlo. (Guidato)","title":"ESP-IDF Avanzato - Esercizio 1.1","type":"workshops"},{"content":"In questa seconda parte, separeremo la logica di connessione dalla funzione principale. Il vantaggio di questo approccio Ã¨ che rende possibile cambiare in maniera trasparente il tipo di connessione (ad esempio passando da MQTTS a HTTP) senza dover modificare la logica del main.\nIn questo compito, rifattorizzeremo il codice di connessione a Wi-Fi e MQTT per adattarlo a un nuovo componente.\nObiettivi dell\u0026rsquo;esercizio # Crea un componente cloud_manager con\nLa seguente interfaccia pubblica: cloud_manager_t *cloud_manager_create(void); esp_err_t cloud_manager_connect(cloud_manager_t *manager); esp_err_t cloud_manager_disconnect(cloud_manager_t *manager); esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp); esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager); void cloud_manager_delete(cloud_manager_t *manager); I seguenti parametri da impostare tramite menuconfig: URL del Broker (spostalo dal main al componente cloud_manager) Il canale su cui viene pubblicata la temperatura (sensor/temperature di default) Il canale su cui viene pubblicato lâ€™allarme (sensor/alarm di default) Traccia della soluzione # Crea un nuovo componente e completa cloud_manager.h # Aggiungi i metodi suggeriti\nAggiungi una dichiarazione opaca typedef struct cloud_manager_t cloud_manager_t; In cloud_manager.h devi importare solo esp_err.h Completa cloud_manager.c\n# Implementa cloud_manager_t come: struct cloud_manager_t { esp_mqtt_client_handle_t client; esp_mqtt_client_config_t mqtt_cfg; }; In cloud_manager_create ritorna semplicemente lâ€™oggetto inizializzato.\nIn cloud_manager_connect inizializza la connessione. Puoi usare la funzione example_connect.\nAggiungi quanto segue al CMakeList.txt del componente cloud_manager\nPRIV_REQUIRES mqtt nvs_flash esp_netif protocol_examples_common In app_main.c\nInizializza e connetti il cloud_manager\ncloud_manager_t *cloud = cloud_manager_create(); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); Chiama le funzioni di publishing nella posizione appropriata\nSoluzione dell\u0026rsquo;esercizio # Mostra il codice cloud_manager.h # #pragma once #include \u0026#34;esp_err.h\u0026#34; typedef struct cloud_manager_t cloud_manager_t; /** * @brief Crea una nuova istanza del cloud manager */ cloud_manager_t *cloud_manager_create(void); /** * @brief Connette il cloud manager (avvia MQTT) */ esp_err_t cloud_manager_connect(cloud_manager_t *manager); /** * @brief Disconnette il cloud manager */ esp_err_t cloud_manager_disconnect(cloud_manager_t *manager); /** * @brief Invia un valore di temperatura al cloud */ esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp); /** * @brief Invia un evento di allarme al cloud */ esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager); /** * @brief Libera la memoria */ void cloud_manager_delete(cloud_manager_t *manager); cloud_manager.c # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;mqtt_client.h\u0026#34; #include \u0026#34;nvs_flash.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_netif.h\u0026#34; #include \u0026#34;protocol_examples_common.h\u0026#34; static const char *TAG = \u0026#34;cloud_manager\u0026#34;; struct cloud_manager_t { esp_mqtt_client_handle_t client; esp_mqtt_client_config_t mqtt_cfg; }; // Event handler for MQTT static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_mqtt_event_handle_t event = event_data; esp_mqtt_client_handle_t client = event-\u0026gt;client; switch ((esp_mqtt_event_id_t)event_id) { case MQTT_EVENT_CONNECTED: ESP_LOGI(TAG, \u0026#34;Connesso al broker MQTT\u0026#34;); esp_mqtt_client_subscribe(client, CONFIG_TEMPERATURE_CHANNEL, 0); esp_mqtt_client_subscribe(client, CONFIG_ALARM_CHANNEL, 0); break; case MQTT_EVENT_DISCONNECTED: ESP_LOGI(TAG, \u0026#34;Disconnesso dal broker MQTT\u0026#34;); break; case MQTT_EVENT_PUBLISHED: ESP_LOGI(TAG, \u0026#34;Messaggio pubblicato (msg_id=%d)\u0026#34;, event-\u0026gt;msg_id); break; case MQTT_EVENT_ERROR: ESP_LOGE(TAG, \u0026#34;MQTT_EVENT_ERROR\u0026#34;); break; default: break; } } cloud_manager_t *cloud_manager_create(void) { cloud_manager_t *manager = calloc(1, sizeof(cloud_manager_t)); if (!manager) return NULL; manager-\u0026gt;mqtt_cfg = (esp_mqtt_client_config_t){ .broker.address.uri = CONFIG_BROKER_URL, }; return manager; } esp_err_t cloud_manager_connect(cloud_manager_t *manager) { if(manager == NULL){return ESP_ERR_INVALID_ARG;} ESP_ERROR_CHECK(nvs_flash_init()); ESP_ERROR_CHECK(esp_netif_init()); manager-\u0026gt;client = esp_mqtt_client_init(\u0026amp;manager-\u0026gt;mqtt_cfg); esp_mqtt_client_register_event(manager-\u0026gt;client, ESP_EVENT_ANY_ID, mqtt_event_handler, manager); ESP_ERROR_CHECK(example_connect()); return esp_mqtt_client_start(manager-\u0026gt;client); } esp_err_t cloud_manager_disconnect(cloud_manager_t *manager) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; return esp_mqtt_client_stop(manager-\u0026gt;client); } esp_err_t cloud_manager_send_temperature(cloud_manager_t *manager, float temp) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; char payload[64]; snprintf(payload, sizeof(payload), \u0026#34;%.2f\u0026#34;, temp); ESP_LOGI(TAG, \u0026#34;Temperatura: %.2f Â°C\u0026#34;, temp); int msg_id = esp_mqtt_client_publish(manager-\u0026gt;client, CONFIG_TEMPERATURE_CHANNEL, payload, 0, 1, 0); return msg_id \u0026gt;= 0 ? ESP_OK : ESP_FAIL; } esp_err_t cloud_manager_send_alarm(cloud_manager_t *manager) { if (!manager || !manager-\u0026gt;client) return ESP_ERR_INVALID_ARG; const char *alarm_payload = \u0026#34;ALARM ON!\u0026#34;; int msg_id = esp_mqtt_client_publish(manager-\u0026gt;client, CONFIG_ALARM_CHANNEL, alarm_payload, 0, 1, 0); return msg_id \u0026gt;= 0 ? ESP_OK : ESP_FAIL; } void cloud_manager_delete(cloud_manager_t *manager) { if (manager) { free(manager); } } Kconfig # menu \u0026#34;Configurazione Cloud MQTT\u0026#34; config BROKER_URL string \u0026#34;URL del Broker\u0026#34; default \u0026#34;mqtt://test.mosquitto.org/\u0026#34; help URL del broker a cui connettersi config TEMPERATURE_CHANNEL string \u0026#34;Canale MQTT per pubblicare la temperatura\u0026#34; default \u0026#34;/sensor/temperature\u0026#34; help Il canale nel broker MQTT dove viene pubblicata la temperatura config ALARM_CHANNEL string \u0026#34;Canale MQTT per pubblicare l\u0026#39;allarme\u0026#34; default \u0026#34;/sensor/alarm\u0026#34; help Il canale nel broker MQTT dove viene pubblicato l\u0026#39;allarme endmenu Puoi trovare lâ€™intero progetto soluzione nella cartella assignment_1_2 della repository GitHub.\nProssimo passo: Esercizio 1.3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-1-2/","section":"Workshops","summary":"Creare un componente \u003ccode\u003ecloud_manager\u003c/code\u003e e rifattorizzare il codice per usarlo.","title":"ESP-IDF Avanzato - Esercizio 1.2","type":"workshops"},{"content":"In questo esercizio, creerai due versioni di sdkconfig, una di produzione e una di debug.\nLâ€™unica differenza tra le due sarÃ  il logging: la versione debug mostrerÃ  tutti i log, mentre quella di produzione li sopprimerÃ  tutti.\nObiettivi del compito # Il tuo progetto deve avere i seguenti file di configurazione:\nsdkconfig.defaults: contenente solo la configurazione di target esp32-c3 sdkconfig.prod: contenente la configurazione per la soppressione dei log (sia dellâ€™app che del boot loader) sdkconfig.debug: contenente la configurazione per abilitare i log file profile per semplificare il comando di build La struttura finale della cartella del progetto sarÃ \n. |-- main | |-- CMakeLists.txt | |-- app_main.c | `-- idf_component.yml |-- profiles | |-- debug | `-- prod |-- sdkconfig |-- sdkconfig.debug |-- sdkconfig.defaults |-- sdkconfig.old `-- sdkconfig.prod Passaggi dell\u0026rsquo;esercizio # Creare la versione di produzione di sdkconfig (guidato) Creare un file profile (guidato) Creare la versione debug di sdkconfig Creare la versione di produzione (guidato) # Per creare la configurazione di debug, dobbiamo prima trovare le impostazioni dei log.\nModificare la configurazione in menuconfig # Apri il menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nNel campo di ricerca, inserisci \u0026ldquo;log\u0026rdquo;\nDeseleziona i campi seguenti\nBootloader Config â†’ Bootloader log verbosity Log â†’ Log Level â†’ Default log verbosity Creare il file sdkconfig.prod # Il modo piÃ¹ semplice per trovare i nomi delle configurazioni modificate Ã¨ eseguire lo strumento save-defconfig, che genererÃ  un file sdkconfig.defaults contenente solo i parametri modificati.\nESP-IDF: Save Default Config File (save-defconfig)\nApri il nuovo sdkconfig.defaults CONFIG_LOG_DEFAULT_LEVEL_NONE=y CONFIG_BOOTLOADER_LOG_LEVEL_NONE=y Copia le due configurazioni e incollale in un file sdkconfig.prod\nCompilazione # Apri un terminale: \u0026gt; ESP-IDF: Open ESP-IDF Terminal Per compilare la versione di produzione digita idf.py -B build-production -DSDKCONFIG=build-production/sdkconfig -DSDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.defaults;sdkconfig.prod\u0026#34; build Questo creerÃ  una cartella build-production per la versione \u0026ldquo;production\u0026rdquo;.\nPer caricare il progetto sul modulo, digita:\nidf.py -B build-debug -p \u0026lt;YOUR_PORT\u0026gt; flash monitor Creare file Profile # Per semplificare il processo creeremo un file profile.\nCrea una cartella profiles\nCrea un file prod allâ€™interno della cartella\nAggiungi i parametri CLI\n-B build-production -DSDKCONFIG=build-production/sdkconfig -DSDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.defaults;sdkconfig.prod\u0026#34; Ora possiamo compilare la versione di produzione usando\nidf.py @profiles/prod build Versione Debug # Ora puoi fare lo stesso per la configurazione di debug. Per questo passaggio del compito, devi creare e scrivere:\nsdkconfig.debug profiles/debug Codice soluzione del compito # Mostra codice soluzione skdconfig.defaults\n# This file was generated using idf.py save-defconfig. It can be edited manually. # Espressif IoT Development Framework (ESP-IDF) 5.4.2 Project Minimal Configuration # CONFIG_IDF_TARGET=\u0026#34;esp32c3\u0026#34; skdconfig.prod\nCONFIG_LOG_DEFAULT_LEVEL_NONE=y CONFIG_BOOTLOADER_LOG_LEVEL_NONE=y skdconfig.debug\nCONFIG_LOG_DEFAULT_LEVEL_INFO=y Puoi trovare lâ€™intero progetto di soluzione nella cartella assignment_1_3 del repository GitHub.\nPasso successivo: Lezione 2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-1-3/","section":"Workshops","summary":"Supporto per configurazioni multiple tramite sdkconfig (Guidato)","title":"ESP-IDF Avanzato - Esercizio 1.3","type":"workshops"},{"content":"In questo esercizio, separeremo il codice dell\u0026rsquo;allarme e della temperatura, utilizzando l\u0026rsquo;event loop di default.\nNel codice dell\u0026rsquo;esercizio precedente, abbiamo giÃ  utilizzando indirettamente questo event loop per catturare eventi MQTT e Wi-Fi. Obiettivi dell\u0026rsquo;esercizio # Creare gli eventi\nTEMP_EVENT_BASE - temp_event_id ALARM_EVENT_BASE - alarm_event_id_t Creare le funzioni handler\nalarm_event_handler temp_event_handler Registrare le funzioni handler\nCreare i due timer\nesp_timer_create esp_timer_start_periodic Creare le funzioni callback dei timer per inviare l\u0026rsquo;evento ogni 5s e 200ms\ntemp_timer_callback alarm_timer_callback Creare un loop di sleep infinito nel main\nCreare gli eventi # Definisci le due basi degli eventi a livello globale (ossia fuori da qualsiasi funzione)\nESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); Definisci il loro event_id come enum che in questo caso contengono un solo valore.\ntypedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, } alarm_event_id_t; Creare le funzioni handler # Crea le due funzioni handler degli eventi che si occupano di inviare i dati sul canale MQTT.\nstatic void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Failed to read temperature\u0026#34;); } } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { if (is_alarm_set(alarm)) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALARM ON!!\u0026#34;); cloud_manager_send_alarm(cloud); } } Registrare le funzioni handler # In app_main registra la due funzioni, specificando la base e l\u0026rsquo;id dell\u0026rsquo;evento a cui sono collegate: ESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); Creare i timer # La vera fonte degli eventi in questo esercizio sono i timer. Dobbiamo quindi avviarne due, uno per l\u0026rsquo;allarme ed uno per la temperatura.\nCreare ed avvia i timer per temperatura e allarme:\n// Creare e avviare timer periodici (app_main) // Timer temperatura const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); // Timer allarme const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(alarm_timer, ALARM_CHECK_PERIOD_US)); Le due macro ALARM_CHECK_PERIOD_US e TEMPERATURE_MEAS_PERIOD_US possono essere aggiunte come define allâ€™inizio del codice o come parametro del modulo.\nPer semplicitÃ , definisci le due macro in app_main.c\n#define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) Creare le funzioni callback dei timer # Nel codice precedente, abbiamo dato come .callback le funzioni temp_timer_callback e alarm_timer_callback. Queste funzioni vengono chiamate quando il timer scade.\nScrivi le funzioni callback per postare i relativi eventi\nstatic void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } L\u0026rsquo;event loop si occuperÃ  di chiamare la funzione corretta quando l\u0026rsquo;evento viene attivato.\nSleep nel main # Lâ€™ultima cosa da fare Ã¨ lasciare che il main continui a girare mentre gli eventi vengono attivati.\nAggiungi un loop idle al app_main\nwhile (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } Codice soluzione dell\u0026rsquo;esercizio # Mostra codice completo #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;temperature_sensor.h\u0026#34; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; #define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) ESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); static bool previous_alarm_set = false; typedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, } alarm_event_id_t; static temperature_sensor_t *sensor = NULL; static alarm_t *alarm = NULL; static cloud_manager_t *cloud = NULL; static void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Failed to read temperature\u0026#34;); } } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { bool alarm_state = is_alarm_set(alarm); if (alarm_state \u0026amp;\u0026amp; !previous_alarm_set) { printf(\u0026#34;ALARM ON!!\\n\u0026#34;); cloud_manager_send_alarm(cloud); } previous_alarm_set = alarm_state; } static void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } void app_main(void) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Starting...\u0026#34;); ESP_ERROR_CHECK(esp_event_loop_create_default()); sensor = temperature_sensor_create(); alarm = alarm_create(); cloud = cloud_manager_create(); printf(\u0026#34;Connecting...\\n\u0026#34;); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); printf(\u0026#34;Connected!\\n\u0026#34;); // Register event handlers ESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); // Create and start periodic timers const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(alarm_timer, ALARM_CHECK_PERIOD_US)); // The main task can now just sleep while (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } // Cleanup (unreachable in this example) cloud_manager_disconnect(cloud); cloud_manager_delete(cloud); temperature_sensor_delete(sensor); alarm_delete(alarm); } Puoi trovare lâ€™intero progetto della soluzione nella cartella assignment_2_1 del repository GitHub.\nConclusione # Lâ€™utilizzo di un event loop separa la gestione dellâ€™allarme e del sensore di temperatura. In questa esercizio, avremmo potuto ottenere lo stesso risultato usando le callback dei timer e evitando il sovraccarico dellâ€™event loop. In generale perÃ², gli eventi possono provenire da fonti diverse e lâ€™event loop offre un approccio unificato per separare la logica dellâ€™applicazione.\nProssimo passo # Se hai ancora tempo: Esercizio 2.2.\nNell\u0026rsquo;esercizio 2.2 si aggiunge unâ€™ulteriore fonte di evento attivata stavolta da un GPIO.\nAltrimenti: Lezione 3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-2-1/","section":"Workshops","summary":"Event loop: Gestire sensore di temperatura e allarme tramite eventi (guidato)","title":"ESP-IDF Avanzato - Esercizio 2.1","type":"workshops"},{"content":"In questo Esercizio, analizzerai la dimensione dell\u0026rsquo;immagine binaria e ottimizzerai l\u0026rsquo;uso della memoria della tua applicazione.\nObiettivi dell\u0026rsquo;esercizio # Compilare il progetto originale per individuare eventuali sezioni sovradimensionate o sospette (es. .text, .data, .rodata) che potrebbero nascondere codice non ottimizzato. Modificare la configurazione per ridurre la dimensione. Ricompilare il progetto per verificare i miglioramenti. Compilare il progetto originale # Riapri il codice dell\u0026rsquo;ultimo esercizio (che puÃ² essere indifferentemente il 2.1 o il 2.2) \u0026gt; ESP-IDF: Full Clean Project \u0026gt; ESP-IDF: Build Your Project Otterrai la tabella riepilogativa di Fig.1 per l\u0026rsquo;immagine binaria. Fig.1 - Analisi della dimensione\nRimozione dei log # Rimuovere l\u0026rsquo;output dei log nel menuconfig\nSe non ricordi come fare, dai un\u0026rsquo;occhiata all\u0026rsquo;Esercizio 1.3 \u0026gt; ESP-IDF: Build Your Project Fig.2 - Calcolo della dimensione dopo aver rimosso i log\nLa dimensione del binario Ã¨ diminuita di 77kb rispetto a prima.\nCertificate Bundle # Apri di nuovo il menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Deseleziona Certificate Bundle â†’ Enable trusted root certificate bundle \u0026gt; ESP-IDF: Build Your Project Fig.3 - Calcolo della dimensione dopo aver rimosso il certificate bundle\nOpzioni MQTT non usate # Aprire menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Deselezionare ESP-MQTT Configurations â†’ Enable MQTT over SSL Deselezionare ESP-MQTT Configurations â†’ Enable MQTT over Websocket \u0026gt; ESP-IDF: Build Your Project Fig.4 - Calcolo della dimensione dopo aver rimosso il supporto MQTT SSL e Websocket\nAbbiamo guadagnato altri 6,7kb.\nConclusione # In questo esercizio, abbiamo visto come verificare la dimensione del binario e come utilizzare il menuconfig per rimuovere opzioni non utilizzate al fine di migliorare l\u0026rsquo;uso della memoria della nostra applicazione.\nProssimo passo: Esercizio 3.2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-3-1/","section":"Workshops","summary":"Ridurre la dimensione del binario lavorando sulla configurazione. (guidato)","title":"ESP-IDF Avanzato - Esercizio 3.1","type":"workshops"},{"content":"Se hai ancora tempo, prova a trovare lâ€™altro bug nel codice utilizzando nuovamente le informazioni fornite dal core dump.\nTraccia della soluzione # Crea il file del core dump come hai fatto nel precedente esercizio.\nAspetta che si verifichi il crash Ferma il monitor (CTRL + ]) Esegui idf.py coredump-info \u0026gt; https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/coredump.txt Apri il file https://github.com/espressif/developer-portal-codebase/tree/main/content/workshops/esp-idf-advanced/coredump.txt Espandi il secondo core dump Executing action: coredump-info Serial port /dev/cu.usbmodem1131101 Connecting... Detecting chip type... ESP32-C3 =============================================================== ==================== ESP32 CORE DUMP START ==================== Crashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;, GDB name: \u0026#39;process 1070202648\u0026#39; Crashed task is not in the interrupt context ================== CURRENT THREAD REGISTERS =================== ra 0x4200dc68\t0x4200dc68 \u0026lt;temperature_sensor_read_celsius+10\u0026gt; sp 0x3fc9fe40\t0x3fc9fe40 gp 0x3fc94600\t0x3fc94600 \u0026lt;country_info_24ghz+200\u0026gt; tp 0x3fc9ff10\t0x3fc9ff10 t0 0x4005890e\t1074104590 t1 0x0\t0 t2 0xffffffff\t-1 fp 0x0\t0x0 s1 0x3fc9f13c\t1070199100 a0 0x3fcacc14\t1070255124 a1 0x3fc9fe5c\t1070202460 a2 0x0\t0 a3 0x0\t0 a4 0x3fcacb34\t1070254900 a5 0x0\t0 a6 0x4200d4c2\t1107350722 a7 0x9800000\t159383552 s2 0x0\t0 s3 0x0\t0 s4 0xffffffff\t-1 s5 0x0\t0 s6 0xffffffff\t-1 s7 0x3fcacb44\t1070254916 s8 0x0\t0 s9 0x0\t0 s10 0x0\t0 s11 0x0\t0 t3 0x0\t0 t4 0x604f\t24655 t5 0x0\t0 t6 0x0\t0 pc 0x0\t0x0 ==================== CURRENT THREAD STACK ===================== #0 0x00000000 in ?? () #1 0x4200dc68 in temperature_sensor_read_celsius (sensor=\u0026lt;optimized out\u0026gt;, temperature=temperature@entry=0x3fc9fe5c) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/temperature_sensor/temperature_sensor.c:150 #2 0x4200d4d4 in temp_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:50 #3 0x420b1942 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x0\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #4 0x420b228e in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #5 0x420b2386 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================== THREADS INFO ========================= Id Target Id Frame * 1 process 1070202648 0x00000000 in ?? () 2 process 1070198548 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 3 process 1070254080 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 4 process 1070196668 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 5 process 1070209148 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 6 process 1070222780 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 7 process 1070191796 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 TCB NAME PRIO C/B STACK USED/FREE ---------- ---------------- -------- ---------------- 0x3fc9ff18 sys_evt 20/20 352/2460 0x3fc9ef14 IDLE 0/0 208/1312 0x3fcac800 mqtt_task 5/5 624/5516 0x3fc9e7bc main 1/1 336/3752 0x3fca187c tiT 18/18 336/3240 0x3fca4dbc wifi 23/23 336/6312 0x3fc9d4b4 esp_timer 22/22 224/3856 ==================== THREAD 1 (TCB: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;) ===================== #0 0x00000000 in ?? () #1 0x4200dc68 in temperature_sensor_read_celsius (sensor=\u0026lt;optimized out\u0026gt;, temperature=temperature@entry=0x3fc9fe5c) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/temperature_sensor/temperature_sensor.c:150 #2 0x4200d4d4 in temp_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:50 #3 0x420b1942 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x0\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #4 0x420b228e in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #5 0x420b2386 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 Buona caccia al bug!\nMostra soluzione Lâ€™errore Ã¨ causato dalla riga 128 in app_main.c\nfree(sensor); Elimina lâ€™oggetto sensor e la lettura della temperatura sta usando un puntatore non valido.\nPasso successivo: Lezione 4\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-3-3/","section":"Workshops","summary":"Analizzare il core dump","title":"ESP-IDF Avanzato - Esercizio 3.3","type":"workshops"},{"content":"In questo esercizio, imposterai una tabella di partizioni personalizzata usando VS Code.\nObiettivi esercizio # Per prima cosa, devi abilitare la tabella di partizioni personalizzata in menuconfig.\nApri menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Partition Table â†’ Custom Partition Table CSV Apri l\u0026rsquo;editor: \u0026gt; ESP-IDF: Open Partition Table Editor UI Copia la tabella di partizioni precedente # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, Aggiungi una partizione spiffs Tabella di partizioni personalizzata\nCompila la tabella di partizioni: \u0026gt; ESP-IDF: Build Partition Table Flash della tabella di partizioni: \u0026gt; ESP-IDF: Flash (UART) Your Project Rileggi la tabella delle partizioni. Risultato lettura tabella delle partizioni Parsing binary partition input... Verifying table... # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nsv,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory_app,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, fs,data,spiffs,0x310000,64K, Prossimo passo: Esercizio 4.3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-4-2/","section":"Workshops","summary":"Creare una tabella di partizioni personalizzata","title":"ESP-IDF Avanzato - Esercizio 4.2","type":"workshops"},{"content":" In questo Esercizio abiliteremo la cifratura della flash.\nAbilitare la cifratura della flash (e il bootloader sicuro) Ã¨ unâ€™operazione irreversibile. Controllare attentamente ogni passaggio prima di procedere. Obiettivi dellâ€™esercizio # Verificare lo stato di cifratura del dispositivo Abilitare la cifratura della flash (modalitÃ  sviluppo) Impostare la tabella delle partizioni Verificare nuovamente lo stato di cifratura Verificare lo stato di cifratura del dispositivo # Aprire un terminale ESP-IDF: \u0026gt; ESP-IDF: Open ESP-IDF Terminal Allâ€™interno del terminale, eseguire idf.py efuse-summary Ora controlla gli eFuse rilevanti elencati nella tabella sottostante. Devono essere tutti nel loro stato predefinito (zero).\neFuse Descrizione BLOCK_KEYN Chiave AES. N Ã¨ compreso tra 0 e 5. KEY_PURPOSE_N Controlla il blocco eFuse BLOCK_KEYN, dove N Ã¨ tra 0 e 5. DIS_DOWNLOAD_MANUAL_ENCRYPT Disabilita la cifratura flash quando si utilizza la modalitÃ  di avvio download. SPI_BOOT_CRYPT_CNT Abilita cifratura quando Ã¨ impostata una modalitÃ  di avvio SPI. La funzione Ã¨ abilitata se 1 o 3 bit sono impostati nellâ€™eFuse. Mostra i blocchi eFuse EFUSE_NAME (Block) Description = [Meaningful Value] [Readable/Writeable] (Hex Value) ---------------------------------------------------------------------------------------- Calibration fuses: K_RTC_LDO (BLOCK1) BLOCK1 K_RTC_LDO = 96 R/W (0b0011000) K_DIG_LDO (BLOCK1) BLOCK1 K_DIG_LDO = 20 R/W (0b0000101) V_RTC_DBIAS20 (BLOCK1) BLOCK1 voltage of rtc dbias20 = 172 R/W (0x2b) V_DIG_DBIAS20 (BLOCK1) BLOCK1 voltage of digital dbias20 = 32 R/W (0x08) DIG_DBIAS_HVT (BLOCK1) BLOCK1 digital dbias when hvt = -12 R/W (0b10011) THRES_HVT (BLOCK1) BLOCK1 pvt threshold when hvt = 1600 R/W (0b0110010000) TEMP_CALIB (BLOCK2) Temperature calibration data = -9.0 R/W (0b101011010) OCODE (BLOCK2) ADC OCode = 96 R/W (0x60) ADC1_INIT_CODE_ATTEN0 (BLOCK2) ADC1 init code at atten0 = 1736 R/W (0b0110110010) ADC1_INIT_CODE_ATTEN1 (BLOCK2) ADC1 init code at atten1 = -272 R/W (0b1001000100) ADC1_INIT_CODE_ATTEN2 (BLOCK2) ADC1 init code at atten2 = -368 R/W (0b1001011100) ADC1_INIT_CODE_ATTEN3 (BLOCK2) ADC1 init code at atten3 = -824 R/W (0b1011001110) ADC1_CAL_VOL_ATTEN0 (BLOCK2) ADC1 calibration voltage at atten0 = -204 R/W (0b1000110011) ADC1_CAL_VOL_ATTEN1 (BLOCK2) ADC1 calibration voltage at atten1 = -4 R/W (0b1000000001) ADC1_CAL_VOL_ATTEN2 (BLOCK2) ADC1 calibration voltage at atten2 = -160 R/W (0b1000101000) ADC1_CAL_VOL_ATTEN3 (BLOCK2) ADC1 calibration voltage at atten3 = -332 R/W (0b1001010011) Config fuses: WR_DIS (BLOCK0) Disable programming of individual eFuses = 0 R/W (0x00000000) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 0 R/W (0b0000000) DIS_ICACHE (BLOCK0) Set this bit to disable Icache = False R/W (0b0) DIS_TWAI (BLOCK0) Set this bit to disable CAN function = False R/W (0b0) DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = False R/W (0b0) UART_PRINT_CONTROL (BLOCK0) Set the default UARTboot message output mode = Enable when GPIO8 is high at reset R/W (0b10) ERR_RST_ENABLE (BLOCK0) Use BLOCK0 to check error record registers = without check R/W (0b0) BLOCK_USR_DATA (BLOCK3) User data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_SYS_DATA2 (BLOCK10) System data part 2 (reserved) = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Flash fuses: FLASH_TPUW (BLOCK0) Configures flash waiting time after power-up; in u = 0 R/W (0x0) nit of ms. If the value is less than 15; the waiti ng time is the configurable value; Otherwise; the waiting time is twice the configurable value FORCE_SEND_RESUME (BLOCK0) Set this bit to force ROM code to send a resume co = False R/W (0b0) mmand during SPI boot FLASH_CAP (BLOCK1) Flash capacity = 4M R/W (0b001) FLASH_TEMP (BLOCK1) Flash temperature = 105C R/W (0b01) FLASH_VENDOR (BLOCK1) Flash vendor = XMC R/W (0b001) Identity fuses: DISABLE_WAFER_VERSION_MAJOR (BLOCK0) Disables check of wafer version major = False R/W (0b0) DISABLE_BLK_VERSION_MAJOR (BLOCK0) Disables check of blk version major = False R/W (0b0) WAFER_VERSION_MINOR_LO (BLOCK1) WAFER_VERSION_MINOR least significant bits = 3 R/W (0b011) PKG_VERSION (BLOCK1) Package version = 0 R/W (0b000) BLK_VERSION_MINOR (BLOCK1) BLK_VERSION_MINOR = 1 R/W (0b001) WAFER_VERSION_MINOR_HI (BLOCK1) WAFER_VERSION_MINOR most significant bit = False R/W (0b0) WAFER_VERSION_MAJOR (BLOCK1) WAFER_VERSION_MAJOR = 0 R/W (0b00) OPTIONAL_UNIQUE_ID (BLOCK2) Optional unique 128-bit ID = 7c c7 9b 3a 4c 1f e1 be 56 79 19 20 4f ff cd 0e R/W BLK_VERSION_MAJOR (BLOCK2) BLK_VERSION_MAJOR of BLOCK2 = With calibration R/W (0b01) WAFER_VERSION_MINOR (BLOCK0) calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI = 3 R/W (0x3) \u0026lt;\u0026lt; 3 + WAFER_VERSION_MINOR_LO (read only) Jtag fuses: SOFT_DIS_JTAG (BLOCK0) Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000) d number 1 means disable ). JTAG can be enabled in HMAC module DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = False R/W (0b0) is disabled permanently Mac fuses: MAC (BLOCK1) MAC address = 84:f7:03:42:8c:a8 (OK) R/W CUSTOM_MAC (BLOCK3) Custom MAC address = 00:00:00:00:00:00 (OK) R/W Security fuses: DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = False R/W (0b0) oot_mode[3:0] is 0; 1; 2; 3; 6; 7) DIS_FORCE_DOWNLOAD (BLOCK0) Set this bit to disable the function that forces c = False R/W (0b0) hip into download mode DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0) Set this bit to disable flash encryption when in d = False R/W (0b0) ownload boot modes SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Disable R/W (0b000) and disables otherwise SECURE_BOOT_KEY_REVOKE0 (BLOCK0) Revoke 1st secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE1 (BLOCK0) Revoke 2nd secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE2 (BLOCK0) Revoke 3rd secure boot key = False R/W (0b0) KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = USER R/W (0x0) KEY_PURPOSE_1 (BLOCK0) Purpose of Key1 = USER R/W (0x0) KEY_PURPOSE_2 (BLOCK0) Purpose of Key2 = USER R/W (0x0) KEY_PURPOSE_3 (BLOCK0) Purpose of Key3 = USER R/W (0x0) KEY_PURPOSE_4 (BLOCK0) Purpose of Key4 = USER R/W (0x0) KEY_PURPOSE_5 (BLOCK0) Purpose of Key5 = USER R/W (0x0) SECURE_BOOT_EN (BLOCK0) Set this bit to enable secure boot = False R/W (0b0) SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0) Set this bit to enable revoking aggressive secure = False R/W (0b0) boot DIS_DOWNLOAD_MODE (BLOCK0) Set this bit to disable download mode (boot_mode[3 = False R/W (0b0) :0] = 0; 1; 2; 3; 6; 7) ENABLE_SECURITY_DOWNLOAD (BLOCK0) Set this bit to enable secure UART download mode = False R/W (0b0) SECURE_VERSION (BLOCK0) Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000) ure) BLOCK_KEY0 (BLOCK4) Purpose: USER Key0 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY1 (BLOCK5) Purpose: USER Key1 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY2 (BLOCK6) Purpose: USER Key2 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY3 (BLOCK7) Purpose: USER Key3 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY4 (BLOCK8) Purpose: USER Key4 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY5 (BLOCK9) Purpose: USER Key5 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Spi Pad fuses: SPI_PAD_CONFIG_CLK (BLOCK1) SPI PAD CLK = 0 R/W (0b000000) SPI_PAD_CONFIG_Q (BLOCK1) SPI PAD Q(D1) = 0 R/W (0b000000) SPI_PAD_CONFIG_D (BLOCK1) SPI PAD D(D0) = 0 R/W (0b000000) SPI_PAD_CONFIG_CS (BLOCK1) SPI PAD CS = 0 R/W (0b000000) SPI_PAD_CONFIG_HD (BLOCK1) SPI PAD HD(D3) = 0 R/W (0b000000) SPI_PAD_CONFIG_WP (BLOCK1) SPI PAD WP(D2) = 0 R/W (0b000000) SPI_PAD_CONFIG_DQS (BLOCK1) SPI PAD DQS = 0 R/W (0b000000) SPI_PAD_CONFIG_D4 (BLOCK1) SPI PAD D4 = 0 R/W (0b000000) SPI_PAD_CONFIG_D5 (BLOCK1) SPI PAD D5 = 0 R/W (0b000000) SPI_PAD_CONFIG_D6 (BLOCK1) SPI PAD D6 = 0 R/W (0b000000) SPI_PAD_CONFIG_D7 (BLOCK1) SPI PAD D7 = 0 R/W (0b000000) Usb fuses: DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = False R/W (0b0) jtag in module of usb device DIS_USB_SERIAL_JTAG (BLOCK0) USB-Serial-JTAG = Enable R/W (0b0) USB_EXCHG_PINS (BLOCK0) Set this bit to exchange USB D+ and D- pins = False R/W (0b0) DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0) USB printing = Enable R/W (0b0) DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0) Disable UART download mode through USB-Serial-JTAG = False R/W (0b0) Vdd fuses: VDD_SPI_AS_GPIO (BLOCK0) Set this bit to vdd spi pin function as gpio = False R/W (0b0) Wdt fuses: WDT_DELAY_SEL (BLOCK0) RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00) ock cycle Abilitare la cifratura della flash # Aprire menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Security Features â†’ Enable flash encryption on boot (READ DOCS FIRST)\nAssicurarsi di avere: Enable usage mode â†’ Development (Not secure)\nDovresti avere una configurazione simile alla seguente:\nOpzioni di cifratura della flash\nAumentiamo la verbositÃ  del bootloader per vedere cosa succede:\nAprire menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Bootloader log verbosity â†’ verbose Impostare la tabella delle partizioni # Se provassi a flashare il progetto, otterresti un errore.\nMostra errore Successfully created esp32c3 image. Generated \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin [103/103] cd \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py \u0026amp;\u0026amp; \u0026lt;PYTHON_ENV_PATH\u0026gt;/bin/python \u0026lt;ESP_IDF_PATH\u0026gt;/components/partition_table/check_sizes.py --offset 0x8000 bootloader 0x0 \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin FAILED: esp-idf/esptool_py/CMakeFiles/bootloader_check_size \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py/CMakeFiles/bootloader_check_size cd \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/esp-idf/esptool_py \u0026amp;\u0026amp; \u0026lt;PYTHON_ENV_PATH\u0026gt;/bin/python \u0026lt;ESP_IDF_PATH\u0026gt;/components/partition_table/check_sizes.py --offset 0x8000 bootloader 0x0 \u0026lt;PROJECT_ROOT\u0026gt;/build/bootloader/bootloader.bin Error: Bootloader binary size 0x91f0 bytes is too large for partition table offset 0x8000. Bootloader binary can be maximum 0x8000 (32768) bytes unless the partition table offset is increased in the Partition Table section of the project configuration menu. ninja: build stopped: subcommand failed. [972/978] Generating ld/sections.ld ninja: build stopped: subcommand failed. Il motivo Ã¨ che il bootloader ora occupa piÃ¹ spazio e non rientra nello spazio del offset standard della tabella delle partizioni (0x8000). Ãˆ necessario cambiarlo a 0xf000 prima di procedere.\nApri menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig)\nâ†’ Offset of partition table â†’ 0xf000\nCompila il progetto e caricalo sul modulo.\n[Flash Encryption] WARNING: Flash Encryption in Development Mode This will burn eFuses on your device which is an IRREVERSIBLE operation. In Development Mode: Development Mode: Allows re-flashing with plaintext data The flash encryption process requires two steps: 1. First, you need to confirm by typing \u0026#34;BURN DEV\u0026#34; in the input box at the top of the screen 2. After flashing completes, you MUST reset your device 3. Then flash again to enable encryption I log di flashing saranno diversi dal solito questa volta, informandoci sul processo di cifratura della flash. Mostra i log D (122) boot: type=1 subtype=2 I (125) boot: 0 nvs WiFi data 01 02 00010000 00004000 D (132) boot: load partition table entry 0x3c00f020 D (136) boot: type=1 subtype=0 I (139) boot: 1 otadata OTA data 01 00 00014000 00002000 D (146) boot: load partition table entry 0x3c00f040 D (150) boot: type=1 subtype=1 I (153) boot: 2 phy_init RF data 01 01 00016000 00001000 D (160) boot: load partition table entry 0x3c00f060 D (164) boot: type=0 subtype=0 I (167) boot: 3 factory factory app 00 00 00020000 00100000 D (174) boot: load partition table entry 0x3c00f080 D (178) boot: type=0 subtype=10 I (181) boot: 4 ota_0 OTA app 00 10 00120000 00100000 D (188) boot: load partition table entry 0x3c00f0a0 D (192) boot: type=0 subtype=11 I (195) boot: 5 ota_1 OTA app 00 11 00220000 00100000 I (202) boot: End of partition table D (205) boot: OTA data offset 0x14000 D (208) bootloader_flash: rodata starts from paddr=0x00014000, size=0x2000, will be mapped to vaddr=0x3c000000 V (218) bootloader_flash: after mapping, starting from paddr=0x00010000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (229) boot: otadata[0]: sequence values 0xffffffff D (233) boot: otadata[1]: sequence values 0xffffffff D (238) boot: OTA sequence numbers both empty (all-0xFF) or partition table does not have bootable ota_apps (app_count=2) I (249) boot: Defaulting to factory image D (252) boot: Trying partition index -1 offs 0x20000 size 0x100000 D (258) esp_image: reading image header @ 0x20000 D (263) bootloader_flash: mmu set block paddr=0x00020000 (was 0xffffffff) D (269) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (275) esp_image: loading segment header 0 at offset 0x20018 V (280) esp_image: segment data length 0x1fd24 data starts 0x20020 V (286) esp_image: MMU page size 0x10000 V (290) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (297) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (305) esp_image: free data page_count 0x00000080 D (309) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (319) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (351) esp_image: loading segment header 1 at offset 0x3fd44 D (351) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (351) esp_image: segment data length 0x2cc data starts 0x3fd4c V (357) esp_image: MMU page size 0x10000 V (361) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (369) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) load D (376) esp_image: free data page_count 0x00000080 D (381) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (390) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (401) esp_image: loading segment header 2 at offset 0x40018 D (406) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (413) esp_image: segment data length 0xb4b94 data starts 0x40020 V (419) esp_image: MMU page size 0x10000 V (422) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (430) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (438) esp_image: free data page_count 0x00000080 D (442) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (452) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (580) esp_image: loading segment header 3 at offset 0xf4bb4 D (580) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (581) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (587) esp_image: MMU page size 0x10000 V (591) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (598) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) load D (606) esp_image: free data page_count 0x00000080 D (610) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (620) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (633) esp_image: loading segment header 4 at offset 0xf77e0 D (636) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (643) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (649) esp_image: MMU page size 0x10000 V (652) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (660) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) load D (668) esp_image: free data page_count 0x00000080 D (672) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (682) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (708) esp_image: loading segment header 5 at offset 0x10b4b0 D (708) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (709) esp_image: segment data length 0x1c data starts 0x10b4b8 V (714) esp_image: MMU page size 0x10000 V (718) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (726) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) load D (734) esp_image: free data page_count 0x00000080 D (738) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (748) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (758) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (764) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (771) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (785) boot: Loaded app from partition at offset 0x20000 I (785) boot: Checking flash encryption... D (788) efuse: BLK0 REG2 [18-20], len=3 bits D (792) efuse: BLK0 REG0 [4-4], len=1 bits V (796) flash_encrypt: CRYPT_CNT 0, write protection 0 D (801) efuse: BLK0 REG0 [4-4], len=1 bits D (805) efuse: BLK0 REG2 [18-20], len=3 bits I (809) efuse: Batch mode of writing fields is enabled D (814) efuse: BLK0 REG2 [24-27], len=4 bits D (818) efuse: BLK0 REG2 [28-31], len=4 bits D (822) efuse: BLK0 REG3 [0-3], len=4 bits D (825) efuse: BLK0 REG3 [4-7], len=4 bits D (829) efuse: BLK0 REG3 [8-11], len=4 bits D (833) efuse: BLK0 REG3 [12-15], len=4 bits I (837) flash_encrypt: Generating new flash encryption key... D (843) flash_encrypt: Key generation complete D (847) efuse: BLK0 REG2 [24-27], len=4 bits D (851) efuse: BLK0 REG0 [8-8], len=1 bits D (855) efuse: BLK0 REG1 [0-0], len=1 bits D (858) efuse: BLK0 REG0 [23-23], len=1 bits D (862) efuse: BLK4 REG0 [0-31], len=32 bits D (866) efuse: BLK4 REG1 [0-31], len=32 bits D (870) efuse: BLK4 REG2 [0-31], len=32 bits D (874) efuse: BLK4 REG3 [0-31], len=32 bits D (878) efuse: BLK4 REG4 [0-31], len=32 bits D (882) efuse: BLK4 REG5 [0-31], len=32 bits D (886) efuse: BLK4 REG6 [0-31], len=32 bits D (890) efuse: BLK4 REG7 [0-31], len=32 bits D (894) efuse: BLK0 REG2 [28-31], len=4 bits D (898) efuse: BLK0 REG0 [9-9], len=1 bits D (902) efuse: BLK0 REG1 [1-1], len=1 bits D (906) efuse: BLK0 REG0 [24-24], len=1 bits D (910) efuse: BLK5 REG0 [0-31], len=32 bits D (914) efuse: BLK5 REG1 [0-31], len=32 bits D (918) efuse: BLK5 REG2 [0-31], len=32 bits D (922) efuse: BLK5 REG3 [0-31], len=32 bits D (926) efuse: BLK5 REG4 [0-31], len=32 bits D (930) efuse: BLK5 REG5 [0-31], len=32 bits D (934) efuse: BLK5 REG6 [0-31], len=32 bits D (938) efuse: BLK5 REG7 [0-31], len=32 bits D (942) efuse: BLK0 REG3 [0-3], len=4 bits D (946) efuse: BLK0 REG0 [10-10], len=1 bits D (950) efuse: BLK0 REG1 [2-2], len=1 bits D (954) efuse: BLK0 REG0 [25-25], len=1 bits D (958) efuse: BLK6 REG0 [0-31], len=32 bits D (962) efuse: BLK6 REG1 [0-31], len=32 bits D (966) efuse: BLK6 REG2 [0-31], len=32 bits D (970) efuse: BLK6 REG3 [0-31], len=32 bits D (974) efuse: BLK6 REG4 [0-31], len=32 bits D (978) efuse: BLK6 REG5 [0-31], len=32 bits D (982) efuse: BLK6 REG6 [0-31], len=32 bits D (986) efuse: BLK6 REG7 [0-31], len=32 bits D (990) efuse: BLK0 REG3 [4-7], len=4 bits D (993) efuse: BLK0 REG0 [11-11], len=1 bits D (997) efuse: BLK0 REG1 [3-3], len=1 bits D (1001) efuse: BLK0 REG0 [26-26], len=1 bits D (1005) efuse: BLK7 REG0 [0-31], len=32 bits D (1009) efuse: BLK7 REG1 [0-31], len=32 bits D (1013) efuse: BLK7 REG2 [0-31], len=32 bits D (1017) efuse: BLK7 REG3 [0-31], len=32 bits D (1022) efuse: BLK7 REG4 [0-31], len=32 bits D (1026) efuse: BLK7 REG5 [0-31], len=32 bits D (1030) efuse: BLK7 REG6 [0-31], len=32 bits D (1034) efuse: BLK7 REG7 [0-31], len=32 bits D (1038) efuse: BLK0 REG3 [8-11], len=4 bits D (1042) efuse: BLK0 REG0 [12-12], len=1 bits D (1046) efuse: BLK0 REG1 [4-4], len=1 bits D (1050) efuse: BLK0 REG0 [27-27], len=1 bits D (1054) efuse: BLK8 REG0 [0-31], len=32 bits D (1058) efuse: BLK8 REG1 [0-31], len=32 bits D (1062) efuse: BLK8 REG2 [0-31], len=32 bits D (1066) efuse: BLK8 REG3 [0-31], len=32 bits D (1070) efuse: BLK8 REG4 [0-31], len=32 bits D (1074) efuse: BLK8 REG5 [0-31], len=32 bits D (1078) efuse: BLK8 REG6 [0-31], len=32 bits D (1082) efuse: BLK8 REG7 [0-31], len=32 bits D (1087) efuse: BLK0 REG3 [12-15], len=4 bits D (1091) efuse: BLK0 REG0 [13-13], len=1 bits D (1095) efuse: BLK0 REG1 [5-5], len=1 bits D (1099) efuse: BLK0 REG0 [28-28], len=1 bits D (1103) efuse: BLK9 REG0 [0-31], len=32 bits D (1107) efuse: BLK9 REG1 [0-31], len=32 bits D (1111) efuse: BLK9 REG2 [0-31], len=32 bits D (1115) efuse: BLK9 REG3 [0-31], len=32 bits D (1119) efuse: BLK9 REG4 [0-31], len=32 bits D (1123) efuse: BLK9 REG5 [0-31], len=32 bits D (1127) efuse: BLK9 REG6 [0-31], len=32 bits D (1131) efuse: BLK9 REG7 [0-31], len=32 bits D (1135) efuse: BLK0 REG2 [24-27], len=4 bits D (1139) efuse: BLK0 REG0 [8-8], len=1 bits D (1143) efuse: BLK0 REG1 [0-0], len=1 bits D (1147) efuse: BLK0 REG0 [23-23], len=1 bits D (1151) efuse: BLK4 REG0 [0-31], len=32 bits D (1155) efuse: BLK4 REG1 [0-31], len=32 bits D (1159) efuse: BLK4 REG2 [0-31], len=32 bits D (1164) efuse: BLK4 REG3 [0-31], len=32 bits D (1168) efuse: BLK4 REG4 [0-31], len=32 bits D (1172) efuse: BLK4 REG5 [0-31], len=32 bits D (1176) efuse: BLK4 REG6 [0-31], len=32 bits D (1180) efuse: BLK4 REG7 [0-31], len=32 bits I (1184) efuse: Writing EFUSE_BLK_KEY0 with purpose 4 D (1189) efuse: BLK0 REG2 [24-27], len=4 bits D (1193) efuse: BLK0 REG0 [8-8], len=1 bits D (1197) efuse: BLK0 REG1 [0-0], len=1 bits D (1201) efuse: BLK0 REG0 [23-23], len=1 bits D (1205) efuse: BLK4 REG0 [0-31], len=32 bits D (1209) efuse: BLK4 REG1 [0-31], len=32 bits D (1213) efuse: BLK4 REG2 [0-31], len=32 bits D (1217) efuse: BLK4 REG3 [0-31], len=32 bits D (1221) efuse: BLK4 REG4 [0-31], len=32 bits D (1225) efuse: BLK4 REG5 [0-31], len=32 bits D (1229) efuse: BLK4 REG6 [0-31], len=32 bits D (1233) efuse: BLK4 REG7 [0-31], len=32 bits D (1237) efuse: BLK4 REG0 [0-31], len=32 bits D (1241) efuse: BLK4 REG1 [0-31], len=32 bits D (1245) efuse: BLK4 REG2 [0-31], len=32 bits D (1250) efuse: BLK4 REG3 [0-31], len=32 bits D (1254) efuse: BLK4 REG4 [0-31], len=32 bits D (1258) efuse: BLK4 REG5 [0-31], len=32 bits D (1262) efuse: BLK4 REG6 [0-31], len=32 bits D (1266) efuse: BLK4 REG7 [0-31], len=32 bits D (1270) efuse: BLK0 REG0 [23-23], len=1 bits D (1274) efuse: BLK0 REG0 [23-23], len=1 bits D (1278) efuse: BLK0 REG1 [0-0], len=1 bits D (1282) efuse: BLK0 REG1 [0-0], len=1 bits D (1286) efuse: BLK0 REG2 [24-27], len=4 bits D (1290) efuse: BLK0 REG0 [8-8], len=1 bits D (1294) efuse: BLK0 REG0 [8-8], len=1 bits W (1298) flash_encrypt: Not disabling UART bootloader encryption I (1304) flash_encrypt: Disable UART bootloader cache... D (1309) efuse: BLK0 REG1 [10-10], len=1 bits D (1313) efuse: BLK0 REG1 [10-10], len=1 bits I (1317) flash_encrypt: Disable JTAG... D (1320) efuse: BLK0 REG1 [19-19], len=1 bits D (1324) efuse: BLK0 REG1 [19-19], len=1 bits D (1328) efuse: BLK0 REG1 [9-9], len=1 bits D (1332) efuse: BLK0 REG1 [9-9], len=1 bits D (1336) efuse: BLK0 REG4 [1-1], len=1 bits D (1340) efuse: BLK0 REG4 [1-1], len=1 bits I (1345) efuse: BURN BLOCK4 I (1350) efuse: BURN BLOCK4 - OK (write block == read block) I (1352) efuse: BURN BLOCK0 I (1357) efuse: BURN BLOCK0 - OK (all write block bits are set) I (1360) efuse: Batch mode. Prepared fields are committed D (1365) esp_image: reading image header @ 0x0 D (1369) bootloader_flash: mmu set block paddr=0x00000000 (was 0x00100000) D (1376) esp_image: image header: 0xe9 0x03 0x02 0x02 403cc71a V (1382) esp_image: loading segment header 0 at offset 0x18 V (1387) esp_image: segment data length 0x32e8 data starts 0x20 V (1393) esp_image: MMU page size 0x10000 V (1396) esp_image: segment 0 map_segment 0 segment_data_offs 0x20 load_addr 0x3fcd5990 I (1404) esp_image: segment 0: paddr=00000020 vaddr=3fcd5990 size=032e8h ( 13032) D (1411) esp_image: free data page_count 0x00000080 D (1416) bootloader_flash: rodata starts from paddr=0x00000020, size=0x32e8, will be mapped to vaddr=0x3c000000 V (1426) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1437) esp_image: loading segment header 1 at offset 0x3308 D (1442) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) V (1448) esp_image: segment data length 0xcfc data starts 0x3310 V (1454) esp_image: MMU page size 0x10000 V (1458) esp_image: segment 1 map_segment 0 segment_data_offs 0x3310 load_addr 0x403cc710 I (1466) esp_image: segment 1: paddr=00003310 vaddr=403cc710 size=00cfch ( 3324) D (1473) esp_image: free data page_count 0x00000080 D (1477) bootloader_flash: rodata starts from paddr=0x00003310, size=0xcfc, will be mapped to vaddr=0x3c000000 V (1487) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1498) esp_image: loading segment header 2 at offset 0x400c D (1503) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) V (1510) esp_image: segment data length 0x51b8 data starts 0x4014 V (1516) esp_image: MMU page size 0x10000 V (1519) esp_image: segment 2 map_segment 0 segment_data_offs 0x4014 load_addr 0x403ce710 I (1527) esp_image: segment 2: paddr=00004014 vaddr=403ce710 size=051b8h ( 20920) D (1535) esp_image: free data page_count 0x00000080 D (1539) bootloader_flash: rodata starts from paddr=0x00004014, size=0x51b8, will be mapped to vaddr=0x3c000000 V (1549) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (1561) esp_image: image start 0x00000000 end of last section 0x000091cc D (1566) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) D (1573) flash_encrypt: bootloader is plaintext. Encrypting... I (2151) flash_encrypt: bootloader encrypted successfully D (2151) flash_parts: partition table verified, 7 entries D (2151) flash_encrypt: partition table is plaintext. Encrypting... I (2205) flash_encrypt: partition table encrypted and loaded successfully I (2206) flash_encrypt: Encrypting partition 1 at offset 0x14000 (length 0x2000)... I (2331) flash_encrypt: Done encrypting D (2331) esp_image: reading image header @ 0x20000 D (2331) bootloader_flash: mmu set block paddr=0x00020000 (was 0x00000000) D (2334) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (2340) esp_image: loading segment header 0 at offset 0x20018 V (2345) esp_image: segment data length 0x1fd24 data starts 0x20020 V (2351) esp_image: MMU page size 0x10000 V (2355) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (2363) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (2370) esp_image: free data page_count 0x00000080 D (2375) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (2385) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2416) esp_image: loading segment header 1 at offset 0x3fd44 D (2416) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (2417) esp_image: segment data length 0x2cc data starts 0x3fd4c V (2423) esp_image: MMU page size 0x10000 V (2427) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (2435) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) D (2442) esp_image: free data page_count 0x00000080 D (2447) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (2456) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2467) esp_image: loading segment header 2 at offset 0x40018 D (2472) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (2479) esp_image: segment data length 0xb4b94 data starts 0x40020 V (2485) esp_image: MMU page size 0x10000 V (2489) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (2497) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (2504) esp_image: free data page_count 0x00000080 D (2509) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (2519) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (2647) esp_image: loading segment header 3 at offset 0xf4bb4 D (2647) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (2648) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (2654) esp_image: MMU page size 0x10000 V (2658) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (2666) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) D (2673) esp_image: free data page_count 0x00000080 D (2678) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (2687) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (2700) esp_image: loading segment header 4 at offset 0xf77e0 D (2703) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (2710) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (2716) esp_image: MMU page size 0x10000 V (2720) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (2728) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) D (2735) esp_image: free data page_count 0x00000080 D (2740) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (2750) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (2773) esp_image: loading segment header 5 at offset 0x10b4b0 D (2773) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (2774) esp_image: segment data length 0x1c data starts 0x10b4b8 V (2780) esp_image: MMU page size 0x10000 V (2784) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (2792) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) D (2799) esp_image: free data page_count 0x00000080 D (2804) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (2813) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (2824) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (2830) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (2837) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (2845) flash_encrypt: Encrypting partition 3 at offset 0x20000 (length 0xeb500)... I (16131) flash_encrypt: Done encrypting D (16131) esp_image: reading image header @ 0x120000 D (16131) bootloader_flash: mmu set block paddr=0x00120000 (was 0x00100000) D (16135) esp_image: image header: 0x09 0xe5 0x92 0x04 10ef8522 E (16140) esp_image: image at 0x120000 has invalid magic byte (nothing flashed here?) D (16148) esp_image: reading image header @ 0x220000 D (16153) bootloader_flash: mmu set block paddr=0x00220000 (was 0x00120000) D (16159) esp_image: image header: 0xff 0xff 0xff 0x0f ffffffff E (16165) esp_image: image at 0x220000 has invalid magic byte (nothing flashed here?) D (16172) flash_encrypt: All flash regions checked for encryption pass D (16179) efuse: BLK0 REG0 [4-4], len=1 bits D (16183) efuse: BLK0 REG2 [18-20], len=3 bits D (16187) flash_encrypt: CRYPT_CNT 0 -\u0026gt; 1 D (16191) efuse: BLK0 REG2 [18-20], len=3 bits I (16195) efuse: BURN BLOCK0 I (16200) efuse: BURN BLOCK0 - OK (all write block bits are set) I (16204) flash_encrypt: Flash encryption completed I (16208) boot: Resetting with flash encryption enabled... ESP-ROM:esp32c3-api1-20210207 Build:Feb 7 2021 rst:0x3 (RTC_SW_SYS_RST),boot:0xc (SPI_FAST_FLASH_BOOT) Saved PC:0x40048b82 --- 0x40048b82: ets_secure_boot_verify_bootloader_with_keys in ROM SPIWP:0xee mode:DIO, clock div:1 load:0x3fcd5990,len:0x32e8 load:0x403cc710,len:0xcfc load:0x403ce710,len:0x51b8 entry 0x403cc71a I (31) boot: ESP-IDF v5.4.2-dirty 2nd stage bootloader I (31) boot: compile time Jul 22 2025 09:21:12 D (31) bootloader_flash: XMC chip detected by RDID (00204016), skip. D (35) bootloader_flash: mmu set block paddr=0x00000000 (was 0xffffffff) I (41) boot: chip revision: v0.3 I (44) boot: efuse block revision: v1.1 D (48) boot.esp32c3: magic e9 D (51) boot.esp32c3: segments 03 D (53) boot.esp32c3: spi_mode 02 D (56) boot.esp32c3: spi_speed 0f D (59) boot.esp32c3: spi_size 02 I (62) boot.esp32c3: SPI Speed : 80MHz I (66) boot.esp32c3: SPI Mode : DIO I (70) boot.esp32c3: SPI Flash Size : 4MB D (74) boot: Enabling RTCWDT(9000 ms) I (77) boot: Enabling RNG early entropy source... D (82) bootloader_flash: rodata starts from paddr=0x0000f000, size=0xc00, will be mapped to vaddr=0x3c000000 V (91) bootloader_flash: after mapping, starting from paddr=0x00000000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (101) boot: mapped partition table 0xf000 at 0x3c00f000 D (107) flash_parts: partition table verified, 7 entries I (112) boot: Partition Table: I (114) boot: ## Label Usage Type ST Offset Length D (121) boot: load partition table entry 0x3c00f000 D (125) boot: type=1 subtype=2 I (128) boot: 0 nvs WiFi data 01 02 00010000 00004000 D (135) boot: load partition table entry 0x3c00f020 D (139) boot: type=1 subtype=0 I (142) boot: 1 otadata OTA data 01 00 00014000 00002000 D (149) boot: load partition table entry 0x3c00f040 D (153) boot: type=1 subtype=1 I (156) boot: 2 phy_init RF data 01 01 00016000 00001000 D (163) boot: load partition table entry 0x3c00f060 D (167) boot: type=0 subtype=0 I (170) boot: 3 factory factory app 00 00 00020000 00100000 D (177) boot: load partition table entry 0x3c00f080 D (181) boot: type=0 subtype=10 I (184) boot: 4 ota_0 OTA app 00 10 00120000 00100000 D (191) boot: load partition table entry 0x3c00f0a0 D (195) boot: type=0 subtype=11 I (198) boot: 5 ota_1 OTA app 00 11 00220000 00100000 I (205) boot: End of partition table D (208) boot: OTA data offset 0x14000 D (212) bootloader_flash: rodata starts from paddr=0x00014000, size=0x2000, will be mapped to vaddr=0x3c000000 V (221) bootloader_flash: after mapping, starting from paddr=0x00010000 and vaddr=0x3c000000, 0x10000 bytes are mapped D (232) boot: otadata[0]: sequence values 0xffffffff D (236) boot: otadata[1]: sequence values 0xffffffff D (241) boot: OTA sequence numbers both empty (all-0xFF) or partition table does not have bootable ota_apps (app_count=2) I (252) boot: Defaulting to factory image D (255) boot: Trying partition index -1 offs 0x20000 size 0x100000 D (261) esp_image: reading image header @ 0x20000 D (266) bootloader_flash: mmu set block paddr=0x00020000 (was 0xffffffff) D (272) esp_image: image header: 0xe9 0x06 0x02 0x02 403802ea V (278) esp_image: loading segment header 0 at offset 0x20018 V (283) esp_image: segment data length 0x1fd24 data starts 0x20020 V (289) esp_image: MMU page size 0x10000 V (293) esp_image: segment 0 map_segment 1 segment_data_offs 0x20020 load_addr 0x3c0c0020 I (301) esp_image: segment 0: paddr=00020020 vaddr=3c0c0020 size=1fd24h (130340) map D (308) esp_image: free data page_count 0x00000080 D (313) bootloader_flash: rodata starts from paddr=0x00020020, size=0x1fd24, will be mapped to vaddr=0x3c000000 V (322) bootloader_flash: after mapping, starting from paddr=0x00020000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (356) esp_image: loading segment header 1 at offset 0x3fd44 D (356) bootloader_flash: mmu set block paddr=0x00030000 (was 0xffffffff) V (357) esp_image: segment data length 0x2cc data starts 0x3fd4c V (362) esp_image: MMU page size 0x10000 V (366) esp_image: segment 1 map_segment 0 segment_data_offs 0x3fd4c load_addr 0x3fc93e00 I (374) esp_image: segment 1: paddr=0003fd4c vaddr=3fc93e00 size=002cch ( 716) load D (382) esp_image: free data page_count 0x00000080 D (386) bootloader_flash: rodata starts from paddr=0x0003fd4c, size=0x2cc, will be mapped to vaddr=0x3c000000 V (396) bootloader_flash: after mapping, starting from paddr=0x00030000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (406) esp_image: loading segment header 2 at offset 0x40018 D (412) bootloader_flash: mmu set block paddr=0x00040000 (was 0xffffffff) V (418) esp_image: segment data length 0xb4b94 data starts 0x40020 V (424) esp_image: MMU page size 0x10000 V (428) esp_image: segment 2 map_segment 1 segment_data_offs 0x40020 load_addr 0x42000020 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 I (436) esp_image: segment 2: paddr=00040020 vaddr=42000020 size=b4b94h (740244) map D (443) esp_image: free data page_count 0x00000080 D (447) bootloader_flash: rodata starts from paddr=0x00040020, size=0xb4b94, will be mapped to vaddr=0x3c000000 V (457) bootloader_flash: after mapping, starting from paddr=0x00040000 and vaddr=0x3c000000, 0xc0000 bytes are mapped V (598) esp_image: loading segment header 3 at offset 0xf4bb4 D (598) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (599) esp_image: segment data length 0x2c24 data starts 0xf4bbc V (604) esp_image: MMU page size 0x10000 V (608) esp_image: segment 3 map_segment 0 segment_data_offs 0xf4bbc load_addr 0x3fc940cc I (616) esp_image: segment 3: paddr=000f4bbc vaddr=3fc940cc size=02c24h ( 11300) load D (623) esp_image: free data page_count 0x00000080 D (628) bootloader_flash: rodata starts from paddr=0x000f4bbc, size=0x2c24, will be mapped to vaddr=0x3c000000 V (638) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (650) esp_image: loading segment header 4 at offset 0xf77e0 D (654) bootloader_flash: mmu set block paddr=0x000f0000 (was 0xffffffff) V (660) esp_image: segment data length 0x13cc8 data starts 0xf77e8 V (666) esp_image: MMU page size 0x10000 V (670) esp_image: segment 4 map_segment 0 segment_data_offs 0xf77e8 load_addr 0x40380000 --- 0x40380000: _vector_table at /Users/francesco/esp/v5.4.2/esp-idf/components/riscv/vectors_intc.S:54 I (678) esp_image: segment 4: paddr=000f77e8 vaddr=40380000 size=13cc8h ( 81096) load D (685) esp_image: free data page_count 0x00000080 D (690) bootloader_flash: rodata starts from paddr=0x000f77e8, size=0x13cc8, will be mapped to vaddr=0x3c000000 V (699) bootloader_flash: after mapping, starting from paddr=0x000f0000 and vaddr=0x3c000000, 0x20000 bytes are mapped V (727) esp_image: loading segment header 5 at offset 0x10b4b0 D (727) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) V (727) esp_image: segment data length 0x1c data starts 0x10b4b8 V (733) esp_image: MMU page size 0x10000 V (737) esp_image: segment 5 map_segment 0 segment_data_offs 0x10b4b8 load_addr 0x50000000 I (745) esp_image: segment 5: paddr=0010b4b8 vaddr=50000000 size=0001ch ( 28) load D (752) esp_image: free data page_count 0x00000080 D (757) bootloader_flash: rodata starts from paddr=0x0010b4b8, size=0x1c, will be mapped to vaddr=0x3c000000 V (766) bootloader_flash: after mapping, starting from paddr=0x00100000 and vaddr=0x3c000000, 0x10000 bytes are mapped V (777) esp_image: image start 0x00020000 end of last section 0x0010b4d4 D (783) bootloader_flash: mmu set block paddr=0x00100000 (was 0xffffffff) D (790) boot: Calculated hash: 95320d19f00e1b0ae9da94d51f205ea7a1731fc9a3252e2a61a665c109798d46 I (804) boot: Loaded app from partition at offset 0x20000 I (804) boot: Checking flash encryption... D (807) efuse: BLK0 REG2 [18-20], len=3 bits D (811) efuse: BLK0 REG0 [4-4], len=1 bits V (815) flash_encrypt: CRYPT_CNT 1, write protection 0 I (820) flash_encrypt: flash encryption is enabled (1 plaintext flashes left) I (827) boot: Disabling RNG early entropy source... D (831) boot: Mapping segment 0 as DROM D (835) boot: Mapping segment 2 as IROM D (838) boot: calling set_cache_and_start_app D (842) boot: configure drom and irom and start V (847) boot: rodata starts from paddr=0x00020020, vaddr=0x3c0c0020, size=0x1fd24 V (854) boot: after mapping rodata, starting from paddr=0x00020000 and vaddr=0x3c0c0000, 0x20000 bytes are mapped V (864) boot: mapped one page of the rodata, from paddr=0x00020000 and vaddr=0x3c7f0000, 0x10000 bytes are mapped V (874) boot: text starts from paddr=0x00040020, vaddr=0x42000020, size=0xb4b94 --- 0x42000020: esp_app_format_init_elf_sha256 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_app_format/esp_app_desc.c:88 V (881) boot: after mapping text, starting from paddr=0x00040000 and vaddr=0x42000000, 0xc0000 bytes are mapped D (891) boot: start: 0x403802ea --- 0x403802ea: call_start_cpu0 at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/port/cpu_start.c:387 Dovete completare gli ultimi due passaggi:\nPremere il pulsante di reset sul dispositivo Caricare di nuovo il progetto: \u0026gt; ESP-IDF: Flash (UART) Your Project Verificare nuovamente lo stato di cifratura del dispositivo # Aprire un terminale ESP-IDF: \u0026gt; ESP-IDF: Open ESP-IDF Terminal Allâ€™interno del terminale, eseguire idf.py efuse-summary Mostra estratto degli eFuses espefuse.py v4.9.0 Connecting... === Run \u0026#34;summary\u0026#34; command === EFUSE_NAME (Block) Description = [Meaningful Value] [Readable/Writeable] (Hex Value) ---------------------------------------------------------------------------------------- Calibration fuses: K_RTC_LDO (BLOCK1) BLOCK1 K_RTC_LDO = 96 R/W (0b0011000) K_DIG_LDO (BLOCK1) BLOCK1 K_DIG_LDO = 20 R/W (0b0000101) V_RTC_DBIAS20 (BLOCK1) BLOCK1 voltage of rtc dbias20 = 172 R/W (0x2b) V_DIG_DBIAS20 (BLOCK1) BLOCK1 voltage of digital dbias20 = 32 R/W (0x08) DIG_DBIAS_HVT (BLOCK1) BLOCK1 digital dbias when hvt = -12 R/W (0b10011) THRES_HVT (BLOCK1) BLOCK1 pvt threshold when hvt = 1600 R/W (0b0110010000) TEMP_CALIB (BLOCK2) Temperature calibration data = -9.0 R/W (0b101011010) OCODE (BLOCK2) ADC OCode = 96 R/W (0x60) ADC1_INIT_CODE_ATTEN0 (BLOCK2) ADC1 init code at atten0 = 1736 R/W (0b0110110010) ADC1_INIT_CODE_ATTEN1 (BLOCK2) ADC1 init code at atten1 = -272 R/W (0b1001000100) ADC1_INIT_CODE_ATTEN2 (BLOCK2) ADC1 init code at atten2 = -368 R/W (0b1001011100) ADC1_INIT_CODE_ATTEN3 (BLOCK2) ADC1 init code at atten3 = -824 R/W (0b1011001110) ADC1_CAL_VOL_ATTEN0 (BLOCK2) ADC1 calibration voltage at atten0 = -204 R/W (0b1000110011) ADC1_CAL_VOL_ATTEN1 (BLOCK2) ADC1 calibration voltage at atten1 = -4 R/W (0b1000000001) ADC1_CAL_VOL_ATTEN2 (BLOCK2) ADC1 calibration voltage at atten2 = -160 R/W (0b1000101000) ADC1_CAL_VOL_ATTEN3 (BLOCK2) ADC1 calibration voltage at atten3 = -332 R/W (0b1001010011) Config fuses: WR_DIS (BLOCK0) Disable programming of individual eFuses = 8388864 R/W (0x00800100) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 1 R/W (0b0000001) DIS_ICACHE (BLOCK0) Set this bit to disable Icache = False R/W (0b0) DIS_TWAI (BLOCK0) Set this bit to disable CAN function = False R/W (0b0) DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = True R/W (0b1) UART_PRINT_CONTROL (BLOCK0) Set the default UARTboot message output mode = Enable when GPIO8 is high at reset R/W (0b10) ERR_RST_ENABLE (BLOCK0) Use BLOCK0 to check error record registers = without check R/W (0b0) BLOCK_USR_DATA (BLOCK3) User data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_SYS_DATA2 (BLOCK10) System data part 2 (reserved) = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Flash fuses: FLASH_TPUW (BLOCK0) Configures flash waiting time after power-up; in u = 0 R/W (0x0) nit of ms. If the value is less than 15; the waiti ng time is the configurable value; Otherwise; the waiting time is twice the configurable value FORCE_SEND_RESUME (BLOCK0) Set this bit to force ROM code to send a resume co = False R/W (0b0) mmand during SPI boot FLASH_CAP (BLOCK1) Flash capacity = 4M R/W (0b001) FLASH_TEMP (BLOCK1) Flash temperature = 105C R/W (0b01) FLASH_VENDOR (BLOCK1) Flash vendor = XMC R/W (0b001) Identity fuses: DISABLE_WAFER_VERSION_MAJOR (BLOCK0) Disables check of wafer version major = False R/W (0b0) DISABLE_BLK_VERSION_MAJOR (BLOCK0) Disables check of blk version major = False R/W (0b0) WAFER_VERSION_MINOR_LO (BLOCK1) WAFER_VERSION_MINOR least significant bits = 3 R/W (0b011) PKG_VERSION (BLOCK1) Package version = 0 R/W (0b000) BLK_VERSION_MINOR (BLOCK1) BLK_VERSION_MINOR = 1 R/W (0b001) WAFER_VERSION_MINOR_HI (BLOCK1) WAFER_VERSION_MINOR most significant bit = False R/W (0b0) WAFER_VERSION_MAJOR (BLOCK1) WAFER_VERSION_MAJOR = 0 R/W (0b00) OPTIONAL_UNIQUE_ID (BLOCK2) Optional unique 128-bit ID = 7c c7 9b 3a 4c 1f e1 be 56 79 19 20 4f ff cd 0e R/W BLK_VERSION_MAJOR (BLOCK2) BLK_VERSION_MAJOR of BLOCK2 = With calibration R/W (0b01) WAFER_VERSION_MINOR (BLOCK0) calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI = 3 R/W (0x3) \u0026lt;\u0026lt; 3 + WAFER_VERSION_MINOR_LO (read only) Jtag fuses: SOFT_DIS_JTAG (BLOCK0) Set these bits to disable JTAG in the soft way (od = 0 R/W (0b000) d number 1 means disable ). JTAG can be enabled in HMAC module DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = True R/W (0b1) is disabled permanently Mac fuses: MAC (BLOCK1) MAC address = 84:f7:03:42:8c:a8 (OK) R/W CUSTOM_MAC (BLOCK3) Custom MAC address = 00:00:00:00:00:00 (OK) R/W Security fuses: DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = True R/W (0b1) oot_mode[3:0] is 0; 1; 2; 3; 6; 7) DIS_FORCE_DOWNLOAD (BLOCK0) Set this bit to disable the function that forces c = False R/W (0b0) hip into download mode DIS_DOWNLOAD_MANUAL_ENCRYPT (BLOCK0) Set this bit to disable flash encryption when in d = False R/W (0b0) ownload boot modes SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Enable R/W (0b001) and disables otherwise SECURE_BOOT_KEY_REVOKE0 (BLOCK0) Revoke 1st secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE1 (BLOCK0) Revoke 2nd secure boot key = False R/W (0b0) SECURE_BOOT_KEY_REVOKE2 (BLOCK0) Revoke 3rd secure boot key = False R/W (0b0) KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = XTS_AES_128_KEY R/- (0x4) KEY_PURPOSE_1 (BLOCK0) Purpose of Key1 = USER R/W (0x0) KEY_PURPOSE_2 (BLOCK0) Purpose of Key2 = USER R/W (0x0) KEY_PURPOSE_3 (BLOCK0) Purpose of Key3 = USER R/W (0x0) KEY_PURPOSE_4 (BLOCK0) Purpose of Key4 = USER R/W (0x0) KEY_PURPOSE_5 (BLOCK0) Purpose of Key5 = USER R/W (0x0) SECURE_BOOT_EN (BLOCK0) Set this bit to enable secure boot = False R/W (0b0) SECURE_BOOT_AGGRESSIVE_REVOKE (BLOCK0) Set this bit to enable revoking aggressive secure = False R/W (0b0) boot DIS_DOWNLOAD_MODE (BLOCK0) Set this bit to disable download mode (boot_mode[3 = False R/W (0b0) :0] = 0; 1; 2; 3; 6; 7) ENABLE_SECURITY_DOWNLOAD (BLOCK0) Set this bit to enable secure UART download mode = False R/W (0b0) SECURE_VERSION (BLOCK0) Secure version (used by ESP-IDF anti-rollback feat = 0 R/W (0x0000) ure) BLOCK_KEY0 (BLOCK4) Purpose: XTS_AES_128_KEY Key0 or user data = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/- BLOCK_KEY1 (BLOCK5) Purpose: USER Key1 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY2 (BLOCK6) Purpose: USER Key2 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY3 (BLOCK7) Purpose: USER Key3 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY4 (BLOCK8) Purpose: USER Key4 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W BLOCK_KEY5 (BLOCK9) Purpose: USER Key5 or user data = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 R/W Spi Pad fuses: SPI_PAD_CONFIG_CLK (BLOCK1) SPI PAD CLK = 0 R/W (0b000000) SPI_PAD_CONFIG_Q (BLOCK1) SPI PAD Q(D1) = 0 R/W (0b000000) SPI_PAD_CONFIG_D (BLOCK1) SPI PAD D(D0) = 0 R/W (0b000000) SPI_PAD_CONFIG_CS (BLOCK1) SPI PAD CS = 0 R/W (0b000000) SPI_PAD_CONFIG_HD (BLOCK1) SPI PAD HD(D3) = 0 R/W (0b000000) SPI_PAD_CONFIG_WP (BLOCK1) SPI PAD WP(D2) = 0 R/W (0b000000) SPI_PAD_CONFIG_DQS (BLOCK1) SPI PAD DQS = 0 R/W (0b000000) SPI_PAD_CONFIG_D4 (BLOCK1) SPI PAD D4 = 0 R/W (0b000000) SPI_PAD_CONFIG_D5 (BLOCK1) SPI PAD D5 = 0 R/W (0b000000) SPI_PAD_CONFIG_D6 (BLOCK1) SPI PAD D6 = 0 R/W (0b000000) SPI_PAD_CONFIG_D7 (BLOCK1) SPI PAD D7 = 0 R/W (0b000000) Usb fuses: DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = True R/W (0b1) jtag in module of usb device DIS_USB_SERIAL_JTAG (BLOCK0) USB-Serial-JTAG = Enable R/W (0b0) USB_EXCHG_PINS (BLOCK0) Set this bit to exchange USB D+ and D- pins = False R/W (0b0) DIS_USB_SERIAL_JTAG_ROM_PRINT (BLOCK0) USB printing = Enable R/W (0b0) DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE (BLOCK0) Disable UART download mode through USB-Serial-JTAG = False R/W (0b0) Vdd fuses: VDD_SPI_AS_GPIO (BLOCK0) Set this bit to vdd spi pin function as gpio = False R/W (0b0) Wdt fuses: WDT_DELAY_SEL (BLOCK0) RTC watchdog timeout threshold; in unit of slow cl = 40000 R/W (0b00) ock cycle A questo punto, dovresti identificare le seguenti differenze:\n[...] WR_DIS (BLOCK0) Disable programming of individual eFuses = 8388864 R/W (0x00800100) RD_DIS (BLOCK0) Disable reading from BlOCK4-10 = 1 R/W (0b0000001) [...] DIS_DIRECT_BOOT (BLOCK0) Disable direct boot mode = True R/W (0b1) [...] DIS_PAD_JTAG (BLOCK0) Set this bit to disable JTAG in the hard way. JTAG = True R/W (0b1) [...] DIS_DOWNLOAD_ICACHE (BLOCK0) Set this bit to disable Icache in download mode (b = True R/W (0b1)) [...] SPI_BOOT_CRYPT_CNT (BLOCK0) Enables flash encryption when 1 or 3 bits are set = Enable R/W (0b001) [...] KEY_PURPOSE_0 (BLOCK0) Purpose of Key0 = XTS_AES_128_KEY R/- (0x4) [...] BLOCK_KEY0 (BLOCK4) Purpose: XTS_AES_128_KEY Key0 or user data = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/- [...] DIS_USB_JTAG (BLOCK0) Set this bit to disable function of usb switch to = True R/W (0b1) Possiamo osservare che:\nLa cifratura della flash Ã¨ attiva (SPI_BOOT_CRYPT_CNT). Uno dei blocchi eFuse Ã¨ stato riservato per memorizzare la chiave di cifratura. Ora il vostro dispositivo ha la flash cifrata. Siccome abbiamo selezionato la modalitÃ  sviluppo, Ã¨ ancora possibile ricaricarlo tramite la porta seriale.\nConclusione # In questo Esercizio, abbiamo aggiunto la cifratura della flash al progetto abilitando le opzioni appropriate in menuconfig e adattando lâ€™offset della tabella delle partizioni come richiesto.\nProssimo passo: Conclusione\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-4-3/","section":"Workshops","summary":"","title":"ESP-IDF Avanzato - Esercizio 4.3","type":"workshops"},{"content":" Introduzione # Il build system dell\u0026rsquo;ESP-IDF Ã¨ basato su CMake e Ninja. CMake si occupa di configurare il progetto e generare i file necessari per la compilazione, mentre Ninja gestisce il processo di build vero e proprio con un sovraccarico molto ridotto rispetto al tradizionale make.\nBuild system tool chain\nPer semplificare lo sviluppo, ESP-IDF fornisce uno strumento da riga di comando chiamato idf.py. Questo tool funge da interfaccia per CMake e Ninja, gestendo sia la configurazione e la compilazione del progetto, che il flashing del firmware sul dispositivo (tramite esptool.py). idf.py offre inoltre un menu di configurazione (menuconfig) che consente di personalizzare le impostazioni del progetto, e di salvarle in un unico file chiamato sdkconfig. Gli IDE come VS Code ed Espressif IDE (Eclipse) forniscono solitamente interfacce grafiche che semplificano lâ€™uso di idf.py ma che di fatto sono dei wrapper intorno a questo tool.\nIn questo workshop utilizzeremo l\u0026rsquo;estensione ESP-IDF per VS Code.\nSviluppo modulare # Per gestire lo sviluppo di applicazioni complesse, ESP-IDF offre un sistema di componenti, accompagnato da un potente component manager.\nComponenti ESP-IDF # In ESP-IDF, molte librerie sono organizzate in componenti, ossia codice modulare e indipendente che fornisce una funzionalitÃ  specifica. Esempi di moduli gestiti come componenti sono driver o protocolli. Questa struttura semplifica il riutilizzo del codice, la sua organizzazione e la manutenzione in applicazioni complesse.\nAd esempio, la gestione di un sensore puÃ² essere effettuata da un componente dedicato, il quale incapsula tutta la logica di comunicazione e di elaborazione dei dati, evitando cosÃ¬ di riscrivere codice in ogni progetto.\nUn tipico componente include:\nCodice sorgente File header File CMakeLists.txt per la configurazione di build File idf_component.yml che descrive le dipendenze e le informazioni di versione Fig.1 - Struttura di un componente\nQuesta struttura consente di integrare e gestire facilmente i componenti nei progetti ESP-IDF, supportando lo sviluppo modulare e la condivisione del codice. Ulteriori informazioni possono essere trovato alla pagina gestione e utilizzo dei componenti.\nComponent manager # Il component manager Ã¨ uno strumento progettato per semplificare la gestione dei componenti nei progetti ESP-IDF. Questo tool consente agli sviluppatori di:\nAggiungere componenti come dipendenze dei progetti. Scaricare e aggiornare automaticamente componenti dal registro dei componenti ESP o da repository git. Gestire in modo affidabile versioni e dipendenze dei componenti. Durante la compilazione, il component manager scarica tutti i componenti necessari (incluse le rispettive dipendenze) e li colloca nella cartella managed_components. Questo approccio semplifica lâ€™estensione delle funzionalitÃ  e incoraggia il riutilizzo del codice generato dalla comunitÃ  degli sviluppatori Espressif.\nBoard Support Packages (BSP) in ESP-IDF # Un tipo particolare di componente ESP-IDF Ã¨ il Board Support Package (BSP), un componente che incapsula lâ€™inizializzazione hardware per una specifica scheda di sviluppo. I BSP forniscono driver pre-configurati e unâ€™API coerente per lâ€™accesso alle periferiche integrate come LED, pulsanti, display, pannelli touch, codec audio e schede SD. Come ogni altro componente ESP-IDF, un BSP puÃ² essere integrato in un progetto tramite il component manager, usando il comando idf.py add-dependency che modificherÃ  il idf_component.yml.\nSu un EVK base come la ESP32-C6-DevKit, il BSP semplifica la configurazione dei componenti come il pulsante e il LED indirizzabile presenti sulla scheda. Su piattaforme piÃ¹ complesse (ad es. ESP32-S3-BOX-3), il BPS include lâ€™inizializzazione periferiche come display e dispositivi audio.\nI principali vantaggi dellâ€™uso di un BSP sono:\nInizializzazione delle periferiche: i BSP gestiscono la configurazione di basso livello (GPIO, I2C, SPI, ecc.) per lâ€™hardware supportato. Astrazione riutilizzabile: i BSP espongono unâ€™API comune, consentendo il riutilizzo del codice tra progetti e varianti di schede. Avvio rapido: i BSP permettono di iniziare immediatamente lo sviluppo dell\u0026rsquo;applicazione, perchÃ© le periferiche sono giÃ  pronte all\u0026rsquo;uso. BSP personalizzati # Per schede non supportate o personalizzate, Ã¨ possibile utilizzare BSP generici (es. esp_bsp_generic, esp_bsp_devkit) e regolare le mappature hardware tramite menuconfig. Questo approccio consente ai BSP di fungere da livello di astrazione hardware flessibile, sia per hardware ufficiale che personalizzato.\nCome creare un componente # Vediamo ora come creare un componente led_toggle partendo dallâ€™esempio hello_world.\nDopo aver creato un progetto dallâ€™esempio hello_world, la struttura file del progetto sarÃ  la seguente:\n. â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ main â”‚ â”œâ”€â”€ CMakeLists.txt â”‚ â””â”€â”€ hello_world_main.c â”œâ”€â”€ pytest_hello_world.py â”œâ”€â”€ README.md â”œâ”€â”€ sdkconfig â”œâ”€â”€ sdkconfig.ci â””â”€â”€ sdkconfig.old Per creare un componente, apri la palette dei comandi e digita:\n\u0026gt; ESP-IDF: Create a new ESP-IDF Component\nâ†’ led_toggle Ora la struttura del progetto diventa:\n. â”œâ”€â”€ CMakeLists.txt â”œâ”€â”€ components # \u0026lt;--- nuova cartella â”‚ â””â”€â”€ led_toggle â”‚ â”œâ”€â”€ CMakeLists.txt â”‚ â”œâ”€â”€ include â”‚ â”‚ â””â”€â”€ led_toggle.h â”‚ â””â”€â”€ led_toggle.c â”œâ”€â”€ main â”‚ â”œâ”€â”€ CMakeLists.txt â”‚ â””â”€â”€ hello_world_main.c â”œâ”€â”€ pytest_hello_world.py â”œâ”€â”€ README.md â”œâ”€â”€ sdkconfig â”œâ”€â”€ sdkconfig.ci â””â”€â”€ sdkconfig.old Come puoi vedere, Ã¨ stata creata una nuova cartella components e al suo interno si trova il componente led_toggle.\nNella cartella componente ritroviamo\nCMakeLists.txt che contiene la configurazione utilizzata dal sistema di build Cartella include che contiene gli header (inclusi automaticamente dal linker) File .c ossia il codice effettivo del componente AffinchÃ© il build system trovi i componenti appena aggiunti, Ã¨ necessario fare un \u0026ldquo;full clean\u0026rdquo;. In VS Code, puoi eseguire\n\u0026gt; ESP-IDF: Full Clean Project. Supponiamo di avere il seguente file header del componente:\n// led_toggle.h #include \u0026#34;driver/gpio.h\u0026#34; typedef struct { int gpio_nr; bool status; }led_gpio_t; esp_err_t led_config(led_gpio_t * led_gpio); esp_err_t led_drive(led_gpio_t * led_gpio); Dopo una full clean, puoi semplicemente includerlo nel file principale e richiamarne le funzioni:\n#include \u0026#34;led_toggle.h\u0026#34; //[...] void app_main(void) { printf(\u0026#34;Hello world!\\n\u0026#34;); led_gpio_t led_board = { .gpio_nr = 5, .status = true }; led_config(led_board) led_drive(led_board) } Gestione della configurazione nei progetti ESP-IDF # I progetti ESP-IDF gestiscono la configurazione tramite due file: sdkconfig e sdkconfig.defaults.\nsdkconfig contiene la configurazione attiva del progetto. Viene generato e aggiornato automaticamente dagli strumenti di configurazione come idf.py menuconfig, registrando tutte le opzioni selezionate. sdkconfig.defaults fornisce un insieme di valori predefiniti per le opzioni di configurazione. Ãˆ utile per impostare configurazioni iniziali coerenti per nuovi build o diversi ambienti (sviluppo, test, produzione). Puoi generare un file sdkconfig.defaults che rifletta la configurazione corrente digitando il seguente comando nella palette dei comandi di VS Code\n\u0026gt; ESP-IDF: Save Default SDKCONFIG File (save-defconfig) Questo comando Ã¨ un wrapper intorno a:\nidf.py save-defconfig Il comando salva nel file sdkconfig.defaults tutti i valori di configurazione che differiscono da quelli predefiniti.\nOttimizzazione delle prestazioni # I componenti e le librerie sono spesso configurabili attraverso delle impostazioni che vengono modificate via menuconfig. Le impostazioni predefinite di ESP-IDF rappresentano un compromesso tra prestazioni, utilizzo di risorse e disponibilitÃ  di funzionalitÃ .\nPer i sistemi di produzione, gli sviluppatori possono avere obiettivi specifici di ottimizzazione (es. riduzione dellâ€™uso di memoria, aumento della velocitÃ  o riduzione del consumo energetico). Questi obiettivi si ottengono selezionando e regolando le opzioni di configurazione appropriate nel menuconfig.\nA tal fine, la documentazione ufficiale fornisce una guida allâ€™ottimizzazione delle prestazioni con strategie e suggerimenti per raggiungere gli obiettivi desiderati.\nUso di piÃ¹ file sdkconfig # ESP-IDF supporta piÃ¹ file di default (sdkconfig.xxx), che possono essere specificati tramite la variabile dâ€™ambiente SDKCONFIG_DEFAULTS o allâ€™interno del CMakeLists.txt del progetto. I file vengono elencati separati da punti e virgola e applicati in ordine: se esistono chiavi sovrapposte, i valori dei file successivi sovrascrivono quelli precedenti. Questo approccio a livelli consente di:\nMantenere impostazioni condivise in un file comune Sovrascriverle con impostazioni specifiche per ambiente o prodotto Ãˆ inoltre possibile definire default specifici per chip tramite file come sdkconfig.defaults.\u0026lt;chip\u0026gt;, ad esempio sdkconfig.defaults.esp32s3. Questi vengono considerati solo se esiste un file sdkconfig.defaults (anche vuoto). Tale meccanismo consente un controllo fine delle configurazioni per diverse varianti di chip Espressif allâ€™interno dello stesso progetto.\nGestione degli scenari di build con i profili # I file di profilo consentono di racchiudere le impostazioni di compilazione per scenari specifici (es. sviluppo, debug, produzione) in file riutilizzabili. Questi file contengono di fatto gli argomenti di riga di comando del idf.py.\nConsideriamo il caso di due compilazioni differenti per produzione e debug:\nprofiles/prod â€“ build di produzione profiles/debug â€“ build di debug Per compilare usando un profilo:\nidf.py @profiles/prod build Ãˆ anche possibile combinare file di profilo con ulteriori argomenti da riga di comando per maggiore flessibilitÃ . Questo approccio promuove coerenza e semplicitÃ  nel passaggio tra diversi ambienti di compilazione. Per maggiori dettagli, puoi fare riferimento all\u0026rsquo;ESP-IDF multi-config.\nLâ€™estensione ESP-IDF per VS Code consente di definire piÃ¹ configurazioni tramite file JSON. Ãˆ previsto che questo approccio venga unificato con quello da CLI nel prossimo futuro. Puoi consultare i dettagli nella documentazione. Esempio pratico: isolare build di sviluppo e produzione # Per mantenere configurazioni separate per sviluppo e produzione:\nCrea un file sdkconfig.defaults per lo sviluppo.\nCrea file specifici per la produzione, come sdkconfig.prod_common e sdkconfig.prod1.\nCompila con la configurazione di produzione usando:\nidf.py -B build_prod1 -D SDKCONFIG_DEFAULTS=\u0026#34;sdkconfig.prod_common;sdkconfig.prod1\u0026#34; build Questo crea una directory di build isolata (build_prod1) e applica la configurazione specificata. In questo modo puoi mantenere build riproducibili e indipendenti per diversi ambienti.\nApprofondiremo questo argomento nellâ€™esercizio 1.3.\nConclusione # Il sistema di build ESP-IDF fornisce una base versatile per lo sviluppo di applicazioni embedded. Grazie a componenti modulari, dipendenze gestite e supporto per Board Support Package (BSP) riutilizzabili, gli sviluppatori possono creare progetti scalabili e manutenibili. Strumenti come idf.py, il Component Manager e le configurazioni basate su profili semplificano sia lo sviluppo che la distribuzione di codice. Padroneggiando questi strumenti, sarai in grado di creare firmware robusti per unâ€™ampia varietÃ  di piattaforme hardware ed applicazioni.\nPassaggio successivo: Esercizio 1.1\nOppure torna al menÃ¹ di navigazione\nApprofondimenti # Cosâ€™Ã¨ lâ€™ESP Component Registry? Documentazione di IDF Component Manager ed ESP Component Registry ","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/lecture-1/","section":"Workshops","summary":"In questa lezione esploreremo il build system di ESP-IDF, che si basa su CMake e Ninja. Approfondiremo il concetto di componenti, il ruolo del Component Manager e dei Board Support Package (BSP) per lâ€™astrazione dellâ€™hardware. Infine, vedremo come creare componenti personalizzati e gestire le configurazioni attraverso i file sdkconfig e i profili di build, per ottenere compilazioni piÃ¹ flessibili e riproducibili.","title":"ESP-IDF Avanzato - Lezione 1","type":"workshops"},{"content":" Introduzione # Nei sistemi embedded puÃ² essere particolarmente complesso gestire eventi asincroni come la connettivitÃ  Wi-Fi, Bluetooth o i timer.\nL\u0026rsquo;event loop aiuta il disaccoppiamento delle parti del firwmare, permettendo ai vari componenti di definire eventi e registrare handler che rispondono quando questi eventi si verificano.\nL\u0026rsquo;event loop favorisce quindi uno stile di programmazione event-driven pulito.\nQuando Ã¨ utile un event loop # Gli event loop sono essenziali per gestire eventi asincroni in modo modulare e strutturato.\nConsideriamo un firmware che ha diverse parti: un logger, un modulo UI e un servizio di rete. In questo scenario, tutti questi moduli hanno bisogno di intraprendere un\u0026rsquo;azione quando una connessione Wi-Fi viene stabilita.\nUna possibile soluzione Ã¨ che tutti questi moduli interroghino ad intervalli regolari il componente Wi-Fi per vedere se c\u0026rsquo;Ã¨ stata una connessione. Questo approccio Ã¨ detto polling ed in questo casi Ã¨ piuttosto inefficiente.\nUn\u0026rsquo;altra soluzione Ã¨ invece che sia lo stesso componente Wi-Fi a far sapere a tutti i componenti interessati che la connessione Ã¨ avvenuta generando un evento. Per gestire questa modalitÃ , si utilizza l\u0026rsquo;event loop.\nL\u0026rsquo;event loop permette a ciascun componente di registrare un handler indipendente che viene chiamato qualora un particolare evento si verifichi.\nQuesto approccio riduce l\u0026rsquo;accoppiamento tra il componente Wi-Fi e tutti gli altri ed elimina la necessitÃ  di complesse interdipendenze tra componenti. Di conseguenza, le applicazioni diventano piÃ¹ modulari, scalabili e facili da mantenere.\nGli event loop sono particolarmente utili quando piÃ¹ componenti devono reagire allo stesso evento in modo indipendente, come nel caso dello scenario precedente.\nEventi e funzioni di callback # L\u0026rsquo;event loop ruota attorno a due concetti chiave:\nEventi Funzioni di callback Quando un evento si verifica, il modulo che l\u0026rsquo;ha generato \u0026ldquo;posta\u0026rdquo; l\u0026rsquo;evento sull\u0026rsquo;event loop. Quest\u0026rsquo;ultimo invoca poi la funzione di callback corrispondente.\nPer far funzionare questo meccanismo, Ã¨ necessario registrare sia l\u0026rsquo;evento sia la callback associata.\nDiagramma semplificato dell\u0026rsquo;event loop\nMolti eventi possono essere raggruppati logicamente, ad esempio tutti gli eventi relativi a Wi-Fi o al MQTT. Per questo motivo ciascun evento Ã¨ categorizzato utilizzando due identificatori:\nUna event base, che definisce il gruppo di cui l\u0026rsquo;evento fa parte. Un event ID, che identifica l\u0026rsquo;evento specifico all\u0026rsquo;interno di quel gruppo. Ad esempio, gli eventi relativi al Wi-Fi ricadono nella event base chiamata WIFI_EVENT. Event ID specifici all\u0026rsquo;interno di questa base includono WIFI_EVENT_STA_START e WIFI_EVENT_STA_DISCONNECTED.\nEvent loop di default # ESP-IDF crea e gestisce automaticamente un event loop di default per gli eventi di sistema, come appunto il Wi-Fi, la configurazione IP od il Bluetooth. I componenti di sistema postano eventi su questo event loop, e il codice della tua applicazione puÃ² registrare funzioni (handler) per elaborarli.\nÃˆ possibile generare event loop personalizzati ma generalmente, l\u0026rsquo;event loop di default Ã¨ sufficiente ed evita overhead aggiuntivo.\nGli sviluppatori possono infatti postare eventi della propria applicazione anche sull\u0026rsquo;event loop di default. Maggiori dettagli sulle differenze tra event loop di default e event loop utente sono disponibili nella documentazione.\nEsempi di Codice # Definire un evento # Il seguente codice mostra come definire una event base e gli event ID usando le macro di ESP-IDF:\n// In your header file (e.g., my_events.h) #include \u0026#34;esp_event.h\u0026#34; ESP_EVENT_DECLARE_BASE(MY_EVENT_BASE); typedef enum { MY_EVENT_ID_1, MY_EVENT_ID_2, MY_EVENT_ID_3, } my_event_id_t; // In your source file (e.g., my_events.c) #include \u0026#34;my_events.h\u0026#34; ESP_EVENT_DEFINE_BASE(MY_EVENT_BASE); Questo approccio utilizza ESP_EVENT_DECLARE_BASE() per dichiarare la event base in un file header e ESP_EVENT_DEFINE_BASE() per definirla in un file sorgente. Gli event ID sono tipicamente dichiarati come enum.\nQueste macro creano semplicemente variabili globali. Possiamo dare un\u0026rsquo;occhiata al loro codice per capire cosa fanno:\n// Defines for declaring and defining event base #define ESP_EVENT_DECLARE_BASE(id) extern esp_event_base_t const id #define ESP_EVENT_DEFINE_BASE(id) esp_event_base_t const id = #id Definire e registrare un event handler # Il seguente esempio mostra come definire un handler e registrarlo sull\u0026rsquo;event loop di default per un evento specifico:\n// Define the event handler void run_on_event(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { // Event handler logic } // Register the handler to the default event loop esp_event_handler_register(MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;run_on_event, NULL); Postare un evento sull\u0026rsquo;event loop di default # Se si vuole generare un evento, Ã¨ possibile farlo attraverso un post sull\u0026rsquo;event loop di default.\n// Post an event to the default event loop esp_event_post(MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;event_data, sizeof(event_data), portMAX_DELAY); Creare e utilizzare un event loop utente # In scenari piÃ¹ avanzati, potresti voler creare un event loop dedicato. Di seguito un semplice esempio.\nesp_event_loop_handle_t user_loop; esp_event_loop_args_t loop_args = { .queue_size = 5, .task_name = \u0026#34;user_event_task\u0026#34;, // Set to NULL to avoid creating a dedicated task .task_priority = uxTaskPriorityGet(NULL), .task_stack_size = 2048, .task_core_id = tskNO_AFFINITY }; // Create the user event loop esp_event_loop_create(\u0026amp;loop_args, \u0026amp;user_loop); // Register a handler with the custom event loop esp_event_handler_register_with(user_loop, MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;run_on_event, NULL); // Post an event to the custom loop esp_event_post_to(user_loop, MY_EVENT_BASE, MY_EVENT_ID, \u0026amp;event_data, sizeof(event_data), portMAX_DELAY); Conclusione # L\u0026rsquo;event loop offre un modo versatile di gestire eventi asincroni in modo pulito ed efficiente.\nProssimo passo: Esercizio 2.1\nOppure torna al menÃ¹ di navigazione\nApprofondimenti # Panoramica della libreria event loop API esp_event Esempio event loop di default Esempio event loop utente ","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/lecture-2/","section":"Workshops","summary":"In questo articolo esploriamo l\u0026rsquo;event loop. Ne esaminiamo il funzionamento, evidenziamo i vantaggi, spieghiamo come viene utilizzato all\u0026rsquo;interno di ESP-IDF.","title":"ESP-IDF Avanzato - Lezione 2","type":"workshops"},{"content":" Introduzione # In questa lezione tratteremo di due strumenti molto utili nello sviluppo embedded:\nAnalisi delle dimensioni (size analysis): Comprendere e gestire lâ€™uso della memoria della tua applicazione. Core dump: Catturare lo stato del sistema dopo un crash per un debug post-crash dettagliato. Analisi delle dimensioni # La size analysis Ã¨ il processo di stima di quanta memoria flash e RAM il firmware consuma. Questo aiuta a garantire che lâ€™applicazione rientri nelle specifiche di memoria del moduli e lasci abbastanza memoria disponibile per operazioni runtime come la gestione dei task, dei buffer e delle periferiche.\nEseguire lâ€™analisi delle dimensioni # Quando compili un progetto con ESP-IDF, il sistema di build fornisce automaticamente un riepilogo dellâ€™uso della memoria. Dopo aver eseguito:\nESP-IDF: Build Your Project Vedrai un output simile a questo:\nTotal sizes: DRAM .data size: 1234 bytes DRAM .bss size: 5678 bytes IRAM size: 9101 bytes Flash code size: 11213 bytes Flash rodata size: 1415 bytes Questa suddivisione dÃ  indicazioni su dove lâ€™applicazione sta consumando risorse. Per un\u0026rsquo;analisi piÃ¹ dettagliata, l\u0026rsquo;ESP-IDF offre comandi aggiuntivi:\nidf.py size: Fornisce un riepilogo della memoria allocata staticamente. idf.py size-components: Mostra lâ€™uso della memoria per componente. idf.py size-files: Suddivide lâ€™uso per file sorgente. idf.py size-symbols: Elenca lâ€™uso della memoria a livello di simbolo (utile per individuare funzioni o variabili pesanti). Questi strumenti aiutano a identificare i punti critici dell\u0026rsquo;uso della memoria e guidano lâ€™ottimizzazione del codice.\nUna volta conosciuto com\u0026rsquo;Ã¨ utilizzata la memoria dal tuo firmware, puoi iniziare ad agire sia la configurazione che sul codice per diminuirne il consumo. Dopo le modifiche, ripeti la size analysis per valutarne l\u0026rsquo;impatto.\nCore dump # Un core dump Ã¨ uno snapshot della memoria del dispositivo e dello stato del processore al momento del crash. Include:\nStack di chiamate di tutti i task Contenuto dei registri CPU Regioni di memoria rilevanti Questi dati permettono agli sviluppatori di analizzare cosa Ã¨ andato storto, anche dopo il reset del dispositivo. Questo rende i core dump uno strumento prezioso per diagnosticare bug difficili da riprodurre.\nAbilitare e usare i core dump # Per abilitare i core dump su un dispositivo Espressif con ESP-IDF, devi:\nAbilitare il core dump in menuconfig\nGenerare e analizzare il Core Dump Quando si verifica un crash, il chip Espressif salva il core dump sulla flash o lo mostra su UART. Puoi analizzarlo usando:\nidf.py coredump-info Questi comandi decodificano il core dump e presentano un backtrace leggibile, lo stato delle variabili e dei registri. Questo rende piÃ¹ semplice identificare la causa del fallimento.\nI core dump sono uno strumento prezioso da usare insieme al debug.\nConclusione # Padroneggiare l\u0026rsquo;analisi delle dimensioni e i core dump Ã¨ estremamente utile per gli sviluppatori embedded. Lâ€™analisi delle dimensioni aiuta a garantire che lâ€™applicazione rimanga nei limiti delle risorse e funzioni in modo efficiente, mentre i core dump forniscono un potente meccanismo per la diagnostica post-crash.\nIntegrando questi strumenti nel tuo flusso di sviluppo, sarÃ  piÃ¹ semplice costruire applicazioni robuste e ad alte prestazioni.\nPasso successivo: Esercizio 3.1\nOppure torna al menÃ¹ di navigazione\nApprofondimenti # Guida ESP-IDF Core Dump ","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/lecture-3/","section":"Workshops","summary":"In questo articolo trattiamo lâ€™analisi delle dimensioni e i core dump. Scoprirai cosa fanno, perchÃ© sono importanti e come usarli per costruire applicazioni piÃ¹ efficienti e affidabili.","title":"ESP-IDF Avanzato - Lezione 3","type":"workshops"},{"content":" Introduzione # Con la crescente diffusione dei dispositivi IoT nelle abitazioni, i sistemi connessi gestiscono sempre piÃ¹ spesso dati personali, controllano processi fisici e operano in ambienti non affidabili, rendendoli obiettivi interessanti per gli hacker.\nIn risposta a questi rischi, nuove normative come il Radio Equipment Directive Delegated Act (RED DA) dellâ€™UE stanno alzando gli standard di sicurezza per lâ€™IoT, richiedendo ai produttori di implementare protezioni piÃ¹ solide giÃ  in fase di progettazione.\nPer soddisfare queste esigenze, tre tecnologie sono diventate la base della sicurezza moderna per lâ€™IoT: aggiornamenti over-the-air (OTA), cifratura della flash e bootloader sicuro.\nAggiornamenti OTA: consentono ai dispositivi di ricevere aggiornamenti firmware da remoto, permettendo patch di sicurezza e miglioramenti delle funzionalitÃ  senza necessitÃ  di accesso fisico. Questo Ã¨ cruciale per mantenere lâ€™integritÃ  del dispositivo durante tutto il suo ciclo di vita, soprattutto una volta che i prodotti sono distribuiti sul campo.\nCifratura della flash: protegge i dati memorizzati nella memoria flash del dispositivo. Questo garantisce che le informazioni sensibili (come chiavi crittografiche o dati degli utenti) rimangano inaccessibili anche se un attaccante ottiene lâ€™accesso fisico al dispositivo.\nBootloader sicuro: verifica lâ€™integritÃ  e lâ€™autenticitÃ  del firmware prima dellâ€™esecuzione. Controllando le firme digitali durante il processo di avvio, il secure bootloader impedisce lâ€™esecuzione di codice non autorizzato o dannoso.\nNei seguenti esercizi, abiliterete queste funzionalitÃ  direttamente sul EVK. Se non vi sentite sicuri, potete seguire lâ€™articolo del developer portal sull\u0026rsquo;emulazione delle funzionalitÃ  di sicurezza usando QEMU. Queste tre funzionalitÃ  costituiscono uno strato di sicurezza fondamentale, aiutando gli sviluppatori a realizzare dispositivi conformi alle nuove normative.\nNel seguito, vedremo ciascuna di queste funzionalitÃ  separatamente. Per usare lâ€™OTA, bisogna prima modificare la tabella delle partizioni. Per questo motivo, prima di iniziare, dobbiamo dedicare qualche parola alle tabelle delle partizioni.\nTabelle delle partizioni # La tabella delle partizioni definisce come la memoria flash Ã¨ organizzata, specificando a che indirizzi sono memorizzate applicazioni, dati, filesystem e altre risorse. Questa separazione logica permette agli sviluppatori di gestire firmware, dati persistenti e meccanismi di aggiornamento in modo efficiente.\nESP-IDF utilizza la tabella delle partizioni perchÃ© consente:\nSeparazione di codice e dati: Applicazioni e dati persistenti sono isolati, permettendo aggiornamenti firmware senza cancellare i dati dellâ€™utente. Aggiornamenti OTA: Supporto di piÃ¹ partizioni applicative e gestione dei dati OTA per aggiornamenti firmware remoti. Storage flessibile: Supporto di filesystem e di regioni personalizzate per certificati, log o configurazioni. Struttura e posizione # La tabella delle partizioni Ã¨ tipicamente caricata allâ€™offset 0x8000 nella flash del dispositivo e occupa 0xC00 byte, supportando fino a 95 voci e includendo un checksum MD5 per la verifica dellâ€™integritÃ  dei dati caricati. La tabella stessa occupa un intero settore flash da 4 KB, quindi qualsiasi partizione successiva deve iniziare almeno allâ€™offset 0x9000. Ogni voce della tabella include un nome (label), un tipo (come app o data), un sottotipo, un offset e la dimensione nella memoria flash.\nSchemi di partizioni predefiniti # ESP-IDF fornisce diverse tabelle delle partizioni predefinite, selezionabili tramite menuconfig:\nSingle factory app, no OTA: Contiene una singola partizione per l\u0026rsquo;applicazione e partizioni dati di base (NVS, PHY init). Factory app, two OTA definitions: Aggiunge il supporto agli aggiornamenti over-the-air (OTA), con due partizioni app OTA e uno slot dati OTA. Useremo questa tabella delle partizioni predefinita nellâ€™esercizio 4.1 Ad esempio, lo schema \u0026ldquo;Factory app, two OTA definitions\u0026rdquo; appare cosÃ¬:\nName Type SubType Offset Size nvs data nvs 0x9000 0x4000 otadata data ota 0xd000 0x2000 phy_init data phy 0xf000 0x1000 factory app factory 0x10000 1M ota_0 app ota_0 0x110000 1M ota_1 app ota_1 0x210000 1M Il bootloader utilizza la tabella delle partizioni per individuare lâ€™applicazione da avviare e le aree dati per NVS, calibrazione PHY e gestione OTA.\nTabella delle partizioni personalizzata # Per applicazioni avanzate, gli sviluppatori possono definire tabelle delle partizioni personalizzate in formato CSV. Questo permette di aggiungere partizioni extra, come spazio NVS aggiuntivo oppure un filesystem (SPIFFS o FAT). Il CSV personalizzato Ã¨ specificato nella configurazione del progetto e gli strumenti ESP-IDF lo trasformano in tabella di partizione e lo utilizzano di conseguenza.\nNel caso si usi una tabella delle partizioni personalizzata, conviene aumentare la dimensione delle partizioni OTA al massimo spazio disponibile, una volte note le dimensioni delle altre partizioni: in questo modo si avrÃ  piÃ¹ spazio disponibile per gli aggiornamenti OTA futuri. Testeremo questa opzione nellâ€™esercizio 4.2.\nAggiornamenti Over-the-Air (OTA) sui dispositivi Espressif # Gli aggiornamenti Over-the-Air (OTA) consentono di aggiornare il firmware dei dispositivi embedded da remoto senza necessitÃ  di accesso fisico. Questa capacitÃ  Ã¨ particolarmente importante nelle implementazioni IoT, dove i dispositivi sono spesso presenti su aree ampie, possibilmente difficili da raggiungere. Lâ€™OTA assicura che i dispositivi rimangano aggiornati con le ultime funzionalitÃ , correzioni dei bug e patch di sicurezza anche dopo la vendita.\nDurante il processo OTA, il dispositivo Espressif scarica il firmware da una posizione specificata, come illustrato in Fig.1.\nFig.1 \u0026ndash; Diagramma base OTA\nI principali vantaggi dellâ€™OTA includono:\nManutenzione remota:: Aggiornare il firmware senza interventi in loco. Sicurezza migliorata:: Correggere rapidamente vulnerabilitÃ  note. Aggiornamenti delle funzionalitÃ :: Fornire nuove funzionalitÃ  senza interruzioni agli utenti. Costi di manutenzione ridotti:: Evitare costosi richiami o interventi manuali. Implementazione OTA con ESP-IDF # ESP-IDF offre supporto integrato per OTA tramite due metodi principali:\nAPI nativa: Utilizzando il componente app_update per il controllo completo del processo di aggiornamento. API semplificata: Utilizzando il componente esp_https_ota per unâ€™interfaccia di alto livello che gestisce automaticamente download HTTPS e caricamento del firmware scaricato. Nella maggior parte dei casi, lâ€™applicazione deve interagire solo con lâ€™interfaccia pubblica dei componenti esp_https_ota e app_update. In Fig.2 Ã¨ possibile vedere un diagramma semplificato dei componenti del processo OTA.\nFig.2 \u0026ndash; Componenti chiave OTA (diagramma semplificato)\nUn tipico processo OTA include:\nScaricare la nuova immagine firmware via Wi-Fi o Ethernet. Scrivere la nuova immagine in una partizione OTA non utilizzata nella flash. Aggiornare la partizione dati OTA (otadata) per impostare il nuovo firmware come versione attiva. Riavviare il dispositivo per applicare lâ€™aggiornamento. Per usare OTA, Ã¨ necessario aggiungere una tabella delle partizioni appropriata. Esempio di codice con esp_https_ota # Lâ€™utilizzo di esp_https_ota Ã¨ semplice e richiede generalmente poche righe di codice.\n#include \u0026#34;esp_https_ota.h\u0026#34; esp_err_t do_firmware_upgrade() { esp_http_client_config_t config = { .url = \u0026#34;https://example.com/firmware.bin\u0026#34;, .cert_pem = (char *)server_cert_pem_start, }; esp_https_ota_config_t ota_config = { .http_config = \u0026amp;config, }; esp_err_t ret = esp_https_ota(\u0026amp;ota_config); if (ret == ESP_OK) { esp_restart(); } else { return ESP_FAIL; } return ESP_OK; } Questo codice scarica una nuova immagine firmware e, se lâ€™operazione ha successo, riavvia il dispositivo per avviare il nuovo firmware. Per un utilizzo piÃ¹ avanzato, consultare la documentazione ESP-IDF OTA.\nLayout della tabella delle partizioni OTA # Lâ€™OTA richiede un layout specifico della tabella delle partizioni. Questa deve avere almeno le seguenti partizioni:\nPartizione NVS: Per lo storage non volatile. Partizione otadata: Per tracciare quale partizione firmware Ã¨ attiva. Due partizioni app OTA: Per immagini firmware attive/passive. Un esempio di tabella delle partizioni valida Ã¨ il seguente:\nName, Type, SubType, Offset, Size, Flags nvs, data, nvs, , 0x6000, otadata, data, ota, , 0x2000, phy_init, data, phy, , 0x1000, ota_0, app, ota_0, , 1M, ota_1, app, ota_1, , 1M, Questo layout garantisce aggiornamenti sicuri: il nuovo firmware viene scritto nella partizione inattiva e solo dopo la verifica di integritÃ  viene contrassegnato come attivo per il successivo avvio. La partizione otadata occupa due settori flash (0x2000 byte) per prevenire corruzioni in caso di interruzione di corrente durante lâ€™aggiornamento.\nOltre ai campi giÃ  menzionati (data,nvs), questa tabella contiene un campo otadata (con tipologia data,ota) che gioca un ruolo fondamentale negli aggiornamenti OTA.\nPartizione otadata # La partizione otadata Ã¨ una partizione speciale nella tabella delle partizioni, necessaria per progetti che utilizzano aggiornamenti firmware Over-The-Air (OTA). La sua funzione principale Ã¨ memorizzare le informazioni su quale slot OTA (come ota_0 o ota_1) deve essere avviato dal dispositivo. La sua dimensione tipica Ã¨ 0x2000 byte (due settori flash).\nLâ€™uso della partizione otadata Ã¨ il seguente:\nAl primo avvio (o dopo un erase), la partizione otadata Ã¨ vuota (tutti i byte impostati a 0xFF). In questo stato, il bootloader avvia il firmware nella partizione app_factory se presente, oppure il primo slot OTA se non lo Ã¨. Dopo un aggiornamento OTA riuscito, la partizione otadata viene aggiornata per indicare quale slot OTA avviare al prossimo riavvio. La partizione Ã¨ progettata per essere robusta contro interruzioni di corrente: utilizza due settori e un campo contatore per determinare lâ€™ultimo dato valido se i settori non sono coerenti. Cifratura della Flash # La cifratura della flash Ã¨ una funzionalitÃ  di sicurezza fondamentale, progettata per proteggere il contenuto della memoria flash. Quando abilitata, tutti i dati memorizzati nella flash vengono cifrati, rendendo estremamente difficile per soggetti non autorizzati estrarre informazioni sensibili, anche nel caso di accesso fisico al dispositivo.\nFunzionamento della cifratura della Flash # Al primo avvio, il firmware viene caricato in chiaro e poi cifrato in loco. Il processo di cifratura utilizza algoritmi come XTS-AES-128, XTS-AES-256 o AES-256, a seconda della serie del SoC Espressif. La chiave crittografica Ã¨ memorizzata in modo sicuro nei blocchi eFuse del chip e non Ã¨ accessibile via software, garantendo una protezione robusta delle chiavi.\nLâ€™accesso alla flash Ã¨ trasparente: qualsiasi regione mappata in memoria viene automaticamente decrittata in lettura e cifrata in scrittura, senza necessitÃ  di modificare il codice applicativo.\nL\u0026rsquo;impostazione predefinita prevede che le partizioni critiche come bootloader, tabella partizioni, partizione chiavi NVS, otadata e tutte le partizioni applicative siano cifrate. Altre partizioni possono essere selettivamente cifrandole segnalandole con il flag encrypted nella tabella partizioni.\nModalitÃ  development e release # La cifratura della flash puÃ² essere abilitata in modalitÃ  \u0026ldquo;Development\u0026rdquo; o \u0026ldquo;Release\u0026rdquo;.\nIn modalitÃ  development, Ã¨ possibile ricaricare firmware in chiaro per test, ma non Ã¨ sicuro per la produzione. In modalitÃ  release, non Ã¨ possibile ricaricare il firmware in chiaro. Ãˆ fortemente consigliato usare la modalitÃ  release per dispositivi in produzione per prevenire lâ€™estrazione o la modifica non autorizzata del firmware.\nNote importanti # Non interrompere lâ€™alimentazione durante il passaggio di cifratura iniziale al primo avvio, poichÃ© potrebbe corrompere la flash e richiedere di caricare nuovamente il firmware. Abilitare la cifratura flash aumenta la dimensione del bootloader, il che puÃ² richiedere un aggiornamento dellâ€™offset della tabella delle partizioni. Lo vedremo in dettaglio nellâ€™esercizio 4.3 Bootloader sicuro # I dispositivi Espressif offrono una funzionalitÃ  chiamata secure boot. Questo meccanismo costituisce la base della sicurezza del dispositivo, proteggendolo dallâ€™esecuzione di codice non autorizzato e dalla manomissione del firmware.\nUn bootloader sicuro Ã¨ un programma speciale che verifica lâ€™autenticitÃ  e lâ€™integritÃ  del firmware prima di consentirne lâ€™esecuzione sul dispositivo. Questo avviene controllando le firme crittografiche associate al bootloader e alle immagini applicative. Se una parte del codice Ã¨ stata modificata o non Ã¨ firmata da una chiave affidabile, il dispositivo rifiuta di eseguirla.\nQuesto processo stabilisce una catena di certificazione (chain of trust):\nIl bootloader hardware (in ROM) verifica il bootloader software. Il bootloader software verifica poi il firmware applicativo. Questo garantisce che solo il codice firmato dal produttore del dispositivo (o da unâ€™altra entitÃ  fidata) possa essere eseguito, proteggendo da malware, aggiornamenti non autorizzati e manomissioni fisiche della memoria flash del dispositivo. La chiave privata della firma Ã¨ mantenuta segreta, mentre la chiave pubblica Ã¨ memorizzata in modo sicuro nella memoria eFUSE del dispositivo, rendendolo inaccessibile a software e attaccanti esterni.\nCome Usare il bootloader sicuro # Abilitare il bootloader sicuro sui dispositivi Espressif comporta i seguenti passaggi:\nAbilitare il secure boot nella configurazione:\nUsare menuconfig per abilitare il secure boot sotto \u0026ldquo;Security Features\u0026rdquo;. Generare o specificare una chiave per la firma:\nSe non esiste una chiave per firmare il firmware, generarne una usando il comando fornito (es. idf.py secure-generate-signing-key). In produzione, generare le chiavi con strumenti affidabili come OpenSSL. Compilare e caricare il bootloader:\nCompilare il bootloader con secure boot abilitato:\nidf.py bootloader Caricare manualmente il bootloader usando il comando mostrato dal processo di build.\nCompilare e caricare lâ€™applicazione:\nCompilare e caricare lâ€™applicazione e la tabella delle partizioni:\nidf.py flash Lâ€™immagine dellâ€™applicazione sarÃ  firmata automaticamente usando la chiave specificata.\nVerificare lâ€™attivazione del secure boot:\nAl primo avvio, il dispositivo abiliterÃ  il secure boot, brucerÃ  gli eFUSE necessari e verificherÃ  le firme. Puoi monitorare lâ€™output seriale per confermare lâ€™attivazione riuscita. Una volta abilitato il secure boot, il bootloader non puÃ² essere ricaricato (a meno di usare una modalitÃ  speciale \u0026ldquo;reflashable\u0026rdquo;, non consigliata per la produzione). Conservare sempre al sicuro la chiave privata, poichÃ© la sua compromissione invalida lâ€™intero processo di secure boot Conclusione # In questo articolo, abbiamo esplorato tre pilastri fondamentali della sicurezza moderna per lâ€™IoT: aggiornamenti OTA, cifratura della flash e bootloader sicuri. Insieme, queste funzionalitÃ  assicurano che i dispositivi possano essere aggiornati in modo sicuro, proteggere i dati sensibili a riposo e verificare lâ€™integritÃ  del firmware a partire dal momento dellâ€™accensione.\nNei prossimi esercizi, testerete queste funzionalitÃ  in prima persona.\nProssimo passo: esercizio 4.1\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/lecture-4/","section":"Workshops","summary":"In questo articolo esploriamo le funzionalitÃ  di sicurezza: aggiornamento OTA, cifratura della flash e bootloader sicuro","title":"ESP-IDF Avanzato - Lezione 4","type":"workshops"},{"content":" Obiettivi dell\u0026rsquo;esercizio # Creazione di un nuovo progetto a partire dall\u0026rsquo;esempio blink Modifica del GPIO di uscita di default via menuconfig Lampeggio del LED della scheda Traccia della soluzione # In questo esercizio creerai un nuovo progetto partendo da un altro esempio della cartella get_started â†’ blink.\nNellâ€™esempio blink, Ã¨ necessario specificare il GPIO a cui Ã¨ collegato il LED. Il valore predefinito Ã¨ GPIO8, ma sulla tua scheda Ã¨ diverso. Dovrai modificare questo valore di configurazione tramite menuconfig.\nCrea il progetto dallâ€™esempio come fatto nellâ€™esercizio precedente.\nModifica il numero del GPIO dellâ€™esempio tramite menuconfig:\nTrova il GPIO a cui Ã¨ collegato il LED sulla tua scheda. \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) â†’ Example Configuration â†’ Blink GPIO number Compila, programma e monitora lâ€™esempio.\nVerifica che il LED lampeggi. La porta di uscita Ã¨ corretta? Consulta lo schema della scheda per verificarlo.\nFig.1 - Vista superiore della scheda\nAttivitÃ  opzionale # (Bonus) Rinomina il file principale in hello_led_main.c e la cartella del progetto in hello_led. Hai riscontrato errori?\nDove si trova il problema? Soluzione Il linker non sa di dover compilare anche il file hello_led_main.c. Ãˆ necessario cambiare il file CMakefile.txt che contiene le informazioni dei file da includere.\nAffronteremo l\u0026rsquo;argomento del build system nel workshop ESP-IDF avanzato. Per il momento, la soluzione consiste nel cambiare l\u0026rsquo;istruzione idf_component_register in CMakelists.txt.\nidf_component_register(SRCS \u0026#34;hello_led_main.c\u0026#34; INCLUDE_DIRS \u0026#34;.\u0026#34;) Conclusione # Ora hai una buona comprensione del processo di creazione, compilazione e caricamento sulla memoria di un progetto ESP-IDF. Nella prossima lezione, ci concentreremo su quello che solitamente Ã¨ il tema principale di unâ€™applicazione Espressif â€” la connettivitÃ .\nProssimo passo # Prossima lezione â†’ Lezione 2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-1-2/","section":"Workshops","summary":"Creare un nuovo progetto basato sull\u0026rsquo;esempio \u003ccode\u003eblink\u003c/code\u003e e far lampeggiare il led sulla scheda.","title":"ESP-IDF Base - Esercizio 1.2","type":"workshops"},{"content":" Passi dell\u0026rsquo;esercizio # Creare un nuovo progetto da template Avviare un soft-AP Avviare un server HTTP Connettersi al soft-AP con uno smartphone Creare un nuovo progetto a partire da template # Negli ultimi esercizi, abbiamo creato un progetto a partire da un esempio. Questa volta creeremo invece un progetto a partire da un template vuoto.\nApri VS Code \u0026gt; ESP-IDF: Create Project from Extension Template Nel menÃ¹ a tendina che appare â†’ Choose a container directory Scegli una cartella nella quale verrÃ  creata la cartella del progetto Nel menÃ¹ a tendina che appare â†’ template-app Scegli il target (esp32c3) e seleziona la porta, come fatto negli esercizi precedenti. Nella cartella che hai selezionato, sono ora presenti i seguenti file di progetto\n. |-- CMakeLists.txt |-- README.md `-- main |-- CMakeLists.txt `-- main.c Come vedi, la struttura Ã¨ molto piÃ¹ semplice che nel caso dell\u0026rsquo;esempio blink o hello_world.\nAvviare un soft-AP # Per mantenere l\u0026rsquo;esercizio il piÃ¹ semplice possibile, in questo tutorial le credenziali dellâ€™access point (AP) saranno definite nel codice. Non useremo quindi la memoria non volatile (NVS), che viene invece normalmente utilizzata nelle applicazioni Wi-Fi per memorizzare credenziali e dati di calibrazione.\nNVS Ã¨ abilitata per impostazione predefinita. Per evitare avvisi ed errori, dobbiamo disabilitarla tramite menuconfig.\nDisabilitare NVS # Per disabilitare NVS, accediamo a menuconfig e cerchiamo lâ€™opzione NVS:\n\u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) â†’ NVS Togli la selezione a PHY e Wi-Fi, come indicato in Fig.1. Fig. 1 - Opzioni NVS da disabilitare\nClicca su Save Chiudi il tab di menuconfig Definire i parametri del soft-AP # Spostiamoci ora sul file main/main.c.\nImposteremo i parametri necessari per il soft-AP come define all\u0026rsquo;inizio del sorgente:\n#define ESP_WIFI_SSID \u0026#34;\u0026lt;NOMEUTENTE_esp_test\u0026gt;\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 Per evitare sovrapposizioni con gli altri partecipanti, crea un nome unico per l\u0026rsquo;SSID.\nQuesto non Ã¨ il metodo raccomandato per memorizzare le credenziali. Ãˆ preferibile conservarle in modo sicuro in NVS o gestirle tramite configurazione usando menuconfig. Inizializzare lo stack IP e lâ€™Event Loop # Il componente Wi-Fi di Espressif si basa su un event loop per gestire eventi asincroni. Per avviare il soft-AP, dobbiamo:\nIncludere esp_wifi.h, string.h ed esp_log.h Inizializzare lo stack IP (esp_netif_init e esp_netif_create_default_wifi_ap) Avviare il loop degli eventi predefinito Creare e registrare una funzione di gestione eventi. Per mantenere il codice ordinato, racchiuderemo tutto nella funzione wifi_init_softap:\n#include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; // ... void wifi_init_softap() { esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // sempre iniziare da qui esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap completata. SSID:%s password:%s canale:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } Registrare le funzioni di gestione degli eventi per il soft-AP # Crea una funzione per gestire gli eventi Wi-Fi\nSiccome Ã¨ usata da wifi_init_softap, questa funzione va definita prima static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Evento nÂ°: %ld!\\n\u0026#34;, event_id); } Chiama la funzione wifi_init_softap() all\u0026rsquo;interno di app_main()\nvoid app_main(void) { wifi_init_softap(); } \u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Dovresti vedere comparire diversi numeri evento nel terminale.\n[...] I (576) wifi:Init max length of beacon: 752/752 Evento nÂ°: 43! I (576) esp_netif_lwip: DHCP server started on interface WIFI_AP_DEF with IP: 192.168.4.1 Evento nÂ°: 12! I (586) main: wifi_init_softap completata. SSID:TEST_WORKSHOP password:test_esp canale:1 I (596) main_task: Returned from app_main() Connettersi al soft-AP con uno smartphone # Prendi il tuo smartphone, apri la lista delle reti Wi-Fi e seleziona lâ€™SSID che hai creato all\u0026rsquo;inizio (Fig. 2).\nFig. 2 - Elenco degli Access Point\nNel terminale dovrebbe comparire Evento nÂ°: 14!, che corrisponde a WIFI_EVENT_AP_STACONNECTED.\nI (7146) wifi:new:\u0026lt;1,0\u0026gt;, old:\u0026lt;1,1\u0026gt;, ap:\u0026lt;1,1\u0026gt;, sta:\u0026lt;255,255\u0026gt;, prof:1, snd_ch_cfg:0x0 I (7146) wifi:station: ba:fa:31:4c:4f:3a join, AID=1, bgn, 20 Evento nÂ°: 43! Evento nÂ°: 14! Per verificare la corrispondenza tra numero e codice, puoi fare riferimento al codice su GitHub. Ricorda che i valori delle enum partono da 0.\nI codici che vedi, indicato che una stazione (cioÃ¨ il tuo smartphone) si Ã¨ connessa al soft-AP (cioÃ¨ al modulo Espressif).\nAvviare un server HTTP # La libreria HTTP server dell\u0026rsquo;ESP-IDF si chiama esp_http_server. Per utilizzarla, Ã¨ necessario includerla e configurare il server.\nIncludere la libreria # Includi lâ€™header esp_http_server.h:\n#include \u0026#34;esp_http_server.h\u0026#34; Configurare il server HTTP # Creiamo una funzione per lâ€™inizializzazione del server:\nhttpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server avviato con successo, registrazione degli handler URI...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Impossibile avviare il server\u0026#34;); return NULL; } Nella funzione app_main, avviamo il server:\nhttpd_handle_t server = start_webserver(); Gestione delle URI HTTP # Quando un utente visita la route /, vogliamo restituire una semplice pagina HTML.\nRegistriamo la route con httpd_register_uri_handler:\nhttpd_register_uri_handler(server,\u0026amp;hello_world_uri); Indichiamo la struttura httpd_uri_t che definisce le proprietÃ  della route:\nstatic const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, .method = HTTP_GET, .handler = hello_get_handler, .user_ctx = NULL }; Specifichiamo la funzione handler che restituisce la pagina HTML\nstatic esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } Anche in questo caso, l\u0026rsquo;ordine in cui dovrai scrivere le funzioni Ã¨ inverso, ossia prima la hello_get_handler e ultima la httpd_register_uri_handler. In alternativa, puoi definire la firma di queste funzioni in cima al file main.c. Connessione al server # Il modulo Espressif fa da AP e ha un suo indirizzo, solitamente 192.168.4.1. Vogliamo ora collegarci a questo indirizzo (e alla sua route /) per vedere la pagina HTML che abbiamo creato nella funzione httpd_resp_send.\nVerifica l\u0026rsquo;indirizzo dell\u0026rsquo;AP. Puoi farlo cercando nel terminale, la riga seguente:\nI (766) esp_netif_lwip: DHCP server started on interface WIFI_AP_DEF with IP: 192.168.4.1 Apri il browser sul dispositivo connesso e inserisci lâ€™indirizzo IP trovato al punto precedente.\nDovresti vedere la pagina HTML mostrata in Fig.3, generata dalla funzione hello_get_handler.\nFig.3 â€“ Pagina HTML visualizzata\nCodice dellâ€™esercizio # Mostra soluzione #include \u0026lt;stdio.h\u0026gt; #define ESP_WIFI_SSID \u0026#34;TEST_WORKSHOP\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_http_server.h\u0026#34; static const char* TAG = \u0026#34;main\u0026#34;; static esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, .method = HTTP_GET, .handler = hello_get_handler, .user_ctx = NULL }; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Evento nÂ°: %ld!\\n\u0026#34;, event_id); } void wifi_init_softap(){ esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // sempre iniziare da qui esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap completata. SSID:%s password:%s canale:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } httpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server avviato con successo, registrazione degli handler URI...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Impossibile avviare il server\u0026#34;); return NULL; } void app_main(void) { wifi_init_softap(); httpd_handle_t server = start_webserver(); httpd_register_uri_handler(server,\u0026amp;hello_world_uri); } Conclusione # Ora sei in grado di configurare un dispositivo Espressif in modalitÃ  Soft-AP o STA e creare un server HTTP in grado di restituire contenuti HTML.\nAllo stesso modo puoi anche restituire risposte JSON per una REST API, come vedremo negli esercizi successivi.\nPassaggio successivo # Prossimo esercizio: Esercizio 2.2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-2-1/","section":"Workshops","summary":"Far partire una soft-AP e un server HTTP (guidato).","title":"ESP-IDF Base - Esercizio 2.1","type":"workshops"},{"content":"Il secondo esercizio consiste nellâ€™aggiungere le seguenti route al server HTTP che abbiamo creato nell\u0026rsquo;esercizio precedente:\nGET /led/on â†’ accende il LED e restituisce JSON {\u0026ldquo;led\u0026rdquo;: \u0026ldquo;on\u0026rdquo;} GET /led/off â†’ spegne il LED e restituisce JSON {\u0026ldquo;led\u0026rdquo;: \u0026ldquo;off\u0026rdquo;} Traccia della soluzione # Per controllare il led, puoi usare il codice dell\u0026rsquo;esercizio 1.2, riportato qui per convenienza.\nIncludi l\u0026rsquo;header opportuno:\n#include \u0026#34;driver/gpio.h\u0026#34; Specifica il pin da usare (a seconda della scheda che stai usando)\n#define OUTPUT_LED GPIO_NUM_7 Crea una funzione di configurazione (da chiamare dalla funzione app_main)\nstatic void configure_led(void) { ESP_LOGI(TAG, \u0026#34;LED Configured!\\n\u0026#34;); gpio_reset_pin(OUTPUT_LED); /* Set the GPIO as push/pull output */ gpio_set_direction(OUTPUT_LED, GPIO_MODE_OUTPUT); } Crea la funzione per pilotare il led:\nstatic void led_control(int level){ gpio_set_level(OUTPUT_LED, level); } Codice della soluzione # Mostra codice soluzione #include \u0026lt;stdio.h\u0026gt; #define ESP_WIFI_SSID \u0026#34;TEST_WORKSHOP\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_http_server.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #define OUTPUT_LED GPIO_NUM_7 static const char* TAG = \u0026#34;main\u0026#34;; static void configure_led(void) { ESP_LOGI(TAG, \u0026#34;LED Configurato!\\n\u0026#34;); gpio_reset_pin(OUTPUT_LED); /* Imposta il GPIO come output push/pull */ gpio_set_direction(OUTPUT_LED, GPIO_MODE_OUTPUT); } static void led_control(int level){ gpio_set_level(OUTPUT_LED, level); } static esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* Handler definitions */ static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Evento nÂ°: %ld!\\n\u0026#34;, event_id); } static esp_err_t led_on_handler(httpd_req_t *req) { led_control(1); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;on\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static esp_err_t led_off_handler(httpd_req_t *req) { led_control(0); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;off\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* URI definitions */ static const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, .method = HTTP_GET, .handler = hello_get_handler, .user_ctx = NULL }; static const httpd_uri_t led_on_uri = { .uri = \u0026#34;/led/on\u0026#34;, .method = HTTP_GET, .handler = led_on_handler, .user_ctx = NULL }; static const httpd_uri_t led_off_uri = { .uri = \u0026#34;/led/off\u0026#34;, .method = HTTP_GET, .handler = led_off_handler, .user_ctx = NULL }; void wifi_init_softap(){ esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // sempre iniziare da qui esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap completata. SSID:%s password:%s canale:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } httpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server avviato con successo, registrazione degli handler URI...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Impossibile avviare il server\u0026#34;); return NULL; } void app_main(void) { wifi_init_softap(); configure_led(); httpd_handle_t server = start_webserver(); /* Registrazione URI/Handler */ httpd_register_uri_handler(server,\u0026amp;hello_world_uri); httpd_register_uri_handler(server, \u0026amp;led_on_uri); httpd_register_uri_handler(server, \u0026amp;led_off_uri); } Conclusione # Ora abbiamo una chiara panoramica di come collegare le richieste ricevute tramite REST API al controllo fisico del dispositivo. Nellâ€™ultimo esercizio del workshop (il 3.3) lavorerai su unâ€™applicazione simile ma piÃ¹ complessa.\nProssimo passo # Se hai ancora tempo, puoi provare il prossimo esercizio opzionale.\nProssimo esercizio (opzionale) â†’ Esercizio 2.3\nAltrimenti, puoi passare alla terza lezione.\nProssima lezione â†’ Lezione 3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-2-2/","section":"Workshops","summary":"Aggiungere ulteriori route al server HTTP per controllare il led da remoto","title":"ESP-IDF Base - Esercizio 2.2","type":"workshops"},{"content":"Questo esercizio Ã¨ opzionale e dovrebbe essere svolto solo se resta del tempo prima della pausa.\nAggiungi unâ€™altra route al server HTTP degli esercizi precedenti:\nPOST /led/flash â†’ accetta un JSON {\u0026quot;periods\u0026quot;: [int], \u0026quot;duty_cycles\u0026quot;: [int]} e, per ogni elemento, calcola il tempo acceso (on-time) e il tempo spento (off-time) del LED e lo controlla di conseguenza. Per testare un POST, hai bisogno di un\u0026rsquo;app che ti permetta di inviare richieste in maniera strutturata. Un esempio potrebbe essere Teste ma ce ne sono molte altre. Se invece ti colleghi col computer al soft-AP, allora puoi usare lo script python riportato sotto. Script python per POST Come primo passo, installa requests: pip install requests Poi crea lo script seguente per il testing: #!/usr/bin/env python3 \u0026#34;\u0026#34;\u0026#34; Send LED flashing parameters to an ESP device via HTTP POST. Endpoint: POST http://192.168.4.1/led/flash Body: {\u0026#34;periods\u0026#34;: [int, ...], \u0026#34;duty_cycles\u0026#34;: [int, ...]} Each pair (period, duty_cycle) defines one blink pattern. \u0026#34;\u0026#34;\u0026#34; import requests import json # --- Configuration --- ESP_IP = \u0026#34;192.168.4.1\u0026#34; # Replace with your moduleâ€™s IP address ENDPOINT = f\u0026#34;http://{ESP_IP}/led/flash\u0026#34; # Example data: # periods in milliseconds, duty_cycles in percentage payload = { \u0026#34;periods\u0026#34;: [1000, 500, 2000], \u0026#34;duty_cycles\u0026#34;: [50, 75, 25] } def send_led_flash(payload): \u0026#34;\u0026#34;\u0026#34;Send POST request to the ESP endpoint with LED flash parameters.\u0026#34;\u0026#34;\u0026#34; try: print(f\u0026#34;Sending POST to {ENDPOINT} ...\u0026#34;) response = requests.post(ENDPOINT, json=payload, timeout=5) response.raise_for_status() print(\u0026#34;âœ… Request successful!\u0026#34;) print(\u0026#34;Response:\u0026#34;, response.text) except requests.exceptions.RequestException as e: print(\u0026#34;âŒ Error communicating with the ESP:\u0026#34;, e) if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;Payload:\u0026#34;, json.dumps(payload, indent=2)) send_led_flash(payload) Traccia della soluzione # Per prima cosa, verifica che periods e duty_cycles abbiano la stessa lunghezza e contengano solo numeri positivi. duty_cycles deve contenere valori compresi tra 0 e 100.\nPoi puoi scorrere i due array e calcolare, per ogni elemento allâ€™indice i, lâ€™on_time e lâ€™off_time del LED come segue:\non_time[i] = duty_cycle[i]/100 * periods[i] off_time[i] = periods[i]-on_time[i] Infine, puoi comandare il LED secondo la sequenza:\nON: on_time[1] OFF: off_time[1] ON: on_time[2] OFF: off_time[2] ... Conclusione # Se sei riuscito ad arrivare a questo punto, significa che hai acquisito una buona comprensione di una semplice implementazione di una REST API. Ora puoi passare alla terza lezione, che spiega la gestione delle librerie esterne e lâ€™uso dei componenti presenti nel component registry.\nProssimo passo # Prossima lezione â†’ Lezione 3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-2-3/","section":"Workshops","summary":"Aggiungere una nuova route per lampeggio programmabile (Opzionale)","title":"ESP-IDF Base - Esercizio 2.3 (Opzionale)","type":"workshops"},{"content":"Questo esercizio prevede due obiettivi:\nCreare un componente led-toggle Rifattorizzare lâ€™esempio hello_led utilizzando il componente creato Creare un componente led-toggle (guidato) # Il primo compito Ã¨ creare un componente led-toggle.\nCreare un nuovo componente # Apri il progetto dell\u0026rsquo;esercizio 2.2 in VS Code Crea un nuovo componente: \u0026gt; ESP-IDF: Create New ESP-IDF Component Digita led_toggle nel campo di testo che appare in alto (vedi Fig.1) Fig.1 - Creare un nuovo componente\nIl progetto conterrÃ  ora la cartella components e tutti i file necessari:\n. â””â”€â”€ hello_led/ â”œâ”€â”€ components/ â”‚ â””â”€â”€ led_toggle/ â”‚ â”œâ”€â”€ include/ â”‚ â”‚ â””â”€â”€ led_toggle.h â”‚ â”œâ”€â”€ CMakeLists.txt â”‚ â””â”€â”€ led_toggle.c â”œâ”€â”€ main â””â”€â”€ build Creare la funzione toggle # Aggiungi l\u0026rsquo;interfaccia pubblica del tuo componente allâ€™interno di led_toggle.h:\n#include \u0026#34;driver/gpio.h\u0026#34; typedef struct { int gpio_nr; bool status; }led_gpio_t; esp_err_t led_config(led_gpio_t * led_gpio); esp_err_t led_drive(led_gpio_t * led_gpio, bool level); esp_err_t led_toggle(led_gpio_t * led_gpio); esp_err Ã¨ un enum (quindi un int) usato per restituire codici di errore. Puoi controllarne i valori nella documentazione. Questo enum viene utilizzato anche con il logging e macro come ESP_ERR_CHECK, che troverai in quasi tutti gli esempi ESP-IDF. Aggiungi la direttiva REQUIRES al CMakeList.txt del componente led_toggle\nidf_component_register(SRCS \u0026#34;led_toggle.c\u0026#34; REQUIRES esp_driver_gpio INCLUDE_DIRS \u0026#34;include\u0026#34;) In led_toggle.c, implementa la logica del modulo:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026#34;led_toggle.h\u0026#34; #include \u0026#34;esp_err.h\u0026#34; esp_err_t led_config(led_gpio_t * led_gpio){ gpio_config_t io_conf = {}; io_conf.intr_type = GPIO_INTR_DISABLE; io_conf.mode = GPIO_MODE_OUTPUT; io_conf.pin_bit_mask = (1ULL\u0026lt;\u0026lt;led_gpio-\u0026gt;gpio_nr); io_conf.pull_down_en = 0; io_conf.pull_up_en = 0; return gpio_config(\u0026amp;io_conf); } esp_err_t led_drive(led_gpio_t * led_gpio,bool level){ led_gpio-\u0026gt;status = level; return gpio_set_level(led_gpio-\u0026gt;gpio_nr, level); // accende il LED } esp_err_t led_toggle(led_gpio_t * led_gpio){ //TBD return 0; } Ora nel app_main includi l\u0026rsquo;header appropriato\nconfigura la periferica (mediante funzione config_led)\nTesta che tutto funzioni correttamente attraverso la funzione drive_led\nRifattorizzare il codice hello_led # Per questa seconda parte dell\u0026rsquo;esercizio dovrai:\nImplementare la funzione toggle_led Rifattorizzare il codice hello_led per utilizzare il componente appena creato. Conclusione # Ora puoi creare i tuoi componenti, rendendo il codice piÃ¹ facile da mantenere e condividere. Nel prossimo esercizio affronterai un tipico problema di sviluppo e utilizzerai le competenze appena apprese.\nSoluzione Esercizio #include \u0026lt;stdio.h\u0026gt; #define ESP_WIFI_SSID \u0026#34;TEST_WORKSHOP\u0026#34; #define ESP_WIFI_PASS \u0026#34;test_esp\u0026#34; #define ESP_WIFI_CHANNEL 1 #define MAX_STA_CONN 2 #include \u0026#34;esp_wifi.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_http_server.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;led_toggle.h\u0026#34; #define OUTPUT_LED GPIO_NUM_7 static const char* TAG = \u0026#34;main\u0026#34;; led_gpio_t my_led = { .gpio_nr = OUTPUT_LED, .status = false }; static esp_err_t hello_get_handler(httpd_req_t *req) { const char* resp_str = \u0026#34;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;; httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* Handler definitions */ static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ printf(\u0026#34;Evento nÂ°: %ld!\\n\u0026#34;, event_id); } static esp_err_t led_on_handler(httpd_req_t *req) { led_drive(\u0026amp;my_led,true); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;on\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static esp_err_t led_off_handler(httpd_req_t *req) { led_drive(\u0026amp;my_led,false); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;off\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } static esp_err_t led_toggle_handler(httpd_req_t *req) { led_toggle(\u0026amp;my_led); const char* resp_str = \u0026#34;{\\\u0026#34;led\\\u0026#34;: \\\u0026#34;toggled\\\u0026#34;}\u0026#34;; httpd_resp_set_type(req, \u0026#34;application/json\u0026#34;); httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN); return ESP_OK; } /* URI definitions */ static const httpd_uri_t hello_world_uri= { .uri = \u0026#34;/\u0026#34;, .method = HTTP_GET, .handler = hello_get_handler, .user_ctx = NULL }; static const httpd_uri_t led_on_uri = { .uri = \u0026#34;/led/on\u0026#34;, .method = HTTP_GET, .handler = led_on_handler, .user_ctx = NULL }; static const httpd_uri_t led_off_uri = { .uri = \u0026#34;/led/off\u0026#34;, .method = HTTP_GET, .handler = led_off_handler, .user_ctx = NULL }; static const httpd_uri_t led_toggle_uri = { .uri = \u0026#34;/led/toggle\u0026#34;, .method = HTTP_GET, .handler = led_toggle_handler, .user_ctx = NULL }; void wifi_init_softap(){ esp_netif_init(); esp_event_loop_create_default(); esp_netif_create_default_wifi_ap(); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); // sempre iniziare da qui esp_wifi_init(\u0026amp;cfg); esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, \u0026amp;wifi_event_handler, NULL, NULL); wifi_config_t wifi_config = { .ap = { .ssid = ESP_WIFI_SSID, .ssid_len = strlen(ESP_WIFI_SSID), .channel = ESP_WIFI_CHANNEL, .password = ESP_WIFI_PASS, .max_connection = MAX_STA_CONN, .authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .required = true, }, }, }; esp_wifi_set_mode(WIFI_MODE_AP); esp_wifi_set_config(WIFI_IF_AP, \u0026amp;wifi_config); esp_wifi_start(); ESP_LOGI(TAG, \u0026#34;wifi_init_softap completata. SSID:%s password:%s canale:%d\u0026#34;, ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL); } httpd_handle_t start_webserver() { httpd_handle_t server = NULL; httpd_config_t config = HTTPD_DEFAULT_CONFIG(); if (httpd_start(\u0026amp;server, \u0026amp;config) == ESP_OK) { ESP_LOGI(TAG, \u0026#34;Server avviato con successo, registrazione degli handler URI...\u0026#34;); return server; } ESP_LOGE(TAG, \u0026#34;Impossibile avviare il server\u0026#34;); return NULL; } void app_main(void) { wifi_init_softap(); led_config(\u0026amp;my_led); httpd_handle_t server = start_webserver(); /* Registrazione URI/Handler */ httpd_register_uri_handler(server,\u0026amp;hello_world_uri); httpd_register_uri_handler(server, \u0026amp;led_on_uri); httpd_register_uri_handler(server, \u0026amp;led_off_uri); httpd_register_uri_handler(server, \u0026amp;led_toggle_uri); } Prossimo passo # Prossimo esercizio â†’ Esercizio 3.2\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-3-1/","section":"Workshops","summary":"Creare un componente \u003ccode\u003eled-toggle\u003c/code\u003e e rifattorizzare l\u0026rsquo;esempio \u003ccode\u003ehello_led\u003c/code\u003e","title":"ESP-IDF Base - Esercizio 3.1","type":"workshops"},{"content":"In questo esercizio leggerai i valori di umiditÃ  e temperatura dal sensore presente sulla scheda.\nPuoi creare un nuovo progetto a partire dall\u0026rsquo;esempio hello_world o continuare sul codice dell\u0026rsquo;esercizio precedente.\nPer questo esercizio, dovrai:\nIndividuare il part number del sensore sulla tua scheda Trovare il codice del driver per pilotare il sensore Leggere temperatura e umiditÃ  dal sensore e stamparle sulla porta seriale usando printf. Non Ã¨ richiesto sviluppare il driver: concentrati sul modo piÃ¹ rapido per risolvere il problema e su quanto trattato nella lezione precedente. Suggerimento # Mostra suggerimento L\u0026rsquo;indirizzo Ã¨ sulla pagina Github del EVK Per installare una dipendenza, apri un terminale ESP-IDF:\n\u0026gt; ESP-IDF: Open ESP-IDF Terminal Usa poi l\u0026rsquo;idf.py idf.py add-dependency \u0026#34;nome_della_repo_nel_registry\u0026#34; Ricordati di modificare le impostazioni nel menuconfig Conclusione # Ora che sei in grado di leggere il sensore sulla scheda, sei pronto per passare allâ€™ultimo esercizio del workshop e mettere tutto insieme.\nProssimo passo # Prossimo esercizio â†’ Esercizio 3.3\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-3-2/","section":"Workshops","summary":"Leggere i valori di umiditÃ  e temperatura dal sensore sulla scheda","title":"ESP-IDF Base - Esercizio 3.2","type":"workshops"},{"content":"In questo esercizio, combinerai tutto ciÃ² che hai fatto fino ad ora aggiungendo le due route seguenti al tuo server HTTP.\nGET /environment/ che restituisce un oggetto json: { \u0026#39;temperature\u0026#39;: float, \u0026#39;humidity\u0026#39;: float } (Opzionale) POST /startblink/ che fa lampeggiare il LED in base alla lettura della temperatura:\nLampeggia il numero delle decine (es. 29 gradi â†’ 2) con 400ms acceso e 200ms spento Pausa di 1 secondo Lampeggia il numero delle unitÃ  (es. 29 gradi â†’ 9) con 400ms acceso e 200ms spento Conclusione # Hai creato una semplice applicazione IoT, combinando la lettura dei sensori con la connettivitÃ  HTTP, permettendo a servizi esterni di interagire con la tua applicazione.\nProssimo passo # Prossimo passo â†’ Conclusione\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-3-3/","section":"Workshops","summary":"Aggiungere la route al server HTTP per mostrare da remoto i dati ambientali","title":"ESP-IDF Base - Esercizio 3.3","type":"workshops"},{"content":" Introduzione a ESP-IDF # ESP-IDF (Espressif IoT Development Framework) Ã¨ il framework di sviluppo ufficiale per i SoC di Espressif Systems. Fornisce un ambiente completo per la creazione di applicazioni IoT con funzionalitÃ  avanzate di connettivitÃ , sicurezza e affidabilitÃ .\nIl framework ESP-IDF include FreeRTOS, consentendo agli sviluppatori di creare applicazioni multitasking in tempo reale. Dispone di un insieme completo di librerie, strumenti e documentazione, fungendo da base per lo sviluppo su dispositivi Espressif.\nESP-IDF include oltre 400 esempi, aiutando gli sviluppatori a iniziare rapidamente i propri progetti.\nArchitettura # Lâ€™architettura della piattaforma ESP-IDF Ã¨ principalmente suddivisa in 3 livelli:\nPiattaforma ESP-IDF Contiene i componenti di base necessari e il sistema operativo. Include FreeRTOS, driver, build system, protocolli, ecc. Middleware Aggiunge nuove funzionalitÃ  a ESP-IDF, come framework audio o HMI. In questo workshop non li utilizzeremo. Applicazione AIoT La tua applicazione. Fig.1 - Panoramica ad alto livello di ESP-IDF\nTutti i blocchi costitutivi necessari per la tua applicazione sono inclusi nella piattaforma ESP-IDF. Visita il progetto ESP-IDF su GitHub per consultare lâ€™elenco aggiornato delle versioni supportate e i relativi periodi di sviluppo attivo e supporto a lungo termine.\nespressif/esp-idf Espressif IoT Development Framework. Official development framework for Espressif SoCs. C 16307 7889 Principali blocchi di ESP-IDF # ESP-IDF Ã¨ costruito su FreeRTOS e contiene diverse librerie. Le principali librerie che includerai nei tuoi progetti sono:\nFreeRTOS (freertos): kernel di sistema operativo leggero e real-time, che fornisce multitasking tramite preemptive scheduling, gestione dei task e comunicazione tra task. Driver (esp_driver_xxx): librerie per la gestione delle periferiche. Protocolli (esp_http, esp-tls, ecc.): librerie che implementano protocolli di comunicazione. Durante gli esercizi imparerai a includere sia librerie interne fornite da ESP-IDF che librerie esterne. ESP-IDF offre anche un sistema basato su pacchetti (chiamati \u0026ldquo;componenti\u0026rdquo;) per la gestione delle librerie e le loro dipendenze.\nComponenti # I componenti sono pacchetti che includono librerie, file per la gestione delle dipendenze, metadati e configurazioni.\nFig.2 - Componenti ESP-IDF\nI componenti vengono utilizzati per aggiungere nuove funzionalitÃ  come driver di sensori, protocolli di comunicazione, board support package e altre caratteristiche non incluse di default in ESP-IDF. Alcuni componenti sono giÃ  integrati negli esempi ufficiali, e lo stesso ESP-IDF adotta il modello dei componenti esterni per promuovere la modularitÃ .\nLâ€™uso dei componenti migliora la manutenibilitÃ  e accelera lo sviluppo, permettendo il riuso e la condivisione del codice tra piÃ¹ progetti.\nSe vuoi creare e pubblicare un tuo componente, ti consigliamo di guardare la presentazione DevCon23 - Developing, Publishing, and Maintaining Components for ESP-IDF o di leggere lâ€™articolo How to create an ESP-IDF component.\nPuoi anche trovare componenti visitando la piattaforma ESP Registry.\nNellâ€™esercizio 3.2 avrai la possibilitÃ  di creare un tuo componente e utilizzarlo nel progetto.\nFramework # ESP-IDF Ã¨ anche la base per altri framework, tra cui:\nArduino per Espressif ESP-ADF (Audio Development Framework): progettato per applicazioni audio. ESP-WHO (AI Development Framework): focalizzato sul riconoscimento facciale. ESP-RainMaker: semplifica la creazione di dispositivi connessi con funzionalitÃ  cloud. ESP-Matter SDK: SDK ufficiale di Espressif per lo sviluppo di applicazioni Matter. Per consultare tutti i framework supportati, visita la pagina GitHub dellâ€™organizzazione Espressif.\nSviluppo con ESP-IDF # Oltre alle librerie, ESP-IDF include gli strumenti necessari per compilare, flashare e monitorare il dispositivo.\nPuoi sviluppare applicazioni per dispositivi Espressif con qualsiasi editor di testo, come Gedit o Notepad++, seguendo la guida di installazione manuale presente nella documentazione ufficiale Espressif.\nIn questo workshop, tuttavia, utilizzeremo un IDE (Integrated Development Environment) per semplificare sia lo sviluppo che la configurazione. Espressif supporta diversi IDE, ma ci concentreremo su Visual Studio Code (VS Code), che dispone di unâ€™estensione ufficiale chiamata ESP-IDF. Questa estensione consente di sviluppare, compilare, caricare e fare debug dei progetti direttamente allâ€™interno dellâ€™editor.\nPer darti unâ€™idea, lâ€™estensione ESP-IDF per VS Code gestisce la toolchain e fornisce comandi come:\n\u0026gt; ESP-IDF: Build Your Project \u0026gt; ESP-IDF: Set Espressif Device Target \u0026gt; ESP-IDF: Full clean project Il carattere \u0026gt; indica la palette dei comandi di VS Code, accessibile premendo F1 o Ctrl+Shift+P (su macOS Cmd+Shift+P).\nTutti questi comandi sono dei wrapper attorno allo strumento principale di ESP-IDF, idf.py.\nHardware utilizzato nel workshop # In questo workshop utilizzeremo un modulo basato sul SoC ESP32-C3, chiamato ESP32-C3-Mini-1-N4. Puoi individuare lâ€™ESP32-C3-Mini-1-N4 sulla tua scheda del workshop (vedi Fig. 3). Il SoC ESP32-C3 si trova sotto lo shield del modulo.\nFig.3 - SoC ESP32-C3, modulo e scheda del workshop\nESP32-C3 SoC # ESP32-C3 Ã¨ un SoC dotato di processore RISC-V a 32 bit, con supporto Wi-Fi a 2.4 GHz e Bluetooth LE (Low Energy). Il diagramma a blocchi funzionale Ã¨ mostrato in Fig. 4.\nFig.4 - Diagramma a blocchi ESP32-C3\nESP32-C3 offre:\nProcessore RISC-V single-core a 160 MHz Wi-Fi: supporta modalitÃ  Station, SoftAP e mista Bluetooth LE: compatibile con Bluetooth 5 e mesh Memoria integrata: 400 KB SRAM, 384 KB ROM Meccanismi di sicurezza: acceleratori crittografici hardware, flash cifrata, bootloader sicuro Ampio set di periferiche: fino a 22 GPIO programmabili per LED PWM, UART, I2C, SPI, I2S, ADC, USB/JTAG, ecc. Modulo ESP32-C3-Mini-1-N4 # Espressif offre anche dei moduli che integrano il SoC, memoria flash aggiuntiva, memoria PSRAM, e unâ€™antenna PCB o connettore. Il vantaggio principale della soluzione modulo Ã¨ la semplicitÃ  dâ€™uso (non serve disegnare la parte RF) e la semplificazione in sede di certificazione. Il modulo utilizzato, l\u0026rsquo;ESP32-C3-MINI-1-N4, include 4MB di flash.\nPuoi trovare la spiegazione dei part number di Espressif nell\u0026rsquo;articolo Espressif part numbers explained: A complete guide - Modules. Scheda del workshop ESP32-C3 # Fig.5 - Scheda del workshop\nSchemi elettrici # Puoi trovare tutti gli schemi nella repository Github del EVK.\nConclusione # Ora che abbiamo una panoramica generale di hardware e firmware, siamo pronti per iniziare il primo esercizio.\nProssimo passo # Prossimo esercizio â†’ Esercizio 1.1\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/lecture-1/","section":"Workshops","summary":"In questa lezione introduciamo ESP-IDF, il framework ufficiale di Espressif per lo sviluppo di applicazioni IoT, analizzandone lâ€™architettura, i principali componenti e gli strumenti di sviluppo. Esploriamo inoltre lâ€™hardware utilizzato nel workshop, basato sul SoC ESP32-C3, preparando cosÃ¬ il terreno per il primo esercizio pratico.","title":"ESP-IDF Base - Lezione 1","type":"workshops"},{"content":" ConnettivitÃ  Internet # Le applicazioni comunicano su internet utilizzando diversi protocolli che si basano l\u0026rsquo;uno sull\u0026rsquo;altro, formando una struttura a strati chiamati \u0026ldquo;layer\u0026rdquo;.\nIl modello ISO/OSI Ã¨ un quadro concettuale che suddivide in sette strati il modo in cui i dati (come messaggi, video o pagine web) viaggiano attraverso le reti. Ogni strato ha una propria funzione e utilizza specifici protocolli.\nIl modello ISO/OSI solito viene rappresentato come in Fig.1.\nFig.1 - Stack ISO/OSI\nPartendo dal basso, gli strati sono:\nFisico (PHY) â€“ Specifica come deve interagire l\u0026rsquo;hardware dei due dispositivi che comunicano tra loro: segnali di tensione, radio, antenne e frequenze.\nEsempio: Wi-Fi, Ethernet\nCollegamento Dati (Data Link) â€“ Gestisce la connessione diretta tra dispositivi (come laptop e router) e lâ€™accesso al canale wireless.\nEsempio: MAC (Media Access Control)\nRete (Network) â€“ Si occupa di come i dati passano da una rete allâ€™altra.\nEsempio: IP (Internet Protocol)\nTrasporto (Transport) â€“ Garantisce che i dati vengano consegnati correttamente e nellâ€™ordine giusto.\nEsempi: TCP (Transmission Control Protocol), UDP (User Datagram Protocol)\nSessione (Session) â€“ Gestisce e mantiene le connessioni tra dispositivi o applicazioni.\nEsempi: TLS, NetBIOS, SMB\nPresentazione (Presentation) â€“ Traduce i dati in modo che siano leggibili da entrambe le parti (ad esempio decifrando un messaggio criptato).\nEsempi: SSL/TLS, JPEG, MP3, ASCII\nApplicazione (Application) â€“ Ãˆ ciÃ² che vede lâ€™utente: siti web, videochiamate, email, ecc.\nEsempi: HTTP, SMTP, FTP, DNS\nAlcuni protocolli gestiscono piÃ¹ strati contemporaneamente. Ad esempio, il protocollo Ethernet si occupa sia dello strato fisico che di quello di collegamento dati.\nOgni strato passa il proprio risultato al successivo. Diversi protocolli ad alto livello, possono riutilizzare gli stessi strati inferiori: ad esempio, MQTT si trova allo stesso livello di HTTP, e entrambi utilizzano lo stack TCP/IP.\nIncapsulamento # La combinazione dei livelli avviene tramite incapsulamento.\nLâ€™incapsulamento Ã¨ il processo con cui il payload di un protocollo a basso livello racchiude l\u0026rsquo;intero frame dei protocolli superiori. Nel contesto di una rete Wi-Fi, i dati dellâ€™applicazione vengono prima incapsulati in un segmento TCP, poi in un pacchetto IP e infine in un frame Wi-Fi (IEEE 802.11) o Ethernet. Ogni strato aggiunge il proprio header (e talvolta un trailer) per consentire una comunicazione modulare ed efficiente.\nUnâ€™immagine vale piÃ¹ di mille parole:\nFig.2 - Incapsulamento\nIn breve, tutto il contenuto del livello superiore Ã¨ incluso nel campo payload (o data) del protocollo di livello inferiore.\nConnettivitÃ  nei dispositivi Espressif # Ora che abbiamo compreso i livelli di connettivitÃ , vediamo quale tipo di connettivitÃ  Ã¨ supportato dai moduli Espressif.\nStrati fisici # I moduli Espressif supportano tre principali PHY, a seconda del SoC:\nWi-Fi â€“ Supportato da tutti i dispositivi (ad eccezione della famiglia H); consente la connessione a un router e quindi a internet. SarÃ  il focus di questo workshop. BLE â€“ Usato principalmente per la comunicazione diretta con uno smartphone e per il provisioning (configurazione iniziale). Thread/Zigbee â€“ Protocolli IoT utilizzati per comunicazioni locali macchina-a-macchina (M2M) basate su topologia mesh (molti-a-molti). Per connettersi a Internet serve un bridge Threadâ€“Wi-Fi. Il protocollo Matter utilizza tutti questi livelli di connettivitÃ : BLE per il provisioning, Thread per la comunicazione a basso consumo e Wi-Fi per il trasferimento di dati ad alta velocitÃ . In questo workshop ci concentreremo solo sul Wi-Fi. Vediamo brevemente la sua topologia.\nTopologia Wi-Fi # In una rete Wi-Fi ci sono due ruoli principali: Access Point (AP) e Station (STA).\nLâ€™Access Point (AP) Ã¨ il dispositivo centrale (come un router) che trasmette la rete wireless e connette le stazioni tra loro e con reti esterne come internet. Una Station (STA) Ã¨ qualsiasi dispositivo che si collega allâ€™AP: smartphone, laptop o dispositivo IoT. Lâ€™AP gestisce il mezzo wireless, mentre le STA comunicano attraverso lâ€™AP, mai direttamente tra loro.\nFig.3 - STA and AP\nI moduli Espressif possono funzionare in entrambe le modalitÃ . Per connettersi a un AP, una stazione ha bisogno di due dati:\nL\u0026rsquo;SSID, ossia il nome della rete La password del AP. Nella prima parte dellâ€™esercitazione, imposteremo il dispositivo Espressif in modalitÃ  AP e useremo lo smartphone per controllare la connessione.\nProtocolli di livello applicativo # Nel mondo IoT, esistono diversi protocolli di comunicazione, tra cui i piÃ¹ comuni sono MQTT e HTTP.\nMQTT Ã¨ progettato per la comunicazione macchina-a-macchina (M2M) ed Ã¨ ampiamente usato per reti di sensori e attuatori, specialmente in domotica.\nHTTP Ã¨ il protocollo alla base del web, utilizzato principalmente per fornire contenuti HTML. Unâ€™altra applicazione importante dell\u0026rsquo;HTTP nellâ€™IoT Ã¨ lâ€™implementazione di REST API, che permettono lâ€™interazione tra dispositivi tramite richieste HTTP.\nAd esempio, unâ€™applicazione web per la casa intelligente puÃ² mostrare lo stato di vari sensori interrogando una REST API esposta da un gateway di sensori, che funge da ponte tra i dispositivi e lâ€™interfaccia utente.\nIn questo workshop useremo HTTP per servire una semplice pagina HTML e per implementare una REST API.\nHTTP, HTML e JSON: Servire pagine web e creare REST API # HTTP puÃ² essere utilizzato sia per servire pagine HTML (visualizzate nei browser) che dati strutturati come JSON (per interfaccia verso altri software).\nLe basi dell\u0026rsquo;HTTP # HTTP (Hypertext Transfer Protocol) Ã¨ il fondamento della comunicazione web, basato su un semplice modello client-server. Il client (browser o app) invia una richiesta al server, che la elabora e restituisce una risposta.\nRichieste HTTP # HTTP definisce diversi metodi di richiesta, ciascuno con uno scopo specifico:\nGET â€“ Recupera dati dal server POST â€“ Invia o crea nuovi dati sul server PUT/PATCH â€“ Aggiorna dati esistenti DELETE â€“ Elimina dati Risposte HTTP # Dopo aver ricevuto una richiesta, il server risponde con un codice di stato che indica il risultato:\n200 OK â€“ Richiesta eseguita con successo 201 Created â€“ Nuova risorsa creata (tipicamente dopo una POST) 400 Bad Request â€“ Sintassi della richiesta non valida 401 Unauthorized â€“ Autenticazione richiesta o fallita 404 Not Found â€“ Risorsa non trovata 500 Internal Server Error â€“ Errore generico sul server Le applicazioni moderne e i sistemi IoT utilizzano spesso JSON (JavaScript Object Notation) per scambiare dati strutturati. Questo Ã¨ anche il formato alla base delle API REST.\nFig.4 - Interazione client-server\nHTML: pagine web # HTML (HyperText Markup Language) Ã¨ il linguaggio standard per creare pagine web. Con ESP-IDF, Ã¨ possibile servire pagine HTML direttamente dal dispositivo embedded tramite protocollo HTTP.\nLe pagine HTML possono essere usate per:\nVisualizzare letture di sensori in tempo reale Fornire interfacce di controllo (pulsanti, slider, ecc.) Permettere la configurazione della rete o dei parametri Un semplice esempio di pagina HTML servita da un dispositivo Espressif Ã¨ il seguente.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Dashboard Sensore Espressif\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Sensore Salotto\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Temperatura: 22.5Â°C\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;UmiditÃ : 60%\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In Fig.5 puoi vedere il rendering della pagina HTML.\nFig.5 - Rendering della pagina HTML\nServire contenuti HTML dal dispositivo permette agli utenti di interagire con esso tramite un browser, senza software aggiuntivo.\nJSON: REST API # JSON Ã¨ un formato leggero e leggibile per rappresentare dati strutturati, ideale per applicazioni web e IoT. Un oggetto JSON Ã¨ composto da coppie chiave-valore, ad esempio:\n{ \u0026#34;temperature\u0026#34;: 22.5, \u0026#34;humidity\u0026#34;: 60, \u0026#34;sensor\u0026#34;: \u0026#34;living_room\u0026#34; } REST API # Una REST API (Representational State Transfer) permette alle applicazioni di interagire con un server usando i metodi HTTP standard. Le risorse sono accessibili tramite route (percorsi URL) strutturate e leggibili.\nEsempi di route API REST:\nGET /sensors â€“ Elenca tutti i sensori GET /sensors/42 â€“ Mostra i dati del sensore 42 POST /sensors â€“ Crea un nuovo sensore PUT /sensors/42 â€“ Aggiorna le impostazioni del sensore 42 DELETE /sensors/42 â€“ Elimina il sensore 42 Nel secondo modulo del workshop, implementerai una semplice pagina HTML e una REST API utilizzando HTTP.\nConclusione # In questa lezione abbiamo introdotto la struttura a livelli della comunicazione Internet, il modello ISO/OSI, lâ€™incapsulamento dei dati e lâ€™uso di protocolli come HTTP e MQTT. Abbiamo inoltre visto come le REST API e il formato JSON permettano una comunicazione strutturata tra dispositivi e applicazioni â€” fondamenta dei moderni sistemi IoT connessi.\nOra hai tutte le basi teoriche per iniziare gli esercizi di questa sezione.\nProssimo passo # Prossimo esercizio â†’ Esercizio 2.1\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/lecture-2/","section":"Workshops","summary":"In questa lezione introduciamo la struttura a strati della comunicazione internet, spiegando il modello ISO/OSI e il processo di incapsulamento dei dati. Approfondiamo inoltre i protocolli HTTP e MQTT, mostrando come le REST API e il formato JSON consentano la comunicazione tra dispositivi.","title":"ESP-IDF Base - Lezione 2","type":"workshops"},{"content":" Introduzione # Come abbiamo visto in precedenza, ESP-IDF contiene diverse librerie, da FreeRTOS (il sistema operativo real time) ai driver delle periferiche e alle librerie dei protocolli. Per questioni di spazio, includere librerie per ogni possibile protocollo, algoritmo o driver allâ€™interno di ESP-IDF non Ã¨ possibile.\nSe hai bisogno di un protocollo specifico, Ã¨ molto probabile che si trovi su Github l\u0026rsquo;implementazione in C. In questo caso, la sfida sarÃ  portarlo in ESP-IDF, occupandosi di individuare tutte le dipendenze e informare il build system di quali file debbano essere compilati e linkati.\nPer risolvere questi problemi, Espressif ha sviluppato un sistema di componenti simile ai package manager delle distribuzioni GNU/Linux. I componenti permettono di gestire sia le dipendenze che il linker e per usare un component ESP-IDF Ã¨ sufficiente includere l\u0026rsquo;header file per iniziare ad usarlo.\nCome nel caso dei pacchetti Linux, esiste anche un component manager e un component registry, dove puoi trovare tutti i pacchetti ufficiali di Espressif. Una volta inclusi i componenti, lo strumento idf.py scaricherÃ  il componente e preparerÃ  lâ€™ambiente per il suo utilizzo.\nPer ulteriori informazioni, consigliamo di guardare il talk DevCon23 - Developing, Publishing, and Maintaining Components for ESP-IDF.\nIn questa lezione esploreremo le differenze tra lâ€™uso delle librerie integrate e quelle fornite dal component registry. Vedremo anche come creare un componente per rendere il codice riutilizzabile.\nIn particolare, vedremo come:\nIncludere e usare le librerie gpio e i2c (incluse nell\u0026rsquo;ESP-IDF) Usare il componente button dal registry Creare un nuovo componente Durante gli esercizi, lâ€™obiettivo sarÃ  controllare il LED e il sensore I2C (SHTC3) sulla scheda (vedi Fig. 1).\nFig.1 - GPIO collegato al LED\nLibrerie incluse # Vediamo come usare le librerie incluse nell\u0026rsquo;ESP-IDF. Di solito ciÃ² comporta tre passaggi principali:\nInformare il build system della libreria (includere lâ€™header file e aggiornare CMakeLists.txt) Configurare le impostazioni della libreria Usare la libreria chiamando le sue funzioni GPIO # Un GPIO (General-Purpose Input/Output) Ã¨ unâ€™interfaccia digitale su un microcontrollore o processore che permette di leggere segnali in ingresso (come pulsanti) o controllare dispositivi in uscita (come LED) tramite pin programmabili. I pin possono essere configurati singolarmente come input o output.\nSulla nostra scheda, abbiamo un LED collegato al GPIO8 (vedi Fig. 1) che useremo per lâ€™esempio.\nInclusione della libreria # Per includere la libreria gpio, dobbiamo prima includere lâ€™header e informare il build system dove trovarlo.\n#include \u0026#34;driver/gpio.h\u0026#34; e poi aggiungere a CMakeLists.txt:\nREQUIRES esp_driver_gpio Nota che il file header e il percorso richiesto possono essere diversi: quando includi una libreria, verifica sempre la programming guide.\nPer trovare il path da usare nella direttiva REQUIRES devi seguire i seguenti passi:\nScegliere il core usato (nel nostro caso ESP32-C3) nel riquadro in alto a sinistra. Trovare la pagina della periferica (GPIO) Trovare la sezione API Reference Configurazione # Le periferiche hanno molte impostazioni (input/output, frequenza, ecc.), di conseguenza Ã¨ sempre necessario configurarle prima dellâ€™uso.\nPer il GPIO, una configurazione base Ã¨:\n// inizializza la struttura a zero gpio_config_t io_conf = {}; // disabilita interrupt io_conf.intr_type = GPIO_INTR_DISABLE; // modalitÃ  output io_conf.mode = GPIO_MODE_OUTPUT; // bit mask dei pin da configurare, es. GPIO18/19 io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL; // disabilita pull-down io_conf.pull_down_en = 0; // disabilita pull-up io_conf.pull_up_en = 0; // applica la configurazione al GPIO gpio_config(\u0026amp;io_conf); In questo workshop useremo i GPIO come output. Non parleremo quindi di:\nInterrupt (attivare una funzione quando lâ€™input cambia) Pull-up e pull-down (valore di default dellâ€™input) Lâ€™unico campo che ha bisogno di spiegazione Ã¨ il pin_bit_mask. La configurazione si applica allâ€™intera periferica GPIO. Per poter applicare una configurazione un sottoinsieme di pin, bisogna specificarli tramite una bit mask.\nSupponiamo di voler configurare il pin 10. La bit mask puÃ² essere generata in questo modo:\n#define GPIO_OUTPUT_LED 10 #define GPIO_OUTPUT_PIN_SEL (1ULL\u0026lt;\u0026lt;GPIO_OUTPUT_LED) // es. 0000000000000000000000000000010000000000 Nel caso in cui volessimo invece applicare la configurazione a piÃ¹ GPIO, si usa lâ€™operatore OR:\n#define GPIO_OUTPUT_LED 10 #define GPIO_OUTPUT_EXAMPLE 12 #define GPIO_OUTPUT_PIN_SEL ((1ULL\u0026lt;\u0026lt;GPIO_OUTPUT_LED) | (GPIO_OUTPUT_EXAMPLE)) // es. 0000000000000000000000000001010000000000 Uso # Una volta configurato la periferica, possiamo usare la funzione gpio_set_level per impostare lâ€™uscita a 0 o 1.\ngpio_set_level(GPIO_OUTPUT_LED, 1); // accende il LED gpio_set_level(GPIO_OUTPUT_LED, 0); // spegne il LED I2C # I2C (Inter-Integrated Circuit) Ã¨ un protocollo di comunicazione che utilizza solo due fili (SDA per i dati e SCL per il clock) per trasmettere dati tra dispositivi. Di solito serve a collegare un microcontrollore a un sensore o attuatore esterno. L\u0026rsquo;I2C permette a piÃ¹ periferiche di comunicare con un microcontrollore usando gli stessi fili ed indirizzi univoci, garantendo interconnessioni efficienti e scalabili.\nInclusione della libreria # Consultando la programming guide otteniamo lâ€™header:\n#include \u0026#34;driver/i2c_master.h\u0026#34; e il nome per la direttiva REQUIRES del CMakeLists.txt:\nREQUIRES esp_driver_i2c Configurazione # La configurazione per questa periferica ha la forma seguente:\ni2c_master_bus_config_t bus_config = { .i2c_port = I2C_NUM_0, .sda_io_num = I2C_MASTER_SDA_IO, .scl_io_num = I2C_MASTER_SCL_IO, .clk_source = I2C_CLK_SRC_DEFAULT, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; i2c_new_master_bus(\u0026amp;bus_config, bus_handle); i2c_device_config_t dev_config = { .dev_addr_length = I2C_ADDR_BIT_LEN_7, .device_address = SHTC3_SENSOR_ADDR, .scl_speed_hz = 400000, }; i2c_master_bus_add_device(*bus_handle, \u0026amp;dev_config, dev_handle); I valori per la nostra scheda sono (vedi Fig. 1):\n#define I2C_MASTER_SDA_IO 7 #define I2C_MASTER_SCL_IO 8 #define SHTC3_SENSOR_ADDR 0x70 Le altre macro sono definite internamente.\nComponent Registry # Usare un componente dal registry - button # Per vedere come gestire una libreria esterna, utilizzeremo il componente button attraverso il component registry.\nVai al component registry Cerca il componente button (espressif/button) Copia lâ€™istruzione a sinistra (vedi Fig.2) - idf.py add-dependency \u0026quot;espressif/button^4.1.3\u0026quot; In VS Code: \u0026gt; ESP-IDF: Open ESP-IDF Terminal e incolla il comando Fig.2 - Componente espressif/button\nRiceverai un messaggio simile a:\nExecuting action: add-dependency NOTICE: Successfully added dependency \u0026#34;espressif/button\u0026#34;: \u0026#34;^4.1.3\u0026#34; to component \u0026#34;main\u0026#34; NOTICE: If you want to make additional changes to the manifest file at path \u0026lt;user_path\u0026gt;/blink/main/idf_component.yml manually, please refer to the documentation: https://docs.espressif.com/projects/idf-component-manager/en/latest/reference/manifest_file.html Un nuovo file idf_component.yml Ã¨ stato creato nel progetto con il seguente contenuto:\ndependencies: espressif/led_strip: ^2.4.1 espressif/button: ^4.1.3 Puoi aggiungere dipendenze direttamente in questo file, ma Ã¨ consigliato usare lâ€™utility idf.py add-dependency.\nPer usare il componente, includi lâ€™header appropriato e chiama le funzioni indicate nella documentazione.\nCreare un componente # Per istruzioni dettagliate su come creare un componente tramite CLI, puoi consultare lâ€™articolo How to create an ESP-IDF component sul Developer Portal di Espressif.\nIn questa lezione vedremo invece come creare un componente con VS Code. I passi da seguire sono simili a quelli via CLI:\nCrea un nuovo progetto Crea un nuovo componente con \u0026gt; ESP-IDF: Create New ESP-IDF Component Assegna un nome al componente (es. led_toggle) Il progetto conterrÃ  ora una cartella components con tutti i file necessari:\n. â””â”€â”€ project_folder/ â”œâ”€â”€ components/ â”‚ â””â”€â”€ led_toggle/ â”‚ â”œâ”€â”€ include/ â”‚ â”‚ â””â”€â”€ led_toggle.h â”‚ â”œâ”€â”€ CMakeList.txt â”‚ â””â”€â”€ led_toggle.c â”œâ”€â”€ main â””â”€â”€ build Ogni volta che crei o scarichi un componente, Ã¨ necessario eseguire un full clean del progetto chiamando:\n\u0026gt; ESP-IDF: Full Clean Project\nPuoi quindi includere il tuo componente nel file principale come led_toggle.h.\nConclusione # In questa breve lezione abbiamo esplorato due principali modalitÃ  per includere librerie esterne: direttamente tramite `\nProssimo passo # Prossimo passo: Esercizio 3.1\nOppure torna al menÃ¹ di navigazione\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/lecture-3/","section":"Workshops","summary":"In questa lezione vedremo come includere librerie che fanno parte dell\u0026rsquo;ESP-IDF, librerie esterne e componenti dal ESP component registry","title":"ESP-IDF Base - Lezione 3","type":"workshops"},{"content":"Benvenuto al workshop ESP-IDF avanzato!\nIntroduzione # In questo workshop incontreremo alcuni aspetti piÃ¹ avanzati del framework ESP-IDF, tra cui lo sviluppo modulare tramite componenti, l\u0026rsquo;event loop, i core dump e le funzionalitÃ  di sicurezza.\nTempo stimato: 3 ore. Agenda # Il workshop Ã¨ suddiviso in quattro parti.\nParte 1: Componenti\nLezione 1 â€“ Cosâ€™Ã¨ un componente, come crearlo e come supportare piÃ¹ versioni hardware tramite BSP e configurazioni multiple Esercizio 1.1 â€“ Refactoring del codice creando il componente alarm Esercizio 1.2 â€“ Refactoring del codice creando il componente cloud_manager Esercizio 1.3 â€“ Configurazioni multiple utilizzando sdkconfig Parte 2: Event Loop\nLezione 2 â€“ Informazioni base sugli event loop in ESP-IDF, uso degli eventi dei timer e separazione delle responsabilitÃ  Esercizio 2.1 â€“ Refactoring del codice per utilizzare l\u0026rsquo;event loop Esercizio 2.2 â€“ Aggiungere un evento GPIO allâ€™event loop Parte 3: Prestazioni e analisi dei crash\nLezione 3 â€“ Size analysis ed uso del core dump per debug Esercizio 3.1 â€“ Analizzare le dimensioni dellâ€™applicazione e suggerire ottimizzazioni Esercizio 3.2 â€“ Analizzare un crash utilizzando i core dump (guidato) Esercizio 3.3 â€“ Analizzare un crash utilizzando i core dump (opzionale) Parte 4: OTA e FunzionalitÃ  di Sicurezza\nLezione 4 â€“ Fondamenti di OTA, configurazione della tabella delle partizioni, bootloader sicuro, flash cifrata Esercizio 4.1 â€“ Modificare la tabella delle partizioni per supportare OTA Esercizio 4.2 â€“ Utilizzare una tabella delle partizioni personalizzata Esercizio 4.3 â€“ Abilitare la cifratura della flash Prerequisiti # Per seguire questo workshop, assicurati di soddisfare i prerequisiti elencati di seguito.\nSoftware richiesto # VS Code installato sul proprio computer Estensione ESP-IDF per VS Code aggiunta a VS Code ESP-IDF installato sulla propria macchina\nPuÃ² essere installato tramite VS Code oppure utilizzando lâ€™ESP-IDF Installer Manager Hardware richiesto # Scheda ESP-C3-DevKit-RUST-1 o ESP-C3-DevKit-RUST-2 (se l\u0026rsquo;attivitÃ  Ã¨ in presenza, la scheda verrÃ  fornita durante il workshop)\nÃˆ possibile utilizzare anche una scheda ESP32-C3-DevKit-M/C, ma sarÃ  necessario adattare la configurazione dei pin GPIO di conseguenza. Se l\u0026rsquo;evento si svolge in presenza, si consiglia vivamente di installare VS Code e il plugin ESP-IDF prima dellâ€™inizio del workshop. In caso di problemi, sarÃ  comunque previsto un breve momento durante il primo esercizio per completare lâ€™installazione. Conoscenze base # Buona conoscenza di: Programmazione in C e del linker Funzioni di callback e puntatori a funzione Protocollo MQTT e il suo utilizzo Programmazione embedded Flashing / Programmazione, linking FamiliaritÃ  con le periferiche MCU come GPIO e I2C Esperienza di base con ESP-IDF Installazione degli strumenti (VS Code+ estensione ESP-IDF) Si consiglia vivamente di installare VS Code e il plugin ESP-IDF prima dellâ€™inizio del workshop. Tuttavia, se riscontri problemi, ci sarÃ  un po\u0026rsquo; tempo durante il primo esercizio per completare lâ€™installazione.\nProssimo passo # La prima lezione si basa sul codice in assignment_1_1_base.\nSe durante le esercitazioni non riuscirai a completare un esercizio, potrai comunque continuare scaricando la soluzione appropriata secondo lo schema seguente:\na a s s s s i i g g n n m m e e n n t t _ _ 1 3 _ _ 1 2 _ _ b b a a s s e e a s s i g n m e n t _ 1 _ 1 a s s i g n m e n t a a _ s s 1 s s _ i i 2 g g n n m m e e n n t t _ a 2 3 s _ _ s 1 2 i g n m e n t a a _ s s 1 s s _ i i 3 g g n n m m e e n n t t _ 2 4 _ _ 2 1 a a s s s s i i g g n n m m e e n n t t _ 3 4 _ _ 1 2 Anche se completi con successo tutti gli esercizi, dovrai comunque scaricare almeno assignment_1_1_base e assignment_3_2_base. Il tuo prossimo passo Ã¨ Lezione 1.\nConclusione # Congratulazioni! Sei arrivato alla fine di questo workshop. Speriamo sia stata unâ€™esperienza utile e lâ€™inizio di un percorso piÃ¹ lungo. Grazie per aver seguito il workshop avanzato su ESP-IDF.\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/","section":"Workshops","summary":"Questo workshop tratta le funzionalitÃ  avanzate di ESP-IDF e si concentra sullo sviluppo modulare, sull\u0026rsquo;event loop, sui core dump, sulla size analysis e sulla cifratura della flash.","title":"ESP-IDF workshop: Avanzato","type":"workshops"},{"content":"Benvenuto al workshop base su ESP-IDF!\nIntroduzione # In questo workshop acquisirai una solida comprensione del framework ESP-IDF, imparando a utilizzare in modo efficace Visual Studio Code (VS Code) e lâ€™estensione ESP-IDF per VS Code.\nIl workshop Ã¨ diviso in tre parti.\nNella prima parte, verificheremo che il tuo ambiente di sviluppo sia configurato correttamente, utilizzando come punto di partenza il classico esempio hello world.\nNella seconda parte, approfondiremo lo stack di rete e realizzeremo insieme un semplice server HTTP.\nLa terza parte sarÃ  dedicata a due periferiche molto comuni: GPIO e I2C. Esploreremo inoltre il sistema dei componenti e il component registry, che permette di usare librerie senza dover gestire manualmente le dipendenze o le impostazioni del build system. Nell\u0026rsquo;ultima esercitazione, combineremo il tutto per creare un semplice gateway di sensori, integrando connettivitÃ  e controllo delle periferiche in un unico progetto.\nAl termine del workshop, avrai le competenze di base necessarie per iniziare a sviluppare le tue applicazioni basate su ESP-IDF.\nDurata stimata: 3 ore. Agenda # Il workshop Ã¨ diviso in tre parti, ciascuna della durata di circa unâ€™ora.\nParte 1: Benvenuto e introduzione\nLezione 1 â€“ Introduzione a ESP-IDF e allâ€™estensione ESP-IDF per VS Code Esercizio 1.1 â€“ Verifica lâ€™installazione di ESP-IDF e VS Code compilando e caricando lâ€™esempio hello_world. Modifica il testo dellâ€™esempio. Esercizio 1.2 â€“ Crea un nuovo progetto a partire dallâ€™esempio blink. Parte 2: ConnettivitÃ  HTTP\nLezione 2 â€“ ConnettivitÃ : protocollo HTTP, HTML e REST API\nEsercizio 2.1 â€“ Crea un server HTTP per la gestione della richiesta GET /index.html/ che restituisca \u0026lt;h1\u0026gt;Hello LED Control\u0026lt;/h1\u0026gt;.\nEsercizio 2.2 â€“ Aggiungi al server HTTP le seguenti route:\nGET /led/on â†’ accende il LED e restituisce il JSON {\u0026quot;led\u0026quot;: \u0026quot;on\u0026quot;} GET /led/off â†’ spegne il LED e restituisce il JSON {\u0026quot;led\u0026quot;: \u0026quot;off\u0026quot;} POST /led/blink â†’ accetta un JSON { \u0026quot;times\u0026quot;: int, \u0026quot;interval_ms\u0026quot;: int } e fa lampeggiare il LED il numero di volte indicato con lâ€™intervallo specificato. Esercizio 2.3 â€“ (Opzionale) Aggiungi al server HTTP la route:\nPOST /led/flash â†’ accetta il JSON {\u0026quot;periods\u0026quot;: [int], \u0026quot;duty_cycles\u0026quot;: [int]} e, per ogni elemento, calcola i tempi di accensione e spegnimento, pilotando il LED di conseguenza. Parte 3: Periferiche e integrazione\nLezione 3 â€“ GPIO, I2C e uso del component registry.\nEsercizio 3.1 â€“ Crea un nuovo componente per pilotare il LED.\nEsercizio 3.2 â€“ Aggiungi un componente per la lettura del sensore ambientale a bordo.\nEsercizio 3.3 â€“ (Opzionale) Aggiungi la rotta:\nGET /environment/ â†’ restituisce la lettura del sensore. Scegli il formato JSON piÃ¹ adatto per rappresentare i dati. Prerequisiti # Per seguire questo workshop, assicurati di soddisfare i prerequisiti riportati di seguito.\nSoftware richiesto # VS Code installato sul proprio computer Estensione ESP-IDF per VS Code aggiunta a VS Code ESP-IDF installato sulla propria macchina\nPuÃ² essere installato tramite VS Code oppure utilizzando lâ€™ESP-IDF Installer Manager Hardware richiesto # Scheda ESP-C3-DevKit-RUST-1 o ESP-C3-DevKit-RUST-2 (se l\u0026rsquo;attivitÃ  Ã¨ in presenza, la scheda verrÃ  fornita durante il workshop)\nÃˆ possibile utilizzare anche una scheda ESP32-C3-DevKit-M/C, ma sarÃ  necessario adattare la configurazione dei pin GPIO di conseguenza. Se l\u0026rsquo;evento si svolge in presenza, si consiglia vivamente di installare VS Code e il plugin ESP-IDF prima dellâ€™inizio del workshop. In caso di problemi, sarÃ  comunque previsto un breve momento durante il primo esercizio per completare lâ€™installazione. Conoscenze di base # Elettronica di base Resistenze, condensatori, alimentatori DC/DC Lettura di uno schema elettrico Programmazione embedded di base Cos\u0026rsquo;Ã© la memoria flash Differenza tra compilazione e caricamento del firmware Conoscenza delle principali periferiche di un microcontrollore (principalmente GPIO e I2C) Nozioni base del linguaggio C Cos\u0026rsquo;Ã¨ un header file Concetti di compilatore / linker Uso di define, struct e typedef Formati JSON e YAML HTML e i suoi principali tag (\u0026lt;html\u0026gt;, \u0026lt;body\u0026gt;, \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, \u0026lt;p\u0026gt;) Nozioni base sui metodi di richiesta HTTP (GET, POST) e sul concetto di URI e route Prossimo passo # Il prossimo passo Ã¨ Lezione 1.\nConclusione # Congratulazioni! Sei arrivato alla fine di questo workshop. Ci auguriamo che sia stata unâ€™esperienza utile e lâ€™inizio di un percorso di approfondimento dei tool di Espressif.\nOra sei in grado di creare, compilare e caricare nuovi progetti, utilizzare librerie e componenti esterni, creare i tuoi componenti e controllare tutto tramite unâ€™interfaccia HTTP. Hai quindi acquisito le basi fondamentali per sviluppare unâ€™applicazione IoT.\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/","section":"Workshops","summary":"Questo workshop Ã¨ incentrato sulle basi del framework ESP-IDF: compilerai il tuo primo progetto e programmerai il modulo ESP32-C3 montato su un EVK. Durante questa attivitÃ , creerai dei componenti per ESP-IDF e farai partire un server HTTP con REST API.","title":"ESP-IDF workshop: Base","type":"workshops"},{"content":" Guida setup ambiente # Introduzione # In questa guida vedremo come impostare l\u0026rsquo;ambiente di sviluppo per poter lavorare a progetti basati su toolchain ESP-IDF.\nNel seguito useremo l\u0026rsquo;IDE open source VS Code e l\u0026rsquo;estensione ESP-IDF per VS Code, che permette sia di configurare la tool chain che di compilare e di programmare la memoria flash dei moduli Espressif.\nSe non hai a disposizione una EVK Espressif, puoi comunque testare tutti i passi riportati in questa guida tranne l\u0026rsquo;ultimo.\nPer l\u0026rsquo;ultimo step, Ã¨ necessario invece un EVK basato su un qualunque SoC Espressif. Durante il workshop verrÃ  consegnata una scheda basata su ESP32-C3, la ESP32-C3-DevKit-RUST-1.\nIl termine ESP-IDF compare sia per indicare la toolchain vera e propria che l\u0026rsquo;estensione per VS Code. In questa guida verrÃ  esplicitamente indicata come toolchain ESP-IDF la prima ed estensione ESP-IDF la seconda. La guida Ã¨ strutturata divisa in 5 parti:\nInstallazione di VS Code e dei prerequisiti Installazione dell\u0026rsquo;estensione ESP-IDF per VS Code Configurazione della toolchain ESP-IDF Compilazione primo progetto Programmazione del modulo Installazione VS Code e prerequisiti # Questo passo dipende dal tuo sistema operativo, segui la guida appropriata qui sotto.\nðŸ§ Linux: Installazione VS Code e prerequisiti ðŸªŸ Windows: Installazione VS Code ðŸŽ macOS: Installazione VS Code e prerequisiti Installazione dell\u0026rsquo;estensione per VS Code # Una volta installati tutti i prerequisiti, possiamo aggiungere l\u0026rsquo;estensione ESP-IDF a VS Code. Attraverso l\u0026rsquo;estensione ESP-IDF, installeremo e configureremo poi la toolchain ESP-IDF.\nApri VS Code Individua l\u0026rsquo;icona delle estensioni (quattro quadrati) sulla sinistra Cerca nel riquadro esp-idf Clicca il tasto \u0026ldquo;Install\u0026rdquo; sul primo risultato ESP-IDF Se richiesto, clicca su \u0026ldquo;Accetta e installa\u0026rdquo; Configurazione della toolchain ESP-IDF # Una volta installata l\u0026rsquo;estensione ESP-IDF, va eseguita la procedura di configurazione che permetterÃ  di installare l\u0026rsquo;intera toolchain ESP-IDF automaticamente.\nClicca su Configuring the ESP-IDF Extension Se non si Ã¨ aperta automaticamente la pagina di configurazione dell\u0026rsquo;estensione, puoi:\nAprire la palette dei comandi (F1 oppure CTRL+SHIFT+P) Digitare:\n\u0026gt; ESP-IDF: Configure ESP-IDF Extension Si aprirÃ  un nuovo tab â†’ Clicca su EXPRESS Apri il menÃ¹ a tendina Select ESP-IDF version Selezione l\u0026rsquo;opzione 5.5.1 (release version) Clicca su Install Attendi che l\u0026rsquo;installazione sia finita. L\u0026rsquo;installazione puÃ² richiedere parecchio tempo. Al termine dell\u0026rsquo;installazione troverai la schermata di conferma Compilazione del primo progetto # Una volta installata l\u0026rsquo;estensione e la toolchain, Ã¨ il momento di testare la compilazione di un progetto. Per fare questo, creeremo un nuovo progetto a partire da uno degli esempi inclusi con la toolchain ESP-IDF.\nCrea un progetto da un esempio # Apri la command palette (F1 o CTRL+SHIFT+P) Inizia a digitare ESP-IDF: Show Example Project e clicca sull\u0026rsquo;opzione che compare sotto sotto. Si apre un menÃ¹ a tendina â†’ Seleziona la versione ESP-IDF v5.51 Si apre un tab con una lista di progetti â†’ Seleziona hello_world Nel tab centrale si apre la descrizione del progetto Clicca su Select location for creating hello_world project Si apre la finestra di selezione â†’ scegli una cartella dove creare il progetto e premi Select this folder\nSi apre ora una nuova finestra di VS Code Nel riquadro a destra, dovresti ora vedere i file del progetto basato sull\u0026rsquo;esempio hello_world. Se non vedi i file, assicurati che sia selezionata la prima icona sulla sinistra (i due fogli sovrapposti). Specificare il target # Per poter compilare il progetto e programmare il modulo Espressif, Ã¨ necessario indicare al compilatore con quale SoC si desidera procedere (chiamato \u0026ldquo;target\u0026rdquo;). Nel workshop, useremo una scheda basata su ESP32-C3, quindi per l\u0026rsquo;installazione indicheremo questo target.\nSe hai a disposizione un\u0026rsquo;altra EVK, scegli il target corrispondente. Nella palette dei comandi (F1 o CTRL+SHIFT+P) digita ESP-IDF: Set Espressif Device Target Nel menÃ¹ a tendina che compare â†’ seleziona esp32c3 Nel menÃ¹ a tendina seguente â†’ seleziona ESP32-C3 chip (via builtin USB-JTAG) Compilare il progetto # Passiamo ora alla compilazione del progetto.\nApri la palette dei comandi (F1 o CTRL+SHIF+P)\nInizia a digitare ESP-IDF: Build Your Project\nA questo punto si apre un terminale in basso e compaiono i messaggi di compilazione Alla fine della compilazione, vedrai il riassunto della memoria richiesta Se vedi la schermata di riassunto, significa che sia la toolchain che l\u0026rsquo;estensione sono state correttamente installate.\nSe hai a disposizione una EVK Espressif, puoi procedere ora con la sezione successiva. Qui verificheremo che la connessione USB sia operativa.\nProgrammazione del modulo (flash) # Una volta compilato il progetto, Ã¨ il momento di programmare il modulo. L\u0026rsquo;estensione ESP-IDF per VS Code mette a disposizione il comando \u0026gt; ESP-IDF: Flash (UART) Your Project.\nIn generale perÃ², il comando che viene piÃ¹ utilizzato Ã¨ il seguente\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Oltre a compilare il progetto e programmarlo sul dispositivo, questo comando inizializza un monitor, ossia ti permette di leggere la seriale del modulo direttamente sul terminale dell\u0026rsquo;editor.\nPer programmare il modulo, bisogna\nSelezionare la porta a cui Ã¨ collegata l\u0026rsquo;EVK Programmare il modulo e far partire un monitor\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device In Linux potresti aver bisogno di aggiungere l\u0026rsquo;utente al gruppo dialout per poter usare la seriale senza i privilegi di admin. Da terminale, digita:\nsudo usermod -a -G dialout $USER Ricordati di chiudere la sessione (log out) e riaprine una per rendere attive le modifiche.\nSelezionare la porta a cui Ã¨ collegata l\u0026rsquo;EVK # Connetti la scheda con un cavo USB alla porta del tuo computer Se l\u0026rsquo;avevi chiuso, riapri VS Code e apri la cartella del progetto Fileâ†’ Open Folder oppure Fileâ†’ Open Recent Apri la palette dei comandi e digita:\n\u0026gt;ESP-IDF: Select Port to Use (COM, tty, usbserial) Seleziona la porta (Silicon Labs - il produttore del ponte USB/UART a bordo dell\u0026rsquo;EVK) Il nome della porta ora appare nella barra in basso Se il sistema operativo non rileva automaticamente la scheda connessa alla porta USB, consulta la guida corrispondente:\nðŸªŸ Windows ðŸ§ Linux ðŸŽ macOS Programmare il modulo e far partire un monitor # Apri la palette dei comandi e digita:\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Nel menÃ¹ a tendina â†’ seleziona UART Attendi che il modulo venga programmato e che parta il monitor Nel terminale dell\u0026rsquo;editor, vedrai i messaggi di boot e l\u0026rsquo;\u0026ldquo;hello world!\u0026rdquo; Se riesci a vedere il messaggio nel terminale, significa che il tuo setup Ã¨ operativo e sei pronto per il workshop e per lavorare a progetti basati su ESP-IDF.\nConclusione # In questa guida abbiamo visto come installare VS Code, l\u0026rsquo;estensione ESP-IDF e la toolchain di ESP-IDF. Abbiamo visto come creare un progetto, compilarlo e programmare il modulo sull\u0026rsquo;EVK. L\u0026rsquo;ambiente di sviluppo Ã¨ ora pronto.\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-setup/","section":"Workshops","summary":"Questa guida presenta i passi preliminari per impostare il setup di lavoro e seguire i workshop.","title":"ESP-IDF workshop: Passi preliminari","type":"workshops"},{"content":"Benvenuto sulla pagina dei workshop ESP-IDF di Espressif Systems.\nWorkshop disponibili # ","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/","section":"Espressif ESP-IDF Workshops","summary":"","title":"Espressif ESP-IDF Workshops","type":"page"},{"content":" Installazione VS Code # Vai su sito di download di VS Code Scarica ed installa la versione per Linux (.deb per Ubuntu) In questa guida viene usata l\u0026rsquo;ultima versione LST di Ubuntu, la 24.04. Una volta scaricato il file, verifica il nome del file (in seguito \u0026lt;file\u0026gt;.deb)\nApri il terminale (CTRL+ALT+T) e digita:\nsudo apt install ./\u0026lt;file\u0026gt;.deb Finita l\u0026rsquo;installazione, crea una cartella e prova ad aprire VS Code da terminale:\nmkdir tmp cd tmp code . Dovresti ora vedere l\u0026rsquo;interfaccia di VS Code\nVS Code potrebbe chiederti se ti fidi dell\u0026rsquo;autore della cartella. Questo aspetto Ã¨ importante quando vengono usate repo git, per il momento non fa differenza. Clicca \u0026ldquo;SÃ¬\u0026rdquo;. Installazione prerequisiti # Per poter installare e configurare la toolchain ESP-IDF, Ã¨ necessario avere giÃ  installati Python e git.\nPython # Per installare la toolchain ESP-IDF Ã¨ richiesto una version di python superiore a 3.12.\nPer verificare la versione di python:\nApri un terminale (CTRL+ALT+T) Digita python3 --version Il risultato in Ubuntu 24.04 Ã¨ espressif@Ubuntu24:~$ python3 --version Python 3.12.3 Quindi il prerequisito Ã¨ soddisfatto.\nSe per qualche ragione non lo fosse, puoi seguire questa guida git # Lo sviluppo di ESP-IDF Ã¨ basato su git, il tool di controllo di versione usato, tra gli altri, anche per lo sviluppo del kernel Linux. git Ã¨ la base su cui si fonda GitHub.\nPer installare git:\nApri un terminale (CTRL+ALT+T) Aggiorna le repository:\nsudo apt-get update Installa git:\nsudo apt-get install git Rispondi Y quando richiesto: espressif@Ubuntu24:~$ sudo apt-get install git Reading package lists... Done Building dependency tree... Done Reading state information... Done The following additional packages will be installed: git-man liberror-perl Suggested packages: git-daemon-run | git-daemon-sysvinit git-doc git-email git-gui gitk gitweb git-cvs git-mediawiki git-svn The following NEW packages will be installed: git git-man liberror-perl 0 upgraded, 3 newly installed, 0 to remove and 70 not upgraded. Need to get 4,806 kB of archives. After this operation, 24.5 MB of additional disk space will be used. Do you want to continue? [Y/n] Controlla che git sia stato installato correttamente:\n\u0026gt; git --version \u0026gt; git version 2.43.0 ESP-IDF prerequisiti # Per utilizzare la toolchain ESP-IDF, Ã¨ necessario installare alcuni tool addizionali.\nIn Ubuntu, puoi digitare il comando seguente per installarli tutti:\nsudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 Prossimi step # Prosegui con il prossimo passo.\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-setup/installation_linux/","section":"Workshops","summary":"Questa guida presenta i passi preliminari per impostare il setup di lavoro e seguire i workshop.","title":"Prerequisiti Linux \u0026#x1F427;","type":"workshops"},{"content":" Installazione VS Code # Vai su sito di download di VS Code Scarica ed installa la versione per macOS In questa guida viene usata macOS Sequoia. Una volta scaricato il file, installa VS Code Clicca CTRL+SPACE e cerca Code. Clicca sull\u0026rsquo;icona di VS Code Dovresti ora vedere l\u0026rsquo;interfaccia di VS Code VS Code potrebbe chiederti se ti fidi dell\u0026rsquo;autore della cartella. Questo aspetto Ã¨ importante quando vengono usate repo git, per il momento non fa differenza. Clicca \u0026ldquo;SÃ¬\u0026rdquo;. Installazione prerequisiti # Per poter installare e configurare la toolchain ESP-IDF, Ã¨ necessario avere giÃ  installati Python e git. Nel seguito si userÃ  il gestione pacchetti homebrew (brew).\nInstallazione homebrew\nPer installare homebrew:\nApri un terminale Digita:\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Python # La toolchain ESP-IDF usa la versione di sistema di python. Puoi verificare la versione di python digitando sul terminale\npython 3 --version Nel caso python non fosse giÃ  presente, puoi installarlo col seguente comando da terminale:\nbrew install python3 git # Lo sviluppo di ESP-IDF Ã¨ basato su git, il tool di controllo di versione usato, tra gli altri anche per lo sviluppo del kernel Linux. git Ã¨ la base su cui si fonda GitHub.\nPer installare git:\nApri un terminale Installa git:\nsudo brew install git Controlla che git sia stato installato correttamente:\n\u0026gt; git --version \u0026gt; git version 2.43.0 Installazione prerequisiti # Per utilizzare la toolchain ESP-IDF, Ã¨ necessario installare i tool rimanenti.\nApri un terminale Digita:\nbrew install cmake ninja dfu-util Durante il processo di installazione, potresti aver incontrato dei problemi. Fai riferimento alla sezione Troubleshooting per vedere l\u0026rsquo;errore riscontrato rientra nella casistica indicata.\nProssimi step # Prosegui con il prossimo passo.\nTroubleshooting # Durante il processo di installazione potresti incontrare alcuni errori comuni. Di seguito sono riportati i piÃ¹ frequenti con la relativa causa e soluzione.\nXcode Command Line Tools non installati # Errore\nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun Causa I tool da riga di comando di Xcode non sono installati o non correttamente configurati.\nSoluzione\nxcode-select --install Toolchain non trovata (xtensa-esp32-elf) # Errore\nWARNING: directory for tool xtensa-esp32-elf version esp-2021r2-patch3-8.4.0 is present, but tool was not found ERROR: tool xtensa-esp32-elf has no installed versions. Please run \u0026#39;install.sh\u0026#39; to install it. Causa Su macOS con architettura Apple Silicon, alcuni strumenti binari richiedono Rosetta 2 per funzionare.\nSoluzione\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license Errore â€œBad CPU type in executableâ€ # Errore\nzsh: bad CPU type in executable: ~/.espressif/tools/xtensa-esp32-elf/esp-2021r2-patch3-8.4.0/xtensa-esp32-elf/bin/xtensa-esp32-elf-gcc Causa Lâ€™eseguibile richiede Rosetta 2 per poter essere eseguito su sistemi macOS M1/M2/M3.\nSoluzione\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license ","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-setup/installation_macos/","section":"Workshops","summary":"Questa guida presenta i passi preliminari per impostare il setup di lavoro e seguire i workshop.","title":"Prerequisiti macOS \u0026#x1F34E;","type":"workshops"},{"content":" Installazione VS Code # Vai su sito di download di VS Code Scarica ed installa la versione per Windows In questa guida viene usato Windows 11 Una volta scaricato il file .exe, fai doppio click e segui la procedura di installazione Finita l\u0026rsquo;installazione, per aprire VS Code ci sono due strade.\nApri VS Code da menÃ¹ Apri VS Code da una cartella Siccome Ã¨ spesso utile aprire l\u0026rsquo;editor direttamente nella cartella, seguiremo questa seconda strada.\nApri VS Code da una cartella # Crea una nuova cartella tmp Clicca tasto destro del mouse all\u0026rsquo;interno della cartella in Explorer Sul menÃ¹ seleziona Show more options Clicca su Open with Code Dovresti ora vedere l\u0026rsquo;interfaccia di VS Code VS Code potrebbe chiederti se ti fidi dell\u0026rsquo;autore della cartella. Questo aspetto Ã¨ importante quando vengono usate repo git, per il momento non fa differenza. Clicca \u0026ldquo;SÃ¬\u0026rdquo;. Installazione prerequisiti # Non ci sono da installare altri prerequisiti. Questi sono infatti gestiti automaticamente durante la configurazione dell\u0026rsquo;estensione ESP-IDF.\nProssimi step # Prosegui con il prossimo passo.\n","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-setup/installation_windows/","section":"Workshops","summary":"Questa guida presenta i passi preliminari per impostare il setup di lavoro e seguire i workshop.","title":"Prerequisiti Windows \u0026#x1FA9F;","type":"workshops"},{"content":"","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/","section":"Workshops","summary":"","title":"Workshops","type":"workshops"},{"content":"","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/series/ws00a/","section":"Series","summary":"","title":"WS00A","type":"series"},{"content":"","date":"12 novembre 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/series/ws00b/","section":"Series","summary":"","title":"WS00B","type":"series"},{"content":"In questo esercizio estenderai la funzionalitÃ  dell\u0026rsquo;Esercizio 2.1 introducendo una sorgente di eventi aggiuntiva: quando viene premuto GPIO9, un evento \u0026ldquo;alarm\u0026rdquo; viene inviato al sistema.\nIl codice per rilevare la pressione di un GPIO Ã¨ fornito di seguito.\nObiettivi dell\u0026rsquo;esercizio # Integrare la logica aggiuntiva nell\u0026rsquo;event loop esistente. Usare lo stesso ALARM_EVENT_BASE giÃ  utilizzato per il trigger dell\u0026rsquo;allarme. Creare un nuovo event_id ALARM_EVENT_BUTTON per differenziarlo da ALARM_EVENT_CHECK. Suggerimenti # Esiste una versione alternativa di esp_event_post chiamata esp_event_isr_post. Codice per leggere il GPIO # #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;esp_attr.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #define GPIO_INPUT_IO_9 9 #define ESP_INTR_FLAG_DEFAULT 0 static const char *TAG = \u0026#34;example\u0026#34;; // ISR handler static void gpio_isr_handler(void* arg) { uint32_t gpio_num = (uint32_t) arg; ESP_EARLY_LOGI(TAG, \u0026#34;GPIO[%d] interrupt triggered\u0026#34;, gpio_num); } void app_main(void) { gpio_config_t io_conf = { .intr_type = GPIO_INTR_NEGEDGE, // Falling edge interrupt .mode = GPIO_MODE_INPUT, // Set as input mode .pin_bit_mask = (1ULL \u0026lt;\u0026lt; GPIO_INPUT_IO_9), .pull_up_en = GPIO_PULLUP_ENABLE, // Enable pull-up .pull_down_en = GPIO_PULLDOWN_DISABLE, }; gpio_config(\u0026amp;io_conf); // Install GPIO ISR service gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT); // Hook ISR handler for specific GPIO pin gpio_isr_handler_add(GPIO_INPUT_IO_9, gpio_isr_handler, (void*) GPIO_INPUT_IO_9); ESP_LOGI(TAG, \u0026#34;GPIO 9 configurato come input con interrupt su fronte di discesa\u0026#34;); } Codice soluzione dell\u0026rsquo;Esercizio # Mostra il codice completo #include \u0026#34;cloud_manager.h\u0026#34; #include \u0026#34;temperature_sensor.h\u0026#34; #include \u0026#34;alarm.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; #include \u0026#34;esp_event.h\u0026#34; #include \u0026#34;esp_timer.h\u0026#34; #include \u0026#34;driver/gpio.h\u0026#34; #include \u0026#34;esp_attr.h\u0026#34; #define TEMPERATURE_MEAS_PERIOD_US (5 * 1000000) #define ALARM_CHECK_PERIOD_US (200 * 1000) #define GPIO_INPUT_IO_9 9 #define ESP_INTR_FLAG_DEFAULT 0 static const char *TAG = \u0026#34;assignment2_2\u0026#34;; // EVENTI ESP_EVENT_DEFINE_BASE(TEMP_EVENT_BASE); ESP_EVENT_DEFINE_BASE(ALARM_EVENT_BASE); static bool previous_alarm_set = false; typedef enum { TEMP_EVENT_MEASURE, } temp_event_id_t; typedef enum { ALARM_EVENT_CHECK, ALARM_EVENT_BUTTON } alarm_event_id_t; // GPIO // ISR handler static void gpio_isr_handler(void* arg) { uint32_t gpio_num = (uint32_t) arg; // Ora che pubblichiamo l\u0026#39;evento, rimuoviamo il log: // Non Ã¨ consigliato fare log o print dentro una ISR // // ESP_EARLY_LOGI(TAG, \u0026#34;GPIO[%d] interrupt triggered\u0026#34;, gpio_num); esp_event_isr_post(ALARM_EVENT_BASE, ALARM_EVENT_BUTTON, NULL, 0, 0); } static temperature_sensor_t *sensor = NULL; static alarm_t *alarm = NULL; static cloud_manager_t *cloud = NULL; static void temp_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { float temp; if (temperature_sensor_read_celsius(sensor, \u0026amp;temp) == ESP_OK) { cloud_manager_send_temperature(cloud, temp); } else { ESP_LOGW(\u0026#34;APP\u0026#34;, \u0026#34;Impossibile leggere la temperatura\u0026#34;); } } static void alarm_event_button_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALLARME ATTIVO!!\u0026#34;); cloud_manager_send_alarm(cloud); } static void alarm_event_handler(void* handler_arg, esp_event_base_t base, int32_t id, void* event_data) { bool alarm_state = is_alarm_set(alarm); if (alarm_state \u0026amp;\u0026amp; !previous_alarm_set) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;ALLARME ATTIVO!!\u0026#34;); cloud_manager_send_alarm(cloud); } previous_alarm_set = alarm_state; } static void temp_timer_callback(void* arg) { esp_event_post(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, NULL, 0, 0); } static void alarm_timer_callback(void* arg) { esp_event_post(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, NULL, 0, 0); } void app_main(void) { ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Avvio...\u0026#34;); ESP_ERROR_CHECK(esp_event_loop_create_default()); sensor = temperature_sensor_create(); alarm = alarm_create(); cloud = cloud_manager_create(); ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Connessione in corso...\u0026#34;); ESP_ERROR_CHECK(cloud_manager_connect(cloud)); ESP_LOGI(\u0026#34;APP\u0026#34;, \u0026#34;Connesso!\u0026#34;); // Registrazione degli handler degli eventi ESP_ERROR_CHECK(esp_event_handler_register(TEMP_EVENT_BASE, TEMP_EVENT_MEASURE, temp_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_CHECK, alarm_event_handler, NULL)); ESP_ERROR_CHECK(esp_event_handler_register(ALARM_EVENT_BASE, ALARM_EVENT_BUTTON, alarm_event_button_handler, NULL)); // Creazione e avvio dei timer periodici const esp_timer_create_args_t temp_timer_args = { .callback = \u0026amp;temp_timer_callback, .name = \u0026#34;temp_timer\u0026#34; }; esp_timer_handle_t temp_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;temp_timer_args, \u0026amp;temp_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(temp_timer, TEMPERATURE_MEAS_PERIOD_US)); const esp_timer_create_args_t alarm_timer_args = { .callback = \u0026amp;alarm_timer_callback, .name = \u0026#34;alarm_timer\u0026#34; }; esp_timer_handle_t alarm_timer; ESP_ERROR_CHECK(esp_timer_create(\u0026amp;alarm_timer_args, \u0026amp;alarm_timer)); // GPIO gpio_config_t io_conf = { .intr_type = GPIO_INTR_NEGEDGE, // Falling edge interrupt .mode = GPIO_MODE_INPUT, // Set as input mode .pin_bit_mask = (1ULL \u0026lt;\u0026lt; GPIO_INPUT_IO_9), .pull_up_en = GPIO_PULLUP_ENABLE, // Enable pull-up .pull_down_en = GPIO_PULLDOWN_DISABLE, }; gpio_config(\u0026amp;io_conf); // Installazione del servizio ISR per GPIO gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT); // Collegamento dell\u0026#39;handler ISR per il pin specifico gpio_isr_handler_add(GPIO_INPUT_IO_9, gpio_isr_handler, (void*) GPIO_INPUT_IO_9); // Il task principale puÃ² ora dormire while (1) { vTaskDelay(pdMS_TO_TICKS(1000)); } // Pulizia (non raggiungibile in questo esempio) cloud_manager_disconnect(cloud); cloud_manager_delete(cloud); temperature_sensor_delete(sensor); alarm_delete(alarm); } Puoi trovare l\u0026rsquo;intero progetto della soluzione nella cartella assignment_2_2 sul repository GitHub.\nProssimo passo # Prossimo passo: Lezione 3\nOppure torna al menÃ¹ di navigazione\n","date":"5 agosto 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-2-2/","section":"Workshops","summary":"Event loop: aggiungere un evento GPIO esterno","title":"ESP-IDF Avanzato - Esercizio  2.2","type":"workshops"},{"content":" Core dump # Per questo esercizio, devi partire dal progetto assignment_3_2_base.\nObiettivi dell\u0026rsquo;esercizio # Abilitare il core dump in menuconfig Compilare ed eseguire l\u0026rsquo;applicazione Analizzare il core dump Correggere i bug nel progetto Ricompilare ed eseguire nuovamente l\u0026rsquo;applicazione Abilitare il core dump # Apri menuconfig: \u0026gt; ESP-IDF: SDK Configuration Editor (menuconfig) Imposta Core Dump â†’ Data destination â†’ Flash \u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Compilare ed eseguire l\u0026rsquo;applicazione # Ora attendi che si verifichi il crash.\nQuando si verifica, interrompi l\u0026rsquo;esecuzione (CTRL + ]) Crea un nuovo terminale \u0026gt; ESP-IDF: Open ESP-IDF Terminal esegui idf.py coredump-info \u0026gt; coredump.txt Apri il file coredump.txt Analizzare il core dump # Ora osserva attentamente il file core dump.\nClicca qui se non sei riuscito a generare coredump.txt Executing action: coredump-info Serial port /dev/cu.usbmodem1131101 Connecting... Detecting chip type... ESP32-C3 =============================================================== ==================== ESP32 CORE DUMP START ==================== Crashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;, GDB name: \u0026#39;process 1070202648\u0026#39; Crashed task is not in the interrupt context ================== CURRENT THREAD REGISTERS =================== ra 0x4200d822\t0x4200d822 \u0026lt;is_alarm_set+20\u0026gt; sp 0x3fc9fe50\t0x3fc9fe50 gp 0x3fc94600\t0x3fc94600 \u0026lt;country_info_24ghz+200\u0026gt; tp 0x3fc9ff10\t0x3fc9ff10 t0 0x4005890e\t1074104590 t1 0x90000000\t-1879048192 t2 0xffffffff\t-1 fp 0x0\t0x0 s1 0x8b7f7a\t9142138 a0 0x8b7f7a\t9142138 a1 0x0\t0 a2 0x8b7f7a0\t146274208 a3 0x0\t0 a4 0x4ddf\t19935 a5 0x4c4b3f\t4999999 a6 0x60023000\t1610756096 a7 0xa\t10 s2 0x0\t0 s3 0x0\t0 s4 0xffffffff\t-1 s5 0x0\t0 s6 0xffffffff\t-1 s7 0x0\t0 s8 0x0\t0 s9 0x0\t0 s10 0x0\t0 s11 0x0\t0 t3 0x0\t0 t4 0xfe42\t65090 t5 0x0\t0 t6 0x0\t0 pc 0x4200d840\t0x4200d840 \u0026lt;is_alarm_set+50\u0026gt; ==================== CURRENT THREAD STACK ===================== #0 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 #1 0x4200d48c in alarm_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:66 #2 0x420b1944 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x4c4b3f\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #3 0x420b2290 in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #4 0x420b2388 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================== THREADS INFO ========================= Id Target Id Frame * 1 process 1070202648 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 2 process 1070198548 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 3 process 1070209148 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 4 process 1070196668 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 5 process 1070253776 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 6 process 1070222780 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 7 process 1070191796 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 TCB NAME PRIO C/B STACK USED/FREE ---------- ---------------- -------- ---------------- 0x3fc9ff18 sys_evt 20/20 352/2460 0x3fc9ef14 IDLE 0/0 208/1312 0x3fca187c tiT 18/18 336/3240 0x3fc9e7bc main 1/1 336/3752 0x3fcac6d0 mqtt_task 5/5 768/5372 0x3fca4dbc wifi 23/23 336/6312 0x3fc9d4b4 esp_timer 22/22 224/3856 ==================== THREAD 1 (TCB: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39;) ===================== #0 is_alarm_set (alarm=0x0) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/components/alarm/alarm.c:40 #1 0x4200d48c in alarm_event_handler (handler_arg=\u0026lt;optimized out\u0026gt;, base=\u0026lt;optimized out\u0026gt;, id=\u0026lt;optimized out\u0026gt;, event_data=\u0026lt;optimized out\u0026gt;) at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:66 #2 0x420b1944 in handler_execute (loop=loop@entry=0x3fc9f13c, handler=\u0026lt;optimized out\u0026gt;, post=\u0026lt;error reading variable: Cannot access memory at address 0x4c4b3f\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:136 #3 0x420b2290 in esp_event_loop_run (event_loop=event_loop@entry=0x3fc9f13c, ticks_to_run=ticks_to_run@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:696 #4 0x420b2388 in esp_event_loop_run_task (args=0x3fc9f13c, args@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_event/esp_event.c:106 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 2 (TCB: 0x3fc9ef14, name: \u0026#39;IDLE\u0026#39;) ===================== #0 0x403851d4 in esp_cpu_wait_for_intr () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_hw_support/cpu.c:64 #1 0x42015ce8 in esp_vApplicationIdleHook () at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/freertos_hooks.c:58 #2 0x4038859c in prvIdleTask (pvParameters=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:4341 #3 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 3 (TCB: 0x3fca187c, name: \u0026#39;tiT\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca099c, pvBuffer=pvBuffer@entry=0x3fca182c, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=6) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x42086ae8 in sys_arch_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c, timeout=60) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:313 #4 0x420710ea in tcpip_timeouts_mbox_fetch (mbox=mbox@entry=0x3fc9b7c0 \u0026lt;tcpip_mbox\u0026gt;, msg=msg@entry=0x3fca182c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:104 #5 0x420711dc in tcpip_thread (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:142 #6 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 4 (TCB: 0x3fc9e7bc, name: \u0026#39;main\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40388d04 in vTaskDelay (xTicksToDelay=xTicksToDelay@entry=100) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:1588 #3 0x4200d7e8 in app_main () at /Users/francesco/Documents/articles/devrel-advanced-workshop-code/assignment_3_2/main/app_main.c:136 #4 0x420b420e in main_task (args=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/app_startup.c:208 #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 5 (TCB: 0x3fcac6d0, name: \u0026#39;mqtt_task\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x403875bc in xQueueSemaphoreTake (xQueue=0x3fcac8e0, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1901 #3 0x42086910 in sys_arch_sem_wait (sem=sem@entry=0x3fcac8d0, timeout=timeout@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/port/freertos/sys_arch.c:165 #4 0x420713d4 in tcpip_send_msg_wait_sem (fn=\u0026lt;optimized out\u0026gt;, apimsg=apimsg@entry=0x3fcae33c, sem=0x3fcac8d0) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/tcpip.c:461 #5 0x42088840 in netconn_gethostbyname_addrtype (name=name@entry=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, addr=addr@entry=0x3fcae3a8, dns_addrtype=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/api_lib.c:1333 #6 0x4206de2a in lwip_getaddrinfo (nodename=nodename@entry=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, servname=servname@entry=0x0, hints=hints@entry=0x3fcae3fc, res=res@entry=0x3fcae41c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/lwip/src/api/netdb.c:495 #7 0x42021468 in getaddrinfo (nodename=0x3fcac8b8 \u0026lt;error: Cannot access memory at address 0x3fcac8b8\u0026gt;, servname=0x0, hints=0x3fcae3fc, res=0x3fcae41c) at /Users/francesco/esp/v5.4.2/esp-idf/components/lwip/include/lwip/netdb.h:23 #8 esp_tls_hostname_to_fd (host=\u0026lt;optimized out\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=1883, addr_family=\u0026lt;optimized out\u0026gt;, address=address@entry=0x3fcae464, fd=fd@entry=0x3fcae460) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:210 #9 0x420218c4 in tcp_connect (host=host@entry=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=port@entry=1883, cfg=cfg@entry=0x3fcac83c, error_handle=error_handle@entry=0x3fcac824, sockfd=sockfd@entry=0x3fcac8a0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:359 #10 0x42021ebc in esp_tls_plain_tcp_connect (host=host@entry=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, hostlen=\u0026lt;optimized out\u0026gt;, port=port@entry=1883, cfg=cfg@entry=0x3fcac83c, error_handle=error_handle@entry=0x3fcac824, sockfd=sockfd@entry=0x3fcac8a0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp-tls/esp_tls.c:533 #11 0x42023e06 in tcp_connect (t=\u0026lt;optimized out\u0026gt;, host=0x3fca24cc \u0026lt;error: Cannot access memory at address 0x3fca24cc\u0026gt;, port=1883, timeout_ms=10000) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport_ssl.c:148 #12 0x42023210 in esp_transport_connect (t=\u0026lt;optimized out\u0026gt;, host=\u0026lt;optimized out\u0026gt;, port=\u0026lt;optimized out\u0026gt;, timeout_ms=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/tcp_transport/transport.c:123 #13 0x4200f628 in esp_mqtt_task (pv=0x3fca1a28, pv@entry=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/mqtt/esp-mqtt/mqtt_client.c:1620 #14 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 6 (TCB: 0x3fca4dbc, name: \u0026#39;wifi\u0026#39;) ===================== #0 0x4038345e in esp_crosscore_int_send_yield (core_id=core_id@entry=0) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_system/crosscore_int.c:121 #1 0x40387a5c in vPortYield () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:638 #2 0x40387450 in xQueueReceive (xQueue=0x3fca2c9c, pvBuffer=0x3fca4d48, xTicksToWait=\u0026lt;optimized out\u0026gt;, xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/queue.c:1659 #3 0x420b3d64 in queue_recv_wrapper (queue=\u0026lt;optimized out\u0026gt;, item=\u0026lt;optimized out\u0026gt;, block_time_tick=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_wifi/esp32c3/esp_adapter.c:238 #4 0x400407be in ppTask () #5 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ==================== THREAD 7 (TCB: 0x3fc9d4b4, name: \u0026#39;esp_timer\u0026#39;) ===================== #0 0x40387998 in vPortClearInterruptMaskFromISR (prev_int_level=1) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:515 #1 0x40387a28 in vPortExitCritical () at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:624 #2 0x40389774 in ulTaskGenericNotifyTake (uxIndexToWait=uxIndexToWait@entry=0, xClearCountOnExit=xClearCountOnExit@entry=1, xTicksToWait=xTicksToWait@entry=4294967295) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/tasks.c:5759 #3 0x42017e9a in timer_task (arg=\u0026lt;error reading variable: value has been optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/esp_timer/src/esp_timer.c:459 #4 0x403877cc in vPortTaskWrapper (pxCode=\u0026lt;optimized out\u0026gt;, pvParameters=\u0026lt;optimized out\u0026gt;) at /Users/francesco/esp/v5.4.2/esp-idf/components/freertos/FreeRTOS-Kernel/portable/riscv/port.c:255 ======================= ALL MEMORY REGIONS ======================== Name Address Size Attrs .rtc.text 0x50000000 0x0 RW .rtc.force_fast 0x50000000 0x1c RW A .rtc_noinit 0x5000001c 0x0 RW .rtc.force_slow 0x5000001c 0x0 RW .iram0.text 0x40380000 0x13d0a R XA .dram0.data 0x3fc93e00 0x2ed8 RW A .flash.text 0x42000020 0xb4fd8 R XA .flash.appdesc 0x3c0c0020 0x100 R A .flash.rodata 0x3c0c0120 0x1ff3c RW A .eh_frame_hdr 0x3c0e005c 0x0 RW .eh_frame 0x3c0e005c 0x0 RW .flash.tdata 0x3c0e005c 0x0 RW .iram0.data 0x40393e00 0x0 RW .iram0.bss 0x40393e00 0x0 RW .dram0.heap_start 0x3fc9b8e0 0x0 RW .coredump.tasks.data 0x3fc9ff18 0x150 RW .coredump.tasks.data 0x3fc9fdb0 0x160 RW .coredump.tasks.data 0x3fc9ef14 0x150 RW .coredump.tasks.data 0x3fc9ee30 0xd0 RW .coredump.tasks.data 0x3fca187c 0x150 RW .coredump.tasks.data 0x3fca1720 0x150 RW .coredump.tasks.data 0x3fc9e7bc 0x150 RW .coredump.tasks.data 0x3fc9e660 0x150 RW .coredump.tasks.data 0x3fcac6d0 0x150 RW .coredump.tasks.data 0x3fcae240 0x300 RW .coredump.tasks.data 0x3fca4dbc 0x150 RW .coredump.tasks.data 0x3fca4c60 0x150 RW .coredump.tasks.data 0x3fc9d4b4 0x150 RW .coredump.tasks.data 0x3fc9d3c0 0xe0 RW ===================== ESP32 CORE DUMP END ===================== =============================================================== Done! Identificare il task che ha causato il crash # Il core dump inizia con:\nCrashed task handle: 0x3fc9ff18, name: \u0026#39;sys_evt\u0026#39; Crashed task is not in the interrupt context Da questo possiamo concludere:\nIl crash Ã¨ avvenuto nel task FreeRTOS chiamato sys_evt. Il crash non Ã¨ avvenuto durante un interrupt, quindi Ã¨ un crash in un task normale. Osservare il program counter (PC) e lo stack trace # Il dump dei registri mostra:\npc 0x4200d840\t0x4200d840 \u0026lt;is_alarm_set+50\u0026gt; ra 0x4200d822\t0x4200d822 \u0026lt;is_alarm_set+20\u0026gt; sp 0x3fc9fe50 Questo significa che:\nIl program counter (PC) si trova all\u0026rsquo;indirizzo 0x4200d840, all\u0026rsquo;interno della funzione is_alarm_set, precisamente all\u0026rsquo;offset +50 byte. L\u0026rsquo;indirizzo di ritorno (ra) Ã¨ anchâ€™esso dentro is_alarm_set, quindi il crash Ã¨ avvenuto allâ€™interno di quella funzione. Esaminare lo stack trace # Stack trace (in ordine inverso di chiamata):\n#0 is_alarm_set (alarm=0x0) at alarm.c:40 #1 alarm_event_handler at app_main.c:66 #2 handler_execute (esp_event.c:136) #3 esp_event_loop_run (esp_event.c:696) #4 esp_event_loop_run_task (esp_event.c:106) #5 vPortTaskWrapper (port.c:255) Il crash Ã¨ originato dalla chiamata a is_alarm_set da parte di alarm_event_handler. Questo handler Ã¨ chiamato dall\u0026rsquo;event loop (esp_event_loop_run). Concentrarsi sugli argomenti della funzione # Osserva gli argomenti di is_alarm_set:\n#0 is_alarm_set (alarm=0x0) at alarm.c:40 L\u0026rsquo;argomento alarm Ã¨ 0x0 (puntatore NULL) (!) Diagnosticare il motivo del crash # Il crash Ã¨ avvenuto dentro is_alarm_set con un puntatore NULL come argomento. Di solito, questo significa:\nis_alarm_set dereferenzia alarm senza verificare se fosse NULL. PoichÃ© alarm Ã¨ NULL, accedere ai suoi campi ha causato un accesso a memoria non valido, provocando il crash. Controllare il sorgente # La riga del crash Ã¨ alarm.c:40. Se guardiamo quella linea:\nreturn alarm-\u0026gt;last_state; Dereferenziare alarm senza controllo NULL provoca un fault se alarm == NULL. Qualche riga sopra troviamo:\nalarm = NULL; che Ã¨ probabilmente il nostro bug.\nRicompilare ed eseguire l\u0026rsquo;applicazione # Rimuovi la riga e il blocco else inutile, ottenendo la funzione is_alarm_set come segue:\nbool is_alarm_set(alarm_t *alarm) { int64_t now_us = esp_timer_get_time(); int64_t elapsed_us = now_us - alarm-\u0026gt;last_check_time_us; if (elapsed_us \u0026gt;= CONFIG_ALARM_REFRESH_INTERVAL_MS * 1000) { uint32_t rand_val = esp_random() % 100; alarm-\u0026gt;last_state = rand_val \u0026lt; CONFIG_ALARM_THRESHOLD_PERCENT; alarm-\u0026gt;last_check_time_us = now_us; } return alarm-\u0026gt;last_state; } Ricompila ed esegui l\u0026rsquo;applicazione:\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor Un altro crash! Se hai ancora tempo, prova a risolverlo passando a Esercizio 3.3.\nConclusione # In questo esercizio, abbiamo imparato come creare un core dump e come analizzarlo per capire il motivo di un crash. Lâ€™analisi del core dump Ã¨ uno strumento molto potente per il debug delle applicazioni.\nProssimi passi # Se hai ancora tempo: Esercizio 3.3\nAltrimenti: Lezione 4\nOppure torna al menÃ¹ di navigazione\n","date":"5 agosto 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-advanced/assignment-3-2/","section":"Workshops","summary":"Analizzare il core dump (guidato)","title":"ESP-IDF Avanzato - Esercizio 3.2","type":"workshops"},{"content":" Creare un nuovo progetto da hello_world e cambiare il testo mostrato (Guidato)\nPassi dell\u0026rsquo;esercizio # In questo esercizio\nCreerai un progetto a partire dall\u0026rsquo;esempio hello_world Cambierai il testo di uscita. Prima di iniziare, assicurati di aver installato tutto il necessario.\nIn questo workshop utilizzeremo lâ€™estensione ESP-IDF per VS Code. Se non lâ€™hai ancora installata, segui queste istruzioni. Passo 1: Creare e testare un progetto da un esempio # In questa sezione, impareremo a:\nCreare un nuovo progetto a partire da un esempio Compilare il progetto Programmare il modulo e monitorare l\u0026rsquo;uscita Tieni presente che la maggior parte dei comandi in VS Code vengono eseguiti tramite la palette dei comandi, che puoi aprire premendo Ctrl+Shift+P (oppure Cmd+Shift+P su macOS).\nIn questa guida, i comandi da digitare nella palette dei comandi sono contrassegnati con il simbolo \u0026gt;. Di solito Ã¨ sufficiente scrivere alcune lettere del comando: comparirÃ  un menu a discesa con le opzioni disponibili e basterÃ  cliccare quella richiesta. Creare un nuovo progetto a partire da un esempio # Apri VS Code \u0026gt; ESP-IDF: Show Example Project (Se richiesto) Seleziona la versione di ESP-IDF Clicca su get_started â†’ hello_world Nella nuova scheda, clicca sul pulsante Select Location for Creating \u0026quot;hello_world\u0026quot; Example Fig.1 - Creazione di un nuovo progetto da esempio\nSi aprirÃ  un pop-up che vi chiede se vi fidate dell\u0026rsquo;autore della cartella. Si tratta di una configurazione utile quando si usa git, in questo caso Ã¨ poco rilevante. Clicca sÃ¬ per proseguire. Si aprirÃ  una nuova finestra con la seguente struttura di file:\nFig.2 - File dellâ€™esempio hello_world\nPer ora puoi ignorare le cartelle .vscode, .devcontainer e build. Lavorerai principalmente sul file main/hello_world_main.c.\nCompilare il progetto # Per compilare (build) il progetto, devi prima indicare al compilatore quale SoC (detto target) stai usando. Puoi farlo direttamente dallâ€™IDE:\n\u0026gt; ESP-IDF: Set Espressif Device Target Nel menu a discesa, scegli esp32c3 â†’ ESP32-C3 chip (via builtin USB-JTAG) Ora sei pronto per compilare il progetto:\n\u0026gt; ESP-IDF: Build Your Project\nPuoi anche cliccare sulla piccola icona ðŸ”§ nella barra inferiore Nella parte inferiore dellâ€™IDE si aprirÃ  un terminale che mostrerÃ  il risultato della compilazione e le dimensioni del file binario generato.\nFig.3 - Risultato della compilazione\nSe riscontri problemi in questa fase, puÃ² essere utile eseguire una pulizia completa del progetto con il comando \u0026gt; ESP-IDF: Full clean project. Programmare il modulo e monitorare l\u0026rsquo;uscita # Per vedere il firmware in esecuzione, devi caricarlo sul dispositivo (flash) e leggere lâ€™output emesso sulla porta seriale (monitor).\nCollega la scheda al computer (se non l\u0026rsquo;hai giÃ  fatto) Verifica che il dispositivo venga riconosciuto\nSe non sai come, controlla le seguenti pagine windows - linux/macos Prendi nota del nome della porta a cui Ã¨ stato assegnato il dispositivo Espressif Su Windows il nome della porta inizia con COM Su Linux/macOS il nome della porta inizia con tty o ttyUSB Imposta la porta su VS Code \u0026gt;ESP-IDF: Select Port to Use (COM, tty, usbserial) Se riscontri problemi, consulta la guida Establish Serial Connection with ESP32. Ora puoi caricare il programma sul modulo e avviare il monitor:\n\u0026gt; ESP-IDF: Build, Flash and Start a Monitor on Your Device Nel menÃ¹ a tendina, seleziona UART Nel terminale dovresti vedere la stringa Hello World! e il conto alla rovescia prima del reset.\nPasso 2: Modificare il testo di output # Trova la stringa di output e modificala in Hello LED.\nSoluzione Esercizio # Codice Esercizio main/hello_world_main.c\n/* * SPDX-FileCopyrightText: 2010-2022 Espressif Systems (Shanghai) CO LTD * * SPDX-License-Identifier: CC0-1.0 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;inttypes.h\u0026gt; #include \u0026#34;sdkconfig.h\u0026#34; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;esp_chip_info.h\u0026#34; #include \u0026#34;esp_flash.h\u0026#34; #include \u0026#34;esp_system.h\u0026#34; void app_main(void) { printf(\u0026#34;Hello LED!\\n\u0026#34;); /* Print chip information */ esp_chip_info_t chip_info; uint32_t flash_size; esp_chip_info(\u0026amp;chip_info); printf(\u0026#34;This is %s chip with %d CPU core(s), %s%s%s%s, \u0026#34;, CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features \u0026amp; CHIP_FEATURE_WIFI_BGN) ? \u0026#34;WiFi/\u0026#34; : \u0026#34;\u0026#34;, (chip_info.features \u0026amp; CHIP_FEATURE_BT) ? \u0026#34;BT\u0026#34; : \u0026#34;\u0026#34;, (chip_info.features \u0026amp; CHIP_FEATURE_BLE) ? \u0026#34;BLE\u0026#34; : \u0026#34;\u0026#34;, (chip_info.features \u0026amp; CHIP_FEATURE_IEEE802154) ? \u0026#34;, 802.15.4 (Zigbee/Thread)\u0026#34; : \u0026#34;\u0026#34;); unsigned major_rev = chip_info.revision / 100; unsigned minor_rev = chip_info.revision % 100; printf(\u0026#34;silicon revision v%d.%d, \u0026#34;, major_rev, minor_rev); if(esp_flash_get_size(NULL, \u0026amp;flash_size) != ESP_OK) { printf(\u0026#34;Get flash size failed\u0026#34;); return; } printf(\u0026#34;%\u0026#34; PRIu32 \u0026#34;MB %s flash\\n\u0026#34;, flash_size / (uint32_t)(1024 * 1024), (chip_info.features \u0026amp; CHIP_FEATURE_EMB_FLASH) ? \u0026#34;embedded\u0026#34; : \u0026#34;external\u0026#34;); printf(\u0026#34;Minimum free heap size: %\u0026#34; PRIu32 \u0026#34; bytes\\n\u0026#34;, esp_get_minimum_free_heap_size()); for (int i = 10; i \u0026gt;= 0; i--) { printf(\u0026#34;Restarting in %d seconds...\\n\u0026#34;, i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\u0026#34;Restarting now.\\n\u0026#34;); fflush(stdout); esp_restart(); } Prossimo passo # Prossimo esercizio â†’ Esercizio 1.2\nOppure torna al menÃ¹ di navigazione\n","date":"5 agosto 2025","externalUrl":null,"permalink":"/workshop-esp-idf/it/workshops/esp-idf-basic/assignment-1-1/","section":"Workshops","summary":"","title":"ESP-IDF Base - Esercizio 1.1","type":"workshops"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/it/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/it/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/authors/francesco-bez/","section":"Developer Portal Authors","summary":"","title":"Francesco Bez","type":"authors"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/it/platforms/","section":"Platforms","summary":"","title":"Platforms","type":"platforms"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/it/socs/","section":"Socs","summary":"","title":"Socs","type":"socs"},{"content":"","externalUrl":null,"permalink":"/workshop-esp-idf/it/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]